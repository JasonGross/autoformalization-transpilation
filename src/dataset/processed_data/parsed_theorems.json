[
  {
    "name": "silly1",
    "statement": "Theorem silly1 : forall n, 1 + n = S n.",
    "proof": "Proof.try reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "silly2",
    "statement": "Theorem silly2 : forall (P : Prop), P -> P.",
    "proof": "Proof.intros P HP.\n  Fail reflexivity.\n  try reflexivity.\n  apply HP.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "andb_eq_orb",
    "statement": "Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "add_assoc",
    "statement": "Theorem add_assoc : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "app_length",
    "statement": "Theorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "proof": "Proof.intros; induction lst1;\n    [reflexivity | simpl; rewrite IHlst1; reflexivity].\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "app_length'",
    "statement": "Theorem app_length' : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "proof": "Proof.intros; induction lst1;\n    [idtac | simpl; rewrite IHlst1];\n    reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "add_assoc'",
    "statement": "Theorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "In10",
    "statement": "Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "proof": "Proof.repeat (try (left; reflexivity); right).\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "In10'",
    "statement": "Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "proof": "Proof.repeat (left; reflexivity).\n  repeat (right; try (left; reflexivity)).\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "ev100",
    "statement": "Theorem ev100: ev 100.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "hyp_name",
    "statement": "Theorem hyp_name : forall (P : Prop), P -> P.",
    "proof": "Proof.intros P HP. apply HP.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "no_hyp_name",
    "statement": "Theorem no_hyp_name : forall (P : Prop), P -> P.",
    "proof": "Proof.intros. assumption.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "false_assumed",
    "statement": "Theorem false_assumed : False -> 0 = 1.",
    "proof": "Proof.intros H. destruct H.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "false_assumed'",
    "statement": "Theorem false_assumed' : False -> 0 = 1.",
    "proof": "Proof.intros. contradiction.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "contras",
    "statement": "Theorem contras : forall (P : Prop), P -> ~P -> 0 = 1.",
    "proof": "Proof.intros P HP HNP. exfalso. apply HNP. apply HP.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "contras'",
    "statement": "Theorem contras' : forall (P : Prop), P -> ~P -> 0 = 1.",
    "proof": "Proof.intros. contradiction.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "many_eq",
    "statement": "Theorem many_eq : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p].",
    "proof": "Proof.intros n m o p Hnm Hop. rewrite Hnm. rewrite Hop. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "many_eq'",
    "statement": "Theorem many_eq' : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p].",
    "proof": "Proof.intros. subst. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "lia_succeed1",
    "statement": "Theorem lia_succeed1 : forall (n : nat),\n  n > 0 -> n * 2 > n.",
    "proof": "Proof.lia. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "lia_succeed2",
    "statement": "Theorem lia_succeed2 : forall (n m : nat),\n    n * m = m * n.",
    "proof": "Proof.lia.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "lia_fail1",
    "statement": "Theorem lia_fail1 : 0 = 1.",
    "proof": "Proof.Fail lia.\nAbort.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "lia_fail2",
    "statement": "Theorem lia_fail2 : forall (n : nat),\n    n >= 1 -> 2 ^ n = 2 * 2 ^ (n - 1).",
    "proof": "Proof.Fail lia.\nAbort.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "mult_comm",
    "statement": "Theorem mult_comm : forall (n m : nat),\n    n * m = m * n.",
    "proof": "Proof.intros n m. ring.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "eq_example1",
    "statement": "Theorem eq_example1 :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x).",
    "proof": "Proof.intros. rewrite H. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "eq_example1'",
    "statement": "Theorem eq_example1' :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x).",
    "proof": "Proof.congruence.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "eq_example2",
    "statement": "Theorem eq_example2 : forall (n m o p : nat),\n    n = m ->\n    o = p ->\n    (n, o) = (m, p).",
    "proof": "Proof.congruence.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "eq_example3",
    "statement": "Theorem eq_example3 : forall (X : Type) (h : X) (t : list X),\n    [] <> h :: t.",
    "proof": "Proof.congruence.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "intuition_succeed1",
    "statement": "Theorem intuition_succeed1 : forall (P : Prop),\n    P -> P.",
    "proof": "Proof.intuition. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "intuition_succeed2",
    "statement": "Theorem intuition_succeed2 : forall (P Q : Prop),\n    ~ (P \\/ Q) -> ~P /\\ ~Q.",
    "proof": "Proof.intuition. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "intuition_simplify1",
    "statement": "Theorem intuition_simplify1 : forall (P : Prop),\n    ~~P -> P.",
    "proof": "Proof.intuition.\nAbort.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "intuition_simplify2",
    "statement": "Theorem intuition_simplify2 : forall (x y : nat) (P Q : nat -> Prop),\n  x = y /\\ (P x -> Q x) /\\ P x -> Q y.",
    "proof": "Proof.Fail congruence.\n  intuition.\n  congruence.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "intuition_simplify2'",
    "statement": "Theorem intuition_simplify2' : forall (x y : nat) (P Q : nat -> Prop),\n  x = y /\\ (P x -> Q x) /\\ P x -> Q y.",
    "proof": "Proof.intuition congruence.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "plus_id_exercise_from_basics",
    "statement": "Theorem plus_id_exercise_from_basics : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "add_assoc_from_induction",
    "statement": "Theorem add_assoc_from_induction : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "S_injective_from_tactics",
    "statement": "Theorem S_injective_from_tactics : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "or_distributes_over_and_from_logic",
    "statement": "Theorem or_distributes_over_and_from_logic : forall P Q R : Prop,\n    P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "plus_1_neq_0",
    "statement": "Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "proof": "Proof.intros n. destruct n.\n  - reflexivity.\n  - reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "negb_involutive",
    "statement": "Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "proof": "Proof.intros b. destruct b.\n  - reflexivity.\n  - reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "andb_commutative",
    "statement": "Theorem andb_commutative : forall b c, andb b c = andb c b.",
    "proof": "Proof.intros b c. destruct b.\n  - destruct c.\n    + reflexivity.\n    + reflexivity.\n  - destruct c.\n    + reflexivity.\n    + reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "plus_1_neq_0'",
    "statement": "Theorem plus_1_neq_0' : forall n : nat,\n    (n + 1) =? 0 = false.",
    "proof": "Proof.intros n; destructpf n. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "negb_involutive'",
    "statement": "Theorem negb_involutive' : forall b : bool,\n  negb (negb b) = b.",
    "proof": "Proof.intros b; destructpf b. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "andb_commutative'",
    "statement": "Theorem andb_commutative' : forall b c, andb b c = andb c b.",
    "proof": "Proof.intros b c; destructpf b; destructpf c.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "andb3_exchange",
    "statement": "Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "andb_true_elim2",
    "statement": "Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "proof": "Proof.intros b c. destruct b eqn:Eb.\n  - simpl. intros H. rewrite H. reflexivity.\n  - simpl. intros H. destruct c eqn:Ec.\n    + reflexivity.\n    + rewrite H. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "andb_true_elim2'",
    "statement": "Theorem andb_true_elim2' : forall b c : bool,\n    andb b c = true -> c = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "andb3_exchange'",
    "statement": "Theorem andb3_exchange' :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "app_nil_r",
    "statement": "Theorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "proof": "Proof.intros X lst. induction lst as [ | h t IHt].\n  - reflexivity.\n  - simpl. rewrite IHt. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex1",
    "statement": "Theorem match_ex1 : True.",
    "proof": "Proof.match goal with\n  | [ |- True ] => apply I\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex2",
    "statement": "Theorem match_ex2 : True /\\ True.",
    "proof": "Proof.match goal with\n  | [ |- True ] => apply I\n  | [ |- True /\\ True ] => split; apply I\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex2'",
    "statement": "Theorem match_ex2' : True /\\ True.",
    "proof": "Proof.match goal with\n  | [ |- True ] => idtac \"branch 1\"; apply I\n  | [ |- True /\\ True ] => idtac \"branch 2\"; split; apply I\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex2''",
    "statement": "Theorem match_ex2'' : True /\\ True.",
    "proof": "Proof.match goal with\n  | [ |- _ ] => idtac \"branch 1\"; apply I\n  | [ |- True /\\ True ] => idtac \"branch 2\"; split; apply I\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex2'''",
    "statement": "Theorem match_ex2''' : True /\\ True.",
    "proof": "Proof.Fail match goal with\n  | [ |- _ ] => idtac \"branch 1\"; apply I\n  | [ |- _ ] => idtac \"branch 2\"; apply I\n  end.\nAbort.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex3",
    "statement": "Theorem match_ex3 : forall (P : Prop), P -> P.",
    "proof": "Proof.intros P HP.\n  match goal with\n  | [ H : _ |- _ ] => apply H\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex3'",
    "statement": "Theorem match_ex3' : forall (P : Prop), P -> P.",
    "proof": "Proof.intros P HP.\n  match goal with\n  | [ H : _ |- _ ] => idtac H; apply H\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex4",
    "statement": "Theorem match_ex4 : forall (P Q : Prop), P -> Q -> P.",
    "proof": "Proof.intros P Q HP HQ.\n  match goal with\n  | [ H : _ |- _ ] => idtac H; apply H\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex5",
    "statement": "Theorem match_ex5 : forall (P Q R : Prop), P -> Q -> R.",
    "proof": "Proof.intros P Q R HP HQ.\n  Fail match goal with\n  | [ H : _ |- _ ] => idtac H; apply H\n  end.\nAbort.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "match_ex5",
    "statement": "Theorem match_ex5 : forall (P Q : Prop), P -> Q -> P.",
    "proof": "Proof.intros P Q HP HQ.\n  match goal with\n  | [ H : ?X |- ?X ] => idtac H; apply H\n  end.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "app_nil_r'",
    "statement": "Theorem app_nil_r' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "proof": "Proof.intros X lst. induction lst as [ | h t IHt].\n  - reflexivity.\n  - simpl. rewrite IHt. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "app_nil_r''",
    "statement": "Theorem app_nil_r'' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "proof": "Proof.intros X lst. simple_induction lst.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "add_assoc''",
    "statement": "Theorem add_assoc'' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "proof": "Proof.intros n m p. induction n.\n  - reflexivity.\n  - simpl. rewrite IHn. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "add_assoc'''",
    "statement": "Theorem add_assoc''' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "proof": "Proof.intros n m p. simple_induction n.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "plus_n_Sm",
    "statement": "Theorem plus_n_Sm : forall n m : nat,\n    S (n + m) = n + (S m).",
    "proof": "Proof.intros n m. induction n.\n  - reflexivity.\n  - simpl. rewrite IHn. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "plus_n_Sm'",
    "statement": "Theorem plus_n_Sm' : forall n m : nat,\n    S (n + m) = n + (S m).",
    "proof": "Proof.intros n m. simple_induction n.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "nor_not_or",
    "statement": "Theorem nor_not_or : forall (P Q : Prop),\n    nor P Q -> ~ (P \\/ Q).",
    "proof": "Proof.intros. destruct H. unfold not. intros. destruct H. auto. auto.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      },
      {
        "type": "ltac",
        "content": "Ltac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end."
      },
      {
        "type": "example",
        "content": "Example imp1 : forall (P : Prop), P -> P.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).\nProof. imp_intuition. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "nor_comm",
    "statement": "Theorem nor_comm : forall (P Q : Prop),\n    nor P Q <-> nor Q P.",
    "proof": "Proof.intros P Q. split.\n  - intros H. destruct H. apply stroke; assumption.\n  - intros H. destruct H. apply stroke; assumption.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      },
      {
        "type": "ltac",
        "content": "Ltac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end."
      },
      {
        "type": "example",
        "content": "Example imp1 : forall (P : Prop), P -> P.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).\nProof. imp_intuition. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "nor_not",
    "statement": "Theorem nor_not : forall (P : Prop),\n    nor P P <-> ~P.",
    "proof": "Proof.intros P. split.\n  - intros H. destruct H. assumption.\n  - intros H. apply stroke; assumption.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      },
      {
        "type": "ltac",
        "content": "Ltac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end."
      },
      {
        "type": "example",
        "content": "Example imp1 : forall (P : Prop), P -> P.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).\nProof. imp_intuition. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "nor_comm'",
    "statement": "Theorem nor_comm' : forall (P Q : Prop),\n    nor P Q <-> nor Q P.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      },
      {
        "type": "ltac",
        "content": "Ltac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end."
      },
      {
        "type": "example",
        "content": "Example imp1 : forall (P : Prop), P -> P.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).\nProof. imp_intuition. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "nor_not'",
    "statement": "Theorem nor_not' : forall (P : Prop),\n    nor P P <-> ~P.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      },
      {
        "type": "ltac",
        "content": "Ltac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end."
      },
      {
        "type": "example",
        "content": "Example imp1 : forall (P : Prop), P -> P.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).\nProof. imp_intuition. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "nor_not_and'",
    "statement": "Theorem nor_not_and' : forall (P Q : Prop),\n    nor P Q -> ~ (P /\\ Q).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith List."
      },
      {
        "type": "import",
        "content": "From LF Require Import IndProp."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + inversion Hmatch1. simpl. apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n    + apply MApp.\n      * apply IH1.\n      * apply IH2.\n  -  simpl. apply MUnionL. apply IH.\n  -  simpl. apply MUnionR. apply IH.\n  -  simpl. apply MStar0.\n  -  simpl. apply MStarApp.\n    * apply IH1.\n    * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n.\n  destruct n eqn:E."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi' : forall n, (n + 1 =? 0) = false.\nProof.\n  intros n."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.\nProof.\n  destruct n; reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).\nProof.  Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;"
      },
      {
        "type": "misc",
        "content": "try (apply MApp; try apply IH1; apply IH2)."
      },
      {
        "type": "misc",
        "content": "inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp. apply IH1.  apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];"
      },
      {
        "type": "misc",
        "content": "simpl.\n  -  apply MEmpty.\n  -  apply MChar.\n  -\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).\n    inversion Hmatch1. simpl. apply IH2.\n  -  apply MUnionL. apply IH.\n  -  apply MUnionR. apply IH.\n  -  apply MStar0.\n  -   apply MStarApp; [apply IH1 | apply IH2].\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n  intros T re s M.\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].\n  -  simpl. apply MEmpty.\n  -  simpl. apply MChar.\n  -  simpl.\n    destruct re1.\n    + inversion IH1.\n    + inversion IH1. simpl. destruct re2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n      * apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r.  apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n    + destruct re2.\n      * inversion IH2.\n      * inversion IH2. rewrite app_nil_r. apply IH1.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n      * apply MApp.\n        -- apply IH1.\n        -- apply IH2.\n  -  simpl.\n    destruct re1.\n    + inversion IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n    + destruct re2.\n      * apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n      * apply MUnionL. apply IH.\n  -  simpl.\n    destruct re1.\n    + apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n    + destruct re2.\n      * inversion IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n      * apply MUnionR. apply IH.\n -  simpl.\n    destruct re.\n    + apply MEmpty.\n    + apply MEmpty.\n    + apply MStar0.\n    + apply MStar0.\n    + apply MStar0.\n    + simpl.\n      destruct re.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n      * apply MStar0.\n -  simpl.\n   destruct re.\n   + inversion IH1.\n   + inversion IH1. inversion IH2. apply MEmpty.\n   + apply star_app.\n     * apply MStar1. apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\n   + apply star_app.\n     * apply MStar1.  apply IH1.\n     * apply IH2.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0."
      },
      {
        "type": "check",
        "content": "Check ev_SS : forall n : nat, ev n -> ev (S (S n))."
      },
      {
        "type": "example",
        "content": "Example constructor_example: forall (n:nat),\n    ev (n + n).\nProof.\n  induction n; simpl.\n  - constructor.\n  - rewrite add_comm. simpl. constructor.\n    assumption.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "require",
        "content": "Require Import Ring."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. apply H3.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5 : 2 = 2.\nProof."
      },
      {
        "type": "misc",
        "content": "info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. intros. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "create_hint_db",
        "content": "Create HintDb le_db."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto with le_db.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : le_db."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof. info_auto with le_db. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.\nProof.\n  auto.\n  info_auto with arith.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_re_opt_match'' : option (nat*string) := None."
      },
      {
        "type": "import",
        "content": "Import Pumping."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 /\\\n        s2 <> [] /\\\n        length s1 + length s2 <= pumping_constant re /\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None."
      },
      {
        "type": "example",
        "content": "Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  apply Nat.le_trans with (b + b * c)."
      },
      {
        "type": "misc",
        "content": "- apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  eapply Nat.le_trans.\n  - apply H1.\n  - simpl in H2. rewrite mul_comm. apply H2.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.\nProof.\n  intros a b c d H1 H2.\n  info_eauto using Nat.le_trans.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac simpl_and_try tac := simpl; try tac."
      },
      {
        "type": "example",
        "content": "Example sat_ex1 : 1 + 1 = 2.\nProof. simpl_and_try reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.\nProof. simpl_and_try reflexivity. lia. Qed."
      },
      {
        "type": "ltac",
        "content": "Ltac destructpf x :=\n  destruct x; try reflexivity."
      },
      {
        "type": "misc",
        "content": "Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end."
      },
      {
        "type": "misc",
        "content": "Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity."
      },
      {
        "type": "ltac",
        "content": "Ltac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end."
      },
      {
        "type": "example",
        "content": "Example imp1 : forall (P : Prop), P -> P.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.\nProof. imp_intuition. Qed."
      },
      {
        "type": "example",
        "content": "Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).\nProof. imp_intuition. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q."
      }
    ],
    "source_file": "AltAuto.v"
  },
  {
    "name": "ceval_deterministic",
    "statement": "Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst.\n  -  reflexivity.\n  -  reflexivity.\n  -\n    rewrite (IHE1_1 st'0 H1) in *.\n    apply IHE1_2. assumption.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "ceval_deterministic'",
    "statement": "Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2.\n  generalize dependent st2;\n    induction E1; intros st2 E2; inversion E2; subst;\n    auto.\n  -\n    rewrite (IHE1_1 st'0 H1) in *.\n    auto.\n  -\n    rewrite H in H5. discriminate.\n  -\n    rewrite H in H5. discriminate.\n  -\n    rewrite H in H2. discriminate.\n  -\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    auto.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      },
      {
        "type": "misc",
        "content": "-\n    apply IHE1. assumption.\n  -\n    rewrite H in H5. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H5. discriminate.\n  -\n    apply IHE1. assumption."
      },
      {
        "type": "misc",
        "content": "-\n    reflexivity.\n  -\n    rewrite H in H2. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. assumption.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "debug auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5: 2 = 2.\nProof.\n  info_auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.\nProof.\n  intros.\n  info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nQed."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "ceval_deterministic'_alt",
    "statement": "Theorem ceval_deterministic'_alt: forall c st st1 st2,\n  st =[ c ]=> st1 ->\n  st =[ c ]=> st2 ->\n  st1 = st2.\nProof with auto.\n  intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1;\n           intros st2 E2; inversion E2; subst...\n  -\n    rewrite (IHE1_1 st'0 H1) in *...\n  -\n    rewrite H in H5. discriminate.\n  -\n    rewrite H in H5. discriminate.\n  -\n    rewrite H in H2. discriminate.\n  -\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *...\nQed.",
    "proof": "",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      },
      {
        "type": "misc",
        "content": "-\n    apply IHE1. assumption.\n  -\n    rewrite H in H5. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H5. discriminate.\n  -\n    apply IHE1. assumption."
      },
      {
        "type": "misc",
        "content": "-\n    reflexivity.\n  -\n    rewrite H in H2. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. assumption.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "debug auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5: 2 = 2.\nProof.\n  info_auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.\nProof.\n  intros.\n  info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nQed."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "ceval_deterministic''",
    "statement": "Theorem ceval_deterministic'': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2.\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; auto.\n  -\n    rewrite (IHE1_1 st'0 H1) in *.\n    auto.\n  -\n      rwd H H5.\n  -\n      rwd H H5.\n  -\n      rwd H H2.\n  -\n    rwd H H4.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    auto. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      },
      {
        "type": "misc",
        "content": "-\n    apply IHE1. assumption.\n  -\n    rewrite H in H5. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H5. discriminate.\n  -\n    apply IHE1. assumption."
      },
      {
        "type": "misc",
        "content": "-\n    reflexivity.\n  -\n    rewrite H in H2. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. assumption.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "debug auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5: 2 = 2.\nProof.\n  info_auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.\nProof.\n  intros.\n  info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac rwd H1 H2 := rewrite H1 in H2; discriminate."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "ceval_deterministic'''",
    "statement": "Theorem ceval_deterministic''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2.\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; try find_rwd; auto.\n  -\n    rewrite (IHE1_1 st'0 H1) in *.\n    auto.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    auto. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      },
      {
        "type": "misc",
        "content": "-\n    apply IHE1. assumption.\n  -\n    rewrite H in H5. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H5. discriminate.\n  -\n    apply IHE1. assumption."
      },
      {
        "type": "misc",
        "content": "-\n    reflexivity.\n  -\n    rewrite H in H2. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. assumption.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "debug auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5: 2 = 2.\nProof.\n  info_auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.\nProof.\n  intros.\n  info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac rwd H1 H2 := rewrite H1 in H2; discriminate."
      },
      {
        "type": "ltac",
        "content": "Ltac find_rwd :=\n  match goal with\n    H1: ?E = true,\n    H2: ?E = false\n    |- _ => rwd H1 H2\n  end."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "ceval_deterministic''''",
    "statement": "Theorem ceval_deterministic'''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2.\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; try find_rwd;\n    try find_eqn; auto.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      },
      {
        "type": "misc",
        "content": "-\n    apply IHE1. assumption.\n  -\n    rewrite H in H5. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H5. discriminate.\n  -\n    apply IHE1. assumption."
      },
      {
        "type": "misc",
        "content": "-\n    reflexivity.\n  -\n    rewrite H in H2. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. assumption.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "debug auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5: 2 = 2.\nProof.\n  info_auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.\nProof.\n  intros.\n  info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac rwd H1 H2 := rewrite H1 in H2; discriminate."
      },
      {
        "type": "ltac",
        "content": "Ltac find_rwd :=\n  match goal with\n    H1: ?E = true,\n    H2: ?E = false\n    |- _ => rwd H1 H2\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac find_eqn :=\n  match goal with\n    H1: forall x, ?P x -> ?L = ?R,\n    H2: ?P ?X\n    |- _ => rewrite (H1 X H2) in *\n  end."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "ceval_deterministic",
    "statement": "Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2.\n  generalize dependent st2;\n  induction E1;\n    intros st2 E2; inversion E2; subst; try find_rwd; try find_eqn; auto.\n  -\n    +\n       find_rwd.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      },
      {
        "type": "misc",
        "content": "-\n    apply IHE1. assumption.\n  -\n    rewrite H in H5. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H5. discriminate.\n  -\n    apply IHE1. assumption."
      },
      {
        "type": "misc",
        "content": "-\n    reflexivity.\n  -\n    rewrite H in H2. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. assumption.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "debug auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5: 2 = 2.\nProof.\n  info_auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.\nProof.\n  intros.\n  info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac rwd H1 H2 := rewrite H1 in H2; discriminate."
      },
      {
        "type": "ltac",
        "content": "Ltac find_rwd :=\n  match goal with\n    H1: ?E = true,\n    H2: ?E = false\n    |- _ => rwd H1 H2\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac find_eqn :=\n  match goal with\n    H1: forall x, ?P x -> ?L = ?R,\n    H2: ?P ?X\n    |- _ => rewrite (H1 X H2) in *\n  end."
      },
      {
        "type": "module",
        "content": "Module Repeat."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp)."
      },
      {
        "type": "misc",
        "content": "Notation \"'repeat' x 'until' y 'end'\" :=\n         (CRepeat x y)\n            (in custom com at level 0,\n             x at level 99, y at level 99)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99)."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "ceval_deterministic'",
    "statement": "Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2.\n  generalize dependent st2;\n  induction E1;\n    intros st2 E2; inversion E2; subst; try find_eqn; try find_rwd; auto.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp."
      },
      {
        "type": "misc",
        "content": "-\n    apply IHE1. assumption.\n  -\n    rewrite H in H5. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H5. discriminate.\n  -\n    apply IHE1. assumption."
      },
      {
        "type": "misc",
        "content": "-\n    reflexivity.\n  -\n    rewrite H in H2. discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  intros P Q R H1 H2 H3.\n  apply H2. apply H1. assumption.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.\nProof.\n  auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.\nProof."
      },
      {
        "type": "misc",
        "content": "auto."
      },
      {
        "type": "misc",
        "content": "debug auto."
      },
      {
        "type": "misc",
        "content": "auto 6.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\/ (Q /\\ R).\nProof. auto. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5: 2 = 2.\nProof.\n  info_auto.\nQed."
      },
      {
        "type": "example",
        "content": "Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.\nProof.\n  intros.\n  info_auto.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma le_antisym : forall n m: nat, (n <= m /\\ m <= n) -> n = m.\nProof. lia. Qed."
      },
      {
        "type": "example",
        "content": "Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto using le_antisym.\nQed."
      },
      {
        "type": "hint",
        "content": "Hint Resolve le_antisym : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m /\\ m <= n)) ->\n  n <= p ->\n  n = m.\nProof.\n  auto.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition is_fortytwo x := (x = 42)."
      },
      {
        "type": "example",
        "content": "Example auto_example_7: forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nAbort."
      },
      {
        "type": "hint",
        "content": "Hint Unfold is_fortytwo : core."
      },
      {
        "type": "example",
        "content": "Example auto_example_7' : forall x,\n  (x <= 42 /\\ 42 <= x) -> is_fortytwo x.\nProof.\n  auto.\nQed."
      },
      {
        "type": "ltac",
        "content": "Ltac rwd H1 H2 := rewrite H1 in H2; discriminate."
      },
      {
        "type": "ltac",
        "content": "Ltac find_rwd :=\n  match goal with\n    H1: ?E = true,\n    H2: ?E = false\n    |- _ => rwd H1 H2\n  end."
      },
      {
        "type": "ltac",
        "content": "Ltac find_eqn :=\n  match goal with\n    H1: forall x, ?P x -> ?L = ?R,\n    H2: ?P ?X\n    |- _ => rewrite (H1 X H2) in *\n  end."
      },
      {
        "type": "module",
        "content": "Module Repeat."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp)."
      },
      {
        "type": "misc",
        "content": "Notation \"'repeat' x 'until' y 'end'\" :=\n         (CRepeat x y)\n            (in custom com at level 0,\n             x at level 99, y at level 99)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99)."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "misc",
        "content": "-\n     +\n        find_rwd.\nQed."
      }
    ],
    "source_file": "Auto.v"
  },
  {
    "name": "plus_O_n",
    "statement": "Theorem plus_O_n : forall n : nat, 0 + n = n.",
    "proof": "Proof.intros n. simpl. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_O_n'",
    "statement": "Theorem plus_O_n' : forall n : nat, 0 + n = n.",
    "proof": "Proof.intros n. reflexivity. Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_O_n''",
    "statement": "Theorem plus_O_n'' : forall n : nat, 0 + n = n.",
    "proof": "Proof.intros m. reflexivity. Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_1_l",
    "statement": "Theorem plus_1_l : forall n:nat, 1 + n = S n.",
    "proof": "Proof.intros n. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "mult_0_l",
    "statement": "Theorem mult_0_l : forall n:nat, 0 * n = 0.",
    "proof": "Proof.intros n. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_id_example",
    "statement": "Theorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m.",
    "proof": "",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_id_exercise",
    "statement": "Theorem plus_id_exercise : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "mult_n_0_m_0",
    "statement": "Theorem mult_n_0_m_0 : forall p q : nat,\n  (p * 0) + (q * 0) = 0.",
    "proof": "Proof.intros p q.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  reflexivity. Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "mult_n_1",
    "statement": "Theorem mult_n_1 : forall p : nat,\n  p * 1 = p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_1_neq_0_firsttry",
    "statement": "Theorem plus_1_neq_0_firsttry : forall n : nat,\n  (n + 1) =? 0 = false.",
    "proof": "Proof.intros n.\n  simpl.\nAbort.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_1_neq_0",
    "statement": "Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "proof": "Proof.intros n. destruct n as [| n'] eqn:E.\n  - reflexivity.\n  - reflexivity.   Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "negb_involutive",
    "statement": "Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "proof": "Proof.intros b. destruct b eqn:E.\n  - reflexivity.\n  - reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "andb_commutative",
    "statement": "Theorem andb_commutative : forall b c, andb b c = andb c b.",
    "proof": "Proof.intros b c. destruct b eqn:Eb.\n  - destruct c eqn:Ec.\n    + reflexivity.\n    + reflexivity.\n  - destruct c eqn:Ec.\n    + reflexivity.\n    + reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "andb_commutative'",
    "statement": "Theorem andb_commutative' : forall b c, andb b c = andb c b.",
    "proof": "Proof.intros b c. destruct b eqn:Eb.\n  { destruct c eqn:Ec.\n    { reflexivity. }\n    { reflexivity. } }\n  { destruct c eqn:Ec.\n    { reflexivity. }\n    { reflexivity. } }\nQed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "andb3_exchange",
    "statement": "Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "proof": "Proof.intros b c d. destruct b eqn:Eb.\n  - destruct c eqn:Ec.\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity. }\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity. }\n  - destruct c eqn:Ec.\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity. }\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity. }\nQed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "andb_true_elim2",
    "statement": "Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "plus_1_neq_0'",
    "statement": "Theorem plus_1_neq_0' : forall n : nat,\n  (n + 1) =? 0 = false.",
    "proof": "Proof.intros [|n].\n  - reflexivity.\n  - reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "andb_commutative''",
    "statement": "Theorem andb_commutative'' :\n  forall b c, andb b c = andb c b.",
    "proof": "Proof.intros [] [].\n  - reflexivity.\n  - reflexivity.\n  - reflexivity.\n  - reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "zero_nbeq_plus_1",
    "statement": "Theorem zero_nbeq_plus_1 : forall n : nat,\n  0 =? (n + 1) = false.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "identity_fn_applied_twice",
    "statement": "Theorem identity_fn_applied_twice :\n  forall (f : bool -> bool),\n  (forall (x : bool), f x = x) ->\n  forall (b : bool), f (f b) = b.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "andb_eq_orb",
    "statement": "Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "letter_comparison_Eq",
    "statement": "Theorem letter_comparison_Eq :\n  forall l, letter_comparison l l = Eq.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "lower_letter_lowers",
    "statement": "Theorem lower_letter_lowers: forall (l : letter),\n  letter_comparison (lower_letter l) l = Lt.",
    "proof": "Proof.intros l.\n  destruct l.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\n  - simpl.\nAbort.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "lower_letter_F_is_F",
    "statement": "Theorem lower_letter_F_is_F:\n  lower_letter F = F.",
    "proof": "Proof.simpl. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "lower_letter_lowers",
    "statement": "Theorem lower_letter_lowers:\n  forall (l : letter),\n    letter_comparison F l = Lt ->\n    letter_comparison (lower_letter l) l = Lt.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "lower_grade_F_Minus",
    "statement": "Theorem lower_grade_F_Minus : lower_grade (Grade F Minus) = (Grade F Minus).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      },
      {
        "type": "definition",
        "content": "Definition lower_grade (g : grade) : grade\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).\nProof.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "lower_grade_lowers",
    "statement": "Theorem lower_grade_lowers :\n  forall (g : grade),\n    grade_comparison (Grade F Minus) g = Lt ->\n    grade_comparison (lower_grade g) g = Lt.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      },
      {
        "type": "definition",
        "content": "Definition lower_grade (g : grade) : grade\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).\nProof.\n Admitted."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "apply_late_policy_unfold",
    "statement": "Theorem apply_late_policy_unfold :\n  forall (late_days : nat) (g : grade),\n    (apply_late_policy late_days g)\n    =\n    (if late_days <? 9 then g  else\n       if late_days <? 17 then lower_grade g\n       else if late_days <? 21 then lower_grade (lower_grade g)\n            else lower_grade (lower_grade (lower_grade g))).",
    "proof": "Proof.intros. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      },
      {
        "type": "definition",
        "content": "Definition lower_grade (g : grade) : grade\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition apply_late_policy (late_days : nat) (g : grade) : grade :=\n  if late_days <? 9 then g\n  else if late_days <? 17 then lower_grade g\n  else if late_days <? 21 then lower_grade (lower_grade g)\n  else lower_grade (lower_grade (lower_grade g))."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "no_penalty_for_mostly_on_time",
    "statement": "Theorem no_penalty_for_mostly_on_time :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = true) ->\n    apply_late_policy late_days g = g.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      },
      {
        "type": "definition",
        "content": "Definition lower_grade (g : grade) : grade\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition apply_late_policy (late_days : nat) (g : grade) : grade :=\n  if late_days <? 9 then g\n  else if late_days <? 17 then lower_grade g\n  else if late_days <? 21 then lower_grade (lower_grade g)\n  else lower_grade (lower_grade (lower_grade g))."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "grade_lowered_once",
    "statement": "Theorem grade_lowered_once :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = false) ->\n    (late_days <? 17 = true) ->\n    (apply_late_policy late_days g) = (lower_grade g).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "inductive",
        "content": "Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday."
      },
      {
        "type": "definition",
        "content": "Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day friday)."
      },
      {
        "type": "misc",
        "content": "Compute (next_working_day (next_working_day saturday))."
      },
      {
        "type": "example",
        "content": "Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday."
      },
      {
        "type": "misc",
        "content": "Proof. simpl. reflexivity.  Qed."
      },
      {
        "type": "import",
        "content": "From Coq Require Export String."
      },
      {
        "type": "inductive",
        "content": "Inductive bool : Type :=\n  | true\n  | false."
      },
      {
        "type": "definition",
        "content": "Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end."
      },
      {
        "type": "definition",
        "content": "Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end."
      },
      {
        "type": "example",
        "content": "Example test_orb1:  (orb true  false) = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb2:  (orb false false) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb3:  (orb false true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_orb4:  (orb true  true)  = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\" := (andb x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"x || y\" := (orb x y)."
      },
      {
        "type": "example",
        "content": "Example test_orb5:  false || false || true = true.\nProof. simpl. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition negb' (b:bool) : bool :=\n  if b then false\n  else true."
      },
      {
        "type": "definition",
        "content": "Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2."
      },
      {
        "type": "inductive",
        "content": "Inductive bw : Type :=\n  | bw_black\n  | bw_white."
      },
      {
        "type": "definition",
        "content": "Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_black)."
      },
      {
        "type": "misc",
        "content": "Compute (invert bw_white)."
      },
      {
        "type": "definition",
        "content": "Definition nandb (b1:bool) (b2:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb1:               (nandb true false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb2:               (nandb false false) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb3:               (nandb false true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nandb4:               (nandb true true) = false.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb31:                 (andb3 true true true) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb32:                 (andb3 false true true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb33:                 (andb3 true false true) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_andb34:                 (andb3 true true false) = false.\n Admitted."
      },
      {
        "type": "check",
        "content": "Check true."
      },
      {
        "type": "check",
        "content": "Check true\n  : bool."
      },
      {
        "type": "check",
        "content": "Check (negb true)\n  : bool."
      },
      {
        "type": "check",
        "content": "Check negb\n  : bool -> bool."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "inductive",
        "content": "Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)."
      },
      {
        "type": "definition",
        "content": "Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end."
      },
      {
        "type": "definition",
        "content": "Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : rgb := blue."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "definition",
        "content": "Definition foo : bool := true."
      },
      {
        "type": "check",
        "content": "Check Playground.foo : rgb."
      },
      {
        "type": "check",
        "content": "Check foo : bool."
      },
      {
        "type": "module",
        "content": "Module TuplePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive bit : Type :=\n  | B1\n  | B0."
      },
      {
        "type": "inductive",
        "content": "Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)."
      },
      {
        "type": "check",
        "content": "Check (bits B1 B0 B1 B0)\n  : nybble."
      },
      {
        "type": "definition",
        "content": "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B1 B0 B1 B0))."
      },
      {
        "type": "misc",
        "content": "Compute (all_zero (bits B0 B0 B0 B0))."
      },
      {
        "type": "end",
        "content": "End TuplePlayground."
      },
      {
        "type": "module",
        "content": "Module NatPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive nat : Type :=\n  | O\n  | S (n : nat)."
      },
      {
        "type": "inductive",
        "content": "Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)."
      },
      {
        "type": "definition",
        "content": "Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground."
      },
      {
        "type": "check",
        "content": "Check (S (S (S (S O))))."
      },
      {
        "type": "definition",
        "content": "Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (minustwo 4)."
      },
      {
        "type": "check",
        "content": "Check S        : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check pred     : nat -> nat."
      },
      {
        "type": "check",
        "content": "Check minustwo : nat -> nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end."
      },
      {
        "type": "definition",
        "content": "Definition odd (n:nat) : bool :=\n  negb (even n)."
      },
      {
        "type": "example",
        "content": "Example test_odd1:    odd 1 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_odd2:    odd 4 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "module",
        "content": "Module NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (plus 3 2)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_mult1: (mult 3 3) = 9.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end."
      },
      {
        "type": "end",
        "content": "End NatPlayground2."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint factorial (n:nat) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial1:          (factorial 3) = 6.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_factorial2:          (factorial 5) = (mult 10 12).\n Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "check",
        "content": "Check ((0 + 1) + 1) : nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_leb1:                leb 2 2 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb2:                leb 2 4 = true.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_leb3:                leb 4 2 = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_leb3': (4 <=? 2) = false.\nProof. simpl. reflexivity.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition ltb (n m : nat) : bool\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope."
      },
      {
        "type": "example",
        "content": "Example test_ltb1:             (ltb 2 2) = false.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb2:             (ltb 2 4) = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_ltb3:             (ltb 4 2) = false.\n Admitted."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "intros n m."
      },
      {
        "type": "misc",
        "content": "intros H."
      },
      {
        "type": "misc",
        "content": "rewrite -> H.\n  reflexivity.  Qed."
      },
      {
        "type": "check",
        "content": "Check mult_n_O."
      },
      {
        "type": "check",
        "content": "Check mult_n_Sm."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None."
      },
      {
        "type": "module",
        "content": "Module LateDays."
      },
      {
        "type": "inductive",
        "content": "Inductive letter : Type :=\n  | A | B | C | D | F."
      },
      {
        "type": "inductive",
        "content": "Inductive modifier : Type :=\n  | Plus | Natural | Minus."
      },
      {
        "type": "inductive",
        "content": "Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)."
      },
      {
        "type": "inductive",
        "content": "Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt."
      },
      {
        "type": "definition",
        "content": "Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B A."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison D D."
      },
      {
        "type": "misc",
        "content": "Compute letter_comparison B F."
      },
      {
        "type": "definition",
        "content": "Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end."
      },
      {
        "type": "definition",
        "content": "Definition grade_comparison (g1 g2 : grade) : comparison\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end."
      },
      {
        "type": "definition",
        "content": "Definition lower_grade (g : grade) : grade\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).\nProof.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).\nProof.\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition apply_late_policy (late_days : nat) (g : grade) : grade :=\n  if late_days <? 9 then g\n  else if late_days <? 17 then lower_grade g\n  else if late_days <? 21 then lower_grade (lower_grade g)\n  else lower_grade (lower_grade (lower_grade g))."
      }
    ],
    "source_file": "Basics.v"
  },
  {
    "name": "optimize_0plus_sound",
    "statement": "Theorem optimize_0plus_sound: forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "proof": "Proof.intros a. induction a.\n  -  reflexivity.\n  -  destruct a1 eqn:Ea1.\n    +  destruct n eqn:En.\n      *   simpl. apply IHa2.\n      *  simpl. rewrite IHa2. reflexivity.\n    +\n      simpl. simpl in IHa1. rewrite IHa1.\n      rewrite IHa2. reflexivity.\n    +\n      simpl. simpl in IHa1. rewrite IHa1.\n      rewrite IHa2. reflexivity.\n    +\n      simpl. simpl in IHa1. rewrite IHa1.\n      rewrite IHa2. reflexivity.\n  -\n    simpl. rewrite IHa1. rewrite IHa2. reflexivity.\n  -\n    simpl. rewrite IHa1. rewrite IHa2. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "silly1",
    "statement": "Theorem silly1 : forall (P : Prop), P -> P.",
    "proof": "Proof.intros P HP.\n  try reflexivity.\n  apply HP.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "silly2",
    "statement": "Theorem silly2 : forall ae, aeval ae = aeval ae.",
    "proof": "Proof.try reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "optimize_0plus_sound'",
    "statement": "Theorem optimize_0plus_sound': forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "proof": "Proof.intros a.\n  induction a;",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "optimize_0plus_sound''",
    "statement": "Theorem optimize_0plus_sound'': forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "proof": "Proof.intros a.\n  induction a;",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "In10",
    "statement": "Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "proof": "Proof.repeat (try (left; reflexivity); right).\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "In10'",
    "statement": "Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "proof": "Proof.repeat simpl.\n  repeat (left; reflexivity).\n  repeat (right; try (left; reflexivity)).\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "repeat_loop",
    "statement": "Theorem repeat_loop : forall (m n : nat),\n  m + n = n + m.",
    "proof": "Proof.intros m n.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "optimize_0plus_b_sound",
    "statement": "Theorem optimize_0plus_b_sound : forall b,\n  beval (optimize_0plus_b b) = beval b.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "aevalR_iff_aeval",
    "statement": "Theorem aevalR_iff_aeval : forall a n,\n  (a ==> n) <-> aeval a = n.",
    "proof": "Proof.split.\n  -\n    intros H.\n    induction H; simpl.\n    +\n      reflexivity.\n    +\n      rewrite IHaevalR1.  rewrite IHaevalR2.  reflexivity.\n    +\n      rewrite IHaevalR1.  rewrite IHaevalR2.  reflexivity.\n    +\n      rewrite IHaevalR1.  rewrite IHaevalR2.  reflexivity.\n  -\n    generalize dependent n.\n    induction a;\n       simpl; intros; subst.\n    +\n      apply E_ANum.\n    +\n      apply E_APlus.\n      * apply IHa1. reflexivity.\n      * apply IHa2. reflexivity.\n    +\n      apply E_AMinus.\n      * apply IHa1. reflexivity.\n      * apply IHa2. reflexivity.\n    +\n      apply E_AMult.\n      * apply IHa1. reflexivity.\n      * apply IHa2. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "aevalR_iff_aeval'",
    "statement": "Theorem aevalR_iff_aeval' : forall a n,\n  (a ==> n) <-> aeval a = n.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "pup_to_2_ceval",
    "statement": "Theorem pup_to_2_ceval :\n  (X !-> 2) =[\n    pup_to_n\n  ]=> (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "ceval_deterministic",
    "statement": "Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "proof": "Proof.intros c st st1 st2 E1 E2.\n  generalize dependent st2.\n  induction E1; intros st2 E2; inversion E2; subst.\n  -  reflexivity.\n  -  reflexivity.\n  -\n    rewrite (IHE1_1 st'0 H1) in *.\n    apply IHE1_2. assumption.\n  -\n      apply IHE1. assumption.\n  -\n      rewrite H in H5. discriminate.\n  -\n      rewrite H in H5. discriminate.\n  -\n      apply IHE1. assumption.\n  -\n    reflexivity.\n  -\n    rewrite H in H2. discriminate.\n  -\n    rewrite H in H4. discriminate.\n  -\n    rewrite (IHE1_1 st'0 H3) in *.\n    apply IHE1_2. assumption.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "plus2_spec",
    "statement": "Theorem plus2_spec : forall st n st',\n  st X = n ->\n  st =[ plus2 ]=> st' ->\n  st' X = n + 2.",
    "proof": "Proof.intros st n st' HX Heval.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "loop_never_stops",
    "statement": "Theorem loop_never_stops : forall st st',\n  ~(st =[ loop ]=> st').",
    "proof": "Proof.intros st st' contra. unfold loop in contra.\n  remember <{ while true do skip end }> as loopdef\n           eqn:Heqloopdef.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "no_whiles_eqv",
    "statement": "Theorem no_whiles_eqv:\n  forall c, no_whiles c = true <-> no_whilesR c.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "execute_app",
    "statement": "Theorem execute_app : forall st p1 p2 stack,\n  s_execute st stack (p1 ++ p2) = s_execute st (s_execute st stack p1) p2.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "s_compile_correct",
    "statement": "Theorem s_compile_correct : forall (st : state) (e : aexp),\n  s_execute st [] (s_compile e) = [ aeval st e ].",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "break_ignore",
    "statement": "Theorem break_ignore : forall c st st' s,\n     st =[ break; c ]=> st' / s ->\n     st = st'.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module BreakImp."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'break'\" := CBreak (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive result : Type :=\n  | SContinue\n  | SBreak."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st' '/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st / SContinue"
      },
      {
        "type": "misc",
        "content": "where \"st '=[' c ']=>' st' '/' s\" := (ceval c st s st')."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "while_continue",
    "statement": "Theorem while_continue : forall b c st st' s,\n  st =[ while b do c end ]=> st' / s ->\n  s = SContinue.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module BreakImp."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'break'\" := CBreak (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive result : Type :=\n  | SContinue\n  | SBreak."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st' '/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st / SContinue"
      },
      {
        "type": "misc",
        "content": "where \"st '=[' c ']=>' st' '/' s\" := (ceval c st s st')."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "while_stops_on_break",
    "statement": "Theorem while_stops_on_break : forall b c st st',\n  beval st b = true ->\n  st =[ c ]=> st' / SBreak ->\n  st =[ while b do c end ]=> st' / SContinue.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module BreakImp."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'break'\" := CBreak (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive result : Type :=\n  | SContinue\n  | SBreak."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st' '/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st / SContinue"
      },
      {
        "type": "misc",
        "content": "where \"st '=[' c ']=>' st' '/' s\" := (ceval c st s st')."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "seq_continue",
    "statement": "Theorem seq_continue : forall c1 c2 st st' st'',\n  st =[ c1 ]=> st' / SContinue ->\n  st' =[ c2 ]=> st'' / SContinue ->\n  st =[ c1 ; c2 ]=> st'' / SContinue.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module BreakImp."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'break'\" := CBreak (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive result : Type :=\n  | SContinue\n  | SBreak."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st' '/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st / SContinue"
      },
      {
        "type": "misc",
        "content": "where \"st '=[' c ']=>' st' '/' s\" := (ceval c st s st')."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "seq_stops_on_break",
    "statement": "Theorem seq_stops_on_break : forall c1 c2 st st',\n  st =[ c1 ]=> st' / SBreak ->\n  st =[ c1 ; c2 ]=> st' / SBreak.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module BreakImp."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'break'\" := CBreak (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive result : Type :=\n  | SContinue\n  | SBreak."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st' '/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st / SContinue"
      },
      {
        "type": "misc",
        "content": "where \"st '=[' c ']=>' st' '/' s\" := (ceval c st s st')."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "while_break_true",
    "statement": "Theorem while_break_true : forall b c st st',\n  st =[ while b do c end ]=> st' / SContinue ->\n  beval st' b = true ->\n  exists st'', st'' =[ c ]=> st' / SBreak.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module BreakImp."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'break'\" := CBreak (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive result : Type :=\n  | SContinue\n  | SBreak."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st' '/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st / SContinue"
      },
      {
        "type": "misc",
        "content": "where \"st '=[' c ']=>' st' '/' s\" := (ceval c st s st')."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "ceval_deterministic",
    "statement": "Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 / s1 ->\n     st =[ c ]=> st2 / s2 ->\n     st1 = st2 /\\ s1 = s2.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Init.Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat. Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List. Import ListNotations."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Strings.String."
      },
      {
        "type": "import",
        "content": "From LF Require Import Maps."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "module",
        "content": "Module AExp."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo : forall n, 0 <=? n = true.\nProof.\n  intros.\n  destruct n."
      },
      {
        "type": "misc",
        "content": "-  simpl. reflexivity.\n    -  simpl. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma foo' : forall n, 0 <=? n = true.\nProof.\n  intros."
      },
      {
        "type": "misc",
        "content": "destruct n;"
      },
      {
        "type": "misc",
        "content": "simpl;"
      },
      {
        "type": "misc",
        "content": "reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "-  reflexivity.\n  -\n    destruct a1 eqn:Ea1;"
      },
      {
        "type": "misc",
        "content": "try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity)."
      },
      {
        "type": "misc",
        "content": "+  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.   Qed."
      },
      {
        "type": "misc",
        "content": "try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);"
      },
      {
        "type": "misc",
        "content": "try reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).\n    +  destruct n;\n      simpl; rewrite IHa2; reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint optimize_0plus_b (b : bexp) : bexp\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).\nProof.  Admitted."
      },
      {
        "type": "ltac",
        "content": "Ltac invert H :=\n  inversion H; subst; clear H."
      },
      {
        "type": "lemma",
        "content": "Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.\n  intros.\n  invert H.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example silly_presburger_example : forall m n o p,\n  m + n <= n + o /\\ o + 3 = p + 3 ->\n  m <= p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_comm__lia : forall m n,\n    m + n = n + m.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "example",
        "content": "Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.\nProof.\n  intros. lia.\nQed."
      },
      {
        "type": "module",
        "content": "Module aevalR_first_try."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "module",
        "content": "Module HypothesisNames."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)."
      },
      {
        "type": "end",
        "content": "End HypothesisNames."
      },
      {
        "type": "misc",
        "content": "Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_first_try."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"e '==>' n\" := (aevalR e n) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_beval_rules : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "split.\n  -\n    intros H; induction H; subst; reflexivity.\n  -\n    generalize dependent n.\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>b' b\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive bevalR: bexp -> bool -> Prop :="
      },
      {
        "type": "misc",
        "content": "where \"e '==>b' b\" := (bevalR e b) : type_scope\n."
      },
      {
        "type": "lemma",
        "content": "Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.\nProof.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End AExp."
      },
      {
        "type": "module",
        "content": "Module aevalR_division."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_division."
      },
      {
        "type": "module",
        "content": "Module aevalR_extended."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"e '==>' n\" (at level 90, left associativity)."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "inductive",
        "content": "Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)"
      },
      {
        "type": "misc",
        "content": "where \"a '==>' n\" := (aevalR a n) : type_scope."
      },
      {
        "type": "end",
        "content": "End aevalR_extended."
      },
      {
        "type": "definition",
        "content": "Definition state := total_map nat."
      },
      {
        "type": "inductive",
        "content": "Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)."
      },
      {
        "type": "definition",
        "content": "Definition W : string := \"W\"."
      },
      {
        "type": "definition",
        "content": "Definition X : string := \"X\"."
      },
      {
        "type": "definition",
        "content": "Definition Y : string := \"Y\"."
      },
      {
        "type": "definition",
        "content": "Definition Z : string := \"Z\"."
      },
      {
        "type": "inductive",
        "content": "Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)."
      },
      {
        "type": "misc",
        "content": "Coercion AId : string >-> aexp.\nCoercion ANum : nat >-> aexp."
      },
      {
        "type": "misc",
        "content": "Declare Custom Entry com.\nDeclare Scope com_scope.\nDeclare Custom Entry com_aux."
      },
      {
        "type": "misc",
        "content": "Notation \"<{ e }>\" := e (e custom com_aux) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"( x )\" := x (in custom com, x at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := true (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'true'\"  := BTrue (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := false (at level 1)."
      },
      {
        "type": "misc",
        "content": "Notation \"'false'\" := BFalse (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity)."
      },
      {
        "type": "misc",
        "content": "Open Scope com_scope."
      },
      {
        "type": "definition",
        "content": "Definition example_aexp : aexp := <{ 3 + (X * 2) }>."
      },
      {
        "type": "definition",
        "content": "Definition example_bexp : bexp := <{ true && ~(X <= 4) }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition empty_st := (_ !-> 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100)."
      },
      {
        "type": "example",
        "content": "Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope."
      },
      {
        "type": "definition",
        "content": "Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Notations.\nPrint fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Notations."
      },
      {
        "type": "misc",
        "content": "Print example_bexp."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Coercions.\nPrint example_bexp."
      },
      {
        "type": "misc",
        "content": "Print fact_in_coq."
      },
      {
        "type": "global_directive",
        "content": "Unset Printing Coercions."
      },
      {
        "type": "misc",
        "content": "Locate aexp."
      },
      {
        "type": "misc",
        "content": "Locate \"&&\"."
      },
      {
        "type": "misc",
        "content": "Locate \";\"."
      },
      {
        "type": "misc",
        "content": "Locate \"while\"."
      },
      {
        "type": "definition",
        "content": "Definition plus2 : com :=\n  <{ X := X + 2 }>."
      },
      {
        "type": "definition",
        "content": "Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>."
      },
      {
        "type": "definition",
        "content": "Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>."
      },
      {
        "type": "definition",
        "content": "Definition loop : com :=\n  <{ while true do\n       skip\n     end }>."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end."
      },
      {
        "type": "misc",
        "content": "Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''"
      },
      {
        "type": "misc",
        "content": "where \"st =[ c ]=> st'\" := (ceval c st st')."
      },
      {
        "type": "example",
        "content": "Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).\nProof."
      },
      {
        "type": "misc",
        "content": "apply E_Seq with (X !-> 2).\n  -\n    apply E_Asgn. reflexivity.\n  -\n    apply E_IfFalse.\n    + reflexivity.\n    + apply E_Asgn. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).\nProof.\n   Admitted."
      },
      {
        "type": "global_directive",
        "content": "Set Printing Implicit."
      },
      {
        "type": "check",
        "content": "Check @ceval_example2."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "misc",
        "content": "inversion Heval. subst. clear Heval. simpl.\n  apply t_update_eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive no_whilesR: com -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check s_execute."
      },
      {
        "type": "example",
        "content": "Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint s_compile (e : aexp) : list sinstr\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module BreakImp."
      },
      {
        "type": "inductive",
        "content": "Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)."
      },
      {
        "type": "misc",
        "content": "Notation \"'break'\" := CBreak (in custom com at level 0)."
      },
      {
        "type": "misc",
        "content": "Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope."
      },
      {
        "type": "misc",
        "content": "Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive result : Type :=\n  | SContinue\n  | SBreak."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"st '=[' c ']=>' st' '/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level)."
      },
      {
        "type": "inductive",
        "content": "Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st / SContinue"
      },
      {
        "type": "misc",
        "content": "where \"st '=[' c ']=>' st' '/' s\" := (ceval c st s st')."
      }
    ],
    "source_file": "Imp.v"
  },
  {
    "name": "ceval_step__ceval",
    "statement": "Theorem ceval_step__ceval: forall c st st',\n      (exists i, ceval_step st c i = Some st') ->\n      st =[ c ]=> st'.",
    "proof": "Proof.intros c st st' H.\n  inversion H as [i E].\n  clear H.\n  generalize dependent st'.\n  generalize dependent st.\n  generalize dependent c.\n  induction i as [| i' ].",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import PeanoNat."
      },
      {
        "type": "import",
        "content": "Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp Maps."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"'LETOPT' x <== e1 'IN' e2\"\n   := (match e1 with\n         | Some x => e2\n         | None => None\n       end)\n   (right associativity, at level 60)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end."
      },
      {
        "type": "example",
        "content": "Example example_test_ceval :\n     test_ceval empty_st"
      },
      {
        "type": "misc",
        "content": "<{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>"
      },
      {
        "type": "misc",
        "content": "= Some (2, 0, 4).\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0).\n Admitted."
      }
    ],
    "source_file": "ImpCEvalFun.v"
  },
  {
    "name": "ceval_step_more",
    "statement": "Theorem ceval_step_more: forall i1 i2 st st' c,\n  i1 <= i2 ->\n  ceval_step st c i1 = Some st' ->\n  ceval_step st c i2 = Some st'.",
    "proof": "Proof.induction i1 as [|i1']; intros i2 st st' c Hle Hceval.\n  -\n    simpl in Hceval. discriminate Hceval.\n  -\n    destruct i2 as [|i2']. inversion Hle.\n    assert (Hle': i1' <= i2') by lia.\n    destruct c.\n    +\n      simpl in Hceval. inversion Hceval.\n      reflexivity.\n    +\n      simpl in Hceval. inversion Hceval.\n      reflexivity.\n    +\n      simpl in Hceval. simpl.\n      destruct (ceval_step st c1 i1') eqn:Heqst1'o.\n      *\n        apply (IHi1' i2') in Heqst1'o; try assumption.\n        rewrite Heqst1'o. simpl. simpl in Hceval.\n        apply (IHi1' i2') in Hceval; try assumption.\n      *\n        discriminate Hceval.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import PeanoNat."
      },
      {
        "type": "import",
        "content": "Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp Maps."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"'LETOPT' x <== e1 'IN' e2\"\n   := (match e1 with\n         | Some x => e2\n         | None => None\n       end)\n   (right associativity, at level 60)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end."
      },
      {
        "type": "example",
        "content": "Example example_test_ceval :\n     test_ceval empty_st"
      },
      {
        "type": "misc",
        "content": "<{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>"
      },
      {
        "type": "misc",
        "content": "= Some (2, 0, 4).\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0).\n Admitted."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H. discriminate H."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H.\n    destruct c;\n           simpl in H; inversion H; subst; clear H.\n      +  apply E_Skip.\n      +  apply E_Asgn. reflexivity."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (ceval_step st c1 i') eqn:Heqr1.\n        *\n          apply E_Seq with s.\n            apply IHi'. rewrite Heqr1. reflexivity.\n            apply IHi'. assumption.\n        *\n          discriminate H1."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (beval st b) eqn:Heqr.\n        *\n          apply E_IfTrue. rewrite Heqr. reflexivity.\n          apply IHi'. assumption.\n        *\n          apply E_IfFalse. rewrite Heqr. reflexivity.\n          apply IHi'. assumption."
      },
      {
        "type": "misc",
        "content": "+  destruct (beval st b) eqn :Heqr.\n        *\n         destruct (ceval_step st c i') eqn:Heqr1.\n         {\n           apply E_WhileTrue with s. rewrite Heqr.\n           reflexivity.\n           apply IHi'. rewrite Heqr1. reflexivity.\n           apply IHi'. assumption. }\n         {  discriminate H1. }\n        *\n          injection H1 as H2. rewrite <- H2.\n          apply E_WhileFalse. apply Heqr. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None."
      }
    ],
    "source_file": "ImpCEvalFun.v"
  },
  {
    "name": "ceval__ceval_step",
    "statement": "Theorem ceval__ceval_step: forall c st st',\n      st =[ c ]=> st' ->\n      exists i, ceval_step st c i = Some st'.",
    "proof": "Proof.intros c st st' Hce.\n  induction Hce.\n   Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import PeanoNat."
      },
      {
        "type": "import",
        "content": "Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp Maps."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"'LETOPT' x <== e1 'IN' e2\"\n   := (match e1 with\n         | Some x => e2\n         | None => None\n       end)\n   (right associativity, at level 60)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end."
      },
      {
        "type": "example",
        "content": "Example example_test_ceval :\n     test_ceval empty_st"
      },
      {
        "type": "misc",
        "content": "<{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>"
      },
      {
        "type": "misc",
        "content": "= Some (2, 0, 4).\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0).\n Admitted."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H. discriminate H."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H.\n    destruct c;\n           simpl in H; inversion H; subst; clear H.\n      +  apply E_Skip.\n      +  apply E_Asgn. reflexivity."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (ceval_step st c1 i') eqn:Heqr1.\n        *\n          apply E_Seq with s.\n            apply IHi'. rewrite Heqr1. reflexivity.\n            apply IHi'. assumption.\n        *\n          discriminate H1."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (beval st b) eqn:Heqr.\n        *\n          apply E_IfTrue. rewrite Heqr. reflexivity.\n          apply IHi'. assumption.\n        *\n          apply E_IfFalse. rewrite Heqr. reflexivity.\n          apply IHi'. assumption."
      },
      {
        "type": "misc",
        "content": "+  destruct (beval st b) eqn :Heqr.\n        *\n         destruct (ceval_step st c i') eqn:Heqr1.\n         {\n           apply E_WhileTrue with s. rewrite Heqr.\n           reflexivity.\n           apply IHi'. rewrite Heqr1. reflexivity.\n           apply IHi'. assumption. }\n         {  discriminate H1. }\n        *\n          injection H1 as H2. rewrite <- H2.\n          apply E_WhileFalse. apply Heqr. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "+\n      simpl in Hceval. simpl.\n      destruct (beval st b); apply (IHi1' i2') in Hceval;\n        assumption."
      },
      {
        "type": "misc",
        "content": "+\n      simpl in Hceval. simpl.\n      destruct (beval st b); try assumption.\n      destruct (ceval_step st c i1') eqn: Heqst1'o.\n      *\n        apply (IHi1' i2') in Heqst1'o; try assumption.\n        rewrite -> Heqst1'o. simpl. simpl in Hceval.\n        apply (IHi1' i2') in Hceval; try assumption.\n      *\n        simpl in Hceval. discriminate Hceval.  Qed."
      }
    ],
    "source_file": "ImpCEvalFun.v"
  },
  {
    "name": "ceval_and_ceval_step_coincide",
    "statement": "Theorem ceval_and_ceval_step_coincide: forall c st st',\n      st =[ c ]=> st'\n  <-> exists i, ceval_step st c i = Some st'.",
    "proof": "Proof.intros c st st'.\n  split. apply ceval__ceval_step. apply ceval_step__ceval.\nQed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import PeanoNat."
      },
      {
        "type": "import",
        "content": "Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp Maps."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"'LETOPT' x <== e1 'IN' e2\"\n   := (match e1 with\n         | Some x => e2\n         | None => None\n       end)\n   (right associativity, at level 60)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end."
      },
      {
        "type": "example",
        "content": "Example example_test_ceval :\n     test_ceval empty_st"
      },
      {
        "type": "misc",
        "content": "<{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>"
      },
      {
        "type": "misc",
        "content": "= Some (2, 0, 4).\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0).\n Admitted."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H. discriminate H."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H.\n    destruct c;\n           simpl in H; inversion H; subst; clear H.\n      +  apply E_Skip.\n      +  apply E_Asgn. reflexivity."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (ceval_step st c1 i') eqn:Heqr1.\n        *\n          apply E_Seq with s.\n            apply IHi'. rewrite Heqr1. reflexivity.\n            apply IHi'. assumption.\n        *\n          discriminate H1."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (beval st b) eqn:Heqr.\n        *\n          apply E_IfTrue. rewrite Heqr. reflexivity.\n          apply IHi'. assumption.\n        *\n          apply E_IfFalse. rewrite Heqr. reflexivity.\n          apply IHi'. assumption."
      },
      {
        "type": "misc",
        "content": "+  destruct (beval st b) eqn :Heqr.\n        *\n         destruct (ceval_step st c i') eqn:Heqr1.\n         {\n           apply E_WhileTrue with s. rewrite Heqr.\n           reflexivity.\n           apply IHi'. rewrite Heqr1. reflexivity.\n           apply IHi'. assumption. }\n         {  discriminate H1. }\n        *\n          injection H1 as H2. rewrite <- H2.\n          apply E_WhileFalse. apply Heqr. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "+\n      simpl in Hceval. simpl.\n      destruct (beval st b); apply (IHi1' i2') in Hceval;\n        assumption."
      },
      {
        "type": "misc",
        "content": "+\n      simpl in Hceval. simpl.\n      destruct (beval st b); try assumption.\n      destruct (ceval_step st c i1') eqn: Heqst1'o.\n      *\n        apply (IHi1' i2') in Heqst1'o; try assumption.\n        rewrite -> Heqst1'o. simpl. simpl in Hceval.\n        apply (IHi1' i2') in Hceval; try assumption.\n      *\n        simpl in Hceval. discriminate Hceval.  Qed."
      }
    ],
    "source_file": "ImpCEvalFun.v"
  },
  {
    "name": "ceval_deterministic'",
    "statement": "Theorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "proof": "Proof.intros c st st1 st2 He1 He2.\n  apply ceval__ceval_step in He1.\n  apply ceval__ceval_step in He2.\n  inversion He1 as [i1 E1].\n  inversion He2 as [i2 E2].\n  apply ceval_step_more with (i2 := i1 + i2) in E1.\n  apply ceval_step_more with (i2 := i1 + i2) in E2.\n  rewrite E1 in E2. inversion E2. reflexivity.\n  lia. lia.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Lia."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import PeanoNat."
      },
      {
        "type": "import",
        "content": "Import Nat."
      },
      {
        "type": "import",
        "content": "From Coq Require Import EqNat."
      },
      {
        "type": "import",
        "content": "From LF Require Import Imp Maps."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"'LETOPT' x <== e1 'IN' e2\"\n   := (match e1 with\n         | Some x => e2\n         | None => None\n       end)\n   (right associativity, at level 60)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end."
      },
      {
        "type": "example",
        "content": "Example example_test_ceval :\n     test_ceval empty_st"
      },
      {
        "type": "misc",
        "content": "<{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>"
      },
      {
        "type": "misc",
        "content": "= Some (2, 0, 4).\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition pup_to_n : com\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0).\n Admitted."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H. discriminate H."
      },
      {
        "type": "misc",
        "content": "-\n    intros c st st' H.\n    destruct c;\n           simpl in H; inversion H; subst; clear H.\n      +  apply E_Skip.\n      +  apply E_Asgn. reflexivity."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (ceval_step st c1 i') eqn:Heqr1.\n        *\n          apply E_Seq with s.\n            apply IHi'. rewrite Heqr1. reflexivity.\n            apply IHi'. assumption.\n        *\n          discriminate H1."
      },
      {
        "type": "misc",
        "content": "+\n        destruct (beval st b) eqn:Heqr.\n        *\n          apply E_IfTrue. rewrite Heqr. reflexivity.\n          apply IHi'. assumption.\n        *\n          apply E_IfFalse. rewrite Heqr. reflexivity.\n          apply IHi'. assumption."
      },
      {
        "type": "misc",
        "content": "+  destruct (beval st b) eqn :Heqr.\n        *\n         destruct (ceval_step st c i') eqn:Heqr1.\n         {\n           apply E_WhileTrue with s. rewrite Heqr.\n           reflexivity.\n           apply IHi'. rewrite Heqr1. reflexivity.\n           apply IHi'. assumption. }\n         {  discriminate H1. }\n        *\n          injection H1 as H2. rewrite <- H2.\n          apply E_WhileFalse. apply Heqr. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "+\n      simpl in Hceval. simpl.\n      destruct (beval st b); apply (IHi1' i2') in Hceval;\n        assumption."
      },
      {
        "type": "misc",
        "content": "+\n      simpl in Hceval. simpl.\n      destruct (beval st b); try assumption.\n      destruct (ceval_step st c i1') eqn: Heqst1'o.\n      *\n        apply (IHi1' i2') in Heqst1'o; try assumption.\n        rewrite -> Heqst1'o. simpl. simpl in Hceval.\n        apply (IHi1' i2') in Hceval; try assumption.\n      *\n        simpl in Hceval. discriminate Hceval.  Qed."
      }
    ],
    "source_file": "ImpCEvalFun.v"
  },
  {
    "name": "mul_0_r'",
    "statement": "Theorem mul_0_r' : forall n:nat,\n  n * 0 = 0.",
    "proof": "Proof.apply nat_ind.\n  -  reflexivity.\n  -  simpl. intros n' IHn'. rewrite -> IHn'.\n    reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "plus_one_r'",
    "statement": "Theorem plus_one_r' : forall n:nat,\n  n + 1 = S n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "booltree_ind_type_correct",
    "statement": "Theorem booltree_ind_type_correct : booltree_ind_type.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "Toy_correct",
    "statement": "Theorem Toy_correct : exists f g,\n  forall P : Toy -> Prop,\n    (forall b : bool, P (f b)) ->\n    (forall (n : nat) (t : Toy), P t -> P (g n t)) ->\n    forall t : Toy, P t.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "mul_0_r''",
    "statement": "Theorem mul_0_r'' : forall n:nat,\n  P_m0r n.",
    "proof": "Proof.apply nat_ind.\n  -  reflexivity.\n  -",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)."
      },
      {
        "type": "check",
        "content": "Check tree_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "add_assoc'",
    "statement": "Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)."
      },
      {
        "type": "check",
        "content": "Check tree_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0."
      },
      {
        "type": "misc",
        "content": "intros n IHn.\n    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "add_comm'",
    "statement": "Theorem add_comm' : forall n m : nat,\n  n + m = m + n.",
    "proof": "Proof.induction n as [| n'].\n  -  intros m. rewrite -> add_0_r. reflexivity.\n  -  intros m. simpl. rewrite -> IHn'.\n    rewrite <- plus_n_Sm. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)."
      },
      {
        "type": "check",
        "content": "Check tree_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0."
      },
      {
        "type": "misc",
        "content": "intros n IHn.\n    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed."
      },
      {
        "type": "misc",
        "content": "intros n m p."
      },
      {
        "type": "misc",
        "content": "induction n as [| n'].\n  -  reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "add_comm''",
    "statement": "Theorem add_comm'' : forall n m : nat,\n  n + m = m + n.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)."
      },
      {
        "type": "check",
        "content": "Check tree_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0."
      },
      {
        "type": "misc",
        "content": "intros n IHn.\n    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed."
      },
      {
        "type": "misc",
        "content": "intros n m p."
      },
      {
        "type": "misc",
        "content": "induction n as [| n'].\n  -  reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "ev_ev'",
    "statement": "Theorem ev_ev' : forall n, ev n -> ev' n.",
    "proof": "Proof.apply ev_ind.\n  -\n    apply ev'_0.\n  -\n    intros m Hm IH.\n    apply (ev'_sum 2 m).\n    + apply ev'_2.\n    + apply IH.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)."
      },
      {
        "type": "check",
        "content": "Check tree_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0."
      },
      {
        "type": "misc",
        "content": "intros n IHn.\n    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed."
      },
      {
        "type": "misc",
        "content": "intros n m p."
      },
      {
        "type": "misc",
        "content": "induction n as [| n'].\n  -  reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "induction m as [| m'].\n  -  simpl. rewrite -> add_0_r. reflexivity.\n  -  simpl. rewrite <- IHm'.\n    rewrite <- plus_n_Sm. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Print ev."
      },
      {
        "type": "check",
        "content": "Check ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "reflect_involution",
    "statement": "Theorem reflect_involution : forall (X : Type) (t : t_tree X),\n    reflect (reflect t) = t.",
    "proof": "Proof.intros X t. induction t.\n  - reflexivity.\n  - destruct p as [[l v] r]. simpl. Abort.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)."
      },
      {
        "type": "check",
        "content": "Check tree_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0."
      },
      {
        "type": "misc",
        "content": "intros n IHn.\n    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed."
      },
      {
        "type": "misc",
        "content": "intros n m p."
      },
      {
        "type": "misc",
        "content": "induction n as [| n'].\n  -  reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "induction m as [| m'].\n  -  simpl. rewrite -> add_0_r. reflexivity.\n  -  simpl. rewrite <- IHm'.\n    rewrite <- plus_n_Sm. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Print ev."
      },
      {
        "type": "check",
        "content": "Check ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "inductive",
        "content": "Inductive le1 : nat -> nat -> Prop :=\n  | le1_n : forall n, le1 n n\n  | le1_S : forall n m, (le1 n m) -> (le1 n (S m))."
      },
      {
        "type": "misc",
        "content": "Notation \"m <=1 n\" := (le1 m n) (at level 70)."
      },
      {
        "type": "inductive",
        "content": "Inductive le2 (n:nat) : nat -> Prop :=\n  | le2_n : le2 n n\n  | le2_S m (H : le2 n m) : le2 n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"m <=2 n\" := (le2 m n) (at level 70)."
      },
      {
        "type": "check",
        "content": "Check le1_ind :\n  forall P : nat -> nat -> Prop,\n    (forall n : nat, P n n) ->\n    (forall n m : nat, n <=1 m -> P n m -> P n (S m)) ->\n    forall n n0 : nat, n <=1 n0 -> P n n0."
      },
      {
        "type": "check",
        "content": "Check le2_ind :\n  forall (n : nat) (P : nat -> Prop),\n    P n ->\n    (forall m : nat, n <=2 m -> P m -> P (S m)) ->\n    forall n0 : nat, n <=2 n0 -> P n0."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "misc",
        "content": "Print nat_ind."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint build_proof\n         (P : nat -> Prop)\n         (evPO : P 0)\n         (evPS : forall n : nat, P n -> P (S n))\n         (n : nat) : P n :=\n  match n with\n  | 0 => evPO\n  | S k => evPS k (build_proof P evPO evPS k)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition nat_ind_tidy := build_proof."
      },
      {
        "type": "lemma",
        "content": "Lemma even_ev : forall n: nat, even n = true -> ev n.\nProof.\n  induction n; intros.\n  - apply ev_0.\n  - destruct n.\n    + simpl in H. inversion H.\n    + simpl in H.\n      apply ev_SS.\nAbort."
      },
      {
        "type": "definition",
        "content": "Definition nat_ind2 :\n  forall (P : nat -> Prop),\n  P 0 ->\n  P 1 ->\n  (forall n : nat, P n -> P (S(S n))) ->\n  forall n : nat , P n :=\n    fun P => fun P0 => fun P1 => fun PSS =>\n      fix f (n:nat) := match n with\n                         0 => P0\n                       | 1 => P1\n                       | S (S n') => PSS n' (f n')\n                       end."
      },
      {
        "type": "lemma",
        "content": "Lemma even_ev : forall n, even n = true -> ev n.\nProof.\n  intros.\n  induction n as [ | |n'] using nat_ind2.\n  - apply ev_0.\n  - simpl in H.\n    inversion H.\n  - simpl in H.\n    apply ev_SS.\n    apply IHn'.\n    apply H.\nQed."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : core_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive t_tree (X : Type) : Type :=\n| t_leaf\n| t_branch : (t_tree X * X * t_tree X) -> t_tree X."
      },
      {
        "type": "misc",
        "content": "Arguments t_leaf {X}.\nArguments t_branch {X}."
      },
      {
        "type": "check",
        "content": "Check t_tree_ind."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "reflect_involution",
    "statement": "Theorem reflect_involution : forall (X : Type) (t : t_tree X),\n    reflect (reflect t) = t.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export ProofObjects."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "inductive",
        "content": "Inductive time : Type :=\n  | day\n  | night."
      },
      {
        "type": "check",
        "content": "Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t."
      },
      {
        "type": "inductive",
        "content": "Inductive rgb : Type :=\n  | red\n  | green\n  | blue."
      },
      {
        "type": "check",
        "content": "Check rgb_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)."
      },
      {
        "type": "check",
        "content": "Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l."
      },
      {
        "type": "inductive",
        "content": "Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)."
      },
      {
        "type": "check",
        "content": "Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n."
      },
      {
        "type": "inductive",
        "content": "Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)."
      },
      {
        "type": "definition",
        "content": "Definition booltree_property_type : Type := booltree -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition base_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition leaf_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition branch_case (P : booltree_property_type) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b."
      },
      {
        "type": "inductive",
        "content": "Inductive Toy : Type :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)."
      },
      {
        "type": "check",
        "content": "Check tree_ind."
      },
      {
        "type": "inductive",
        "content": "Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0."
      },
      {
        "type": "definition",
        "content": "Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0."
      },
      {
        "type": "misc",
        "content": "intros n IHn.\n    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed."
      },
      {
        "type": "misc",
        "content": "intros n m p."
      },
      {
        "type": "misc",
        "content": "induction n as [| n'].\n  -  reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "induction m as [| m'].\n  -  simpl. rewrite -> add_0_r. reflexivity.\n  -  simpl. rewrite <- IHm'.\n    rewrite <- plus_n_Sm. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Print ev."
      },
      {
        "type": "check",
        "content": "Check ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "inductive",
        "content": "Inductive le1 : nat -> nat -> Prop :=\n  | le1_n : forall n, le1 n n\n  | le1_S : forall n m, (le1 n m) -> (le1 n (S m))."
      },
      {
        "type": "misc",
        "content": "Notation \"m <=1 n\" := (le1 m n) (at level 70)."
      },
      {
        "type": "inductive",
        "content": "Inductive le2 (n:nat) : nat -> Prop :=\n  | le2_n : le2 n n\n  | le2_S m (H : le2 n m) : le2 n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"m <=2 n\" := (le2 m n) (at level 70)."
      },
      {
        "type": "check",
        "content": "Check le1_ind :\n  forall P : nat -> nat -> Prop,\n    (forall n : nat, P n n) ->\n    (forall n m : nat, n <=1 m -> P n m -> P n (S m)) ->\n    forall n n0 : nat, n <=1 n0 -> P n n0."
      },
      {
        "type": "check",
        "content": "Check le2_ind :\n  forall (n : nat) (P : nat -> Prop),\n    P n ->\n    (forall m : nat, n <=2 m -> P m -> P (S m)) ->\n    forall n0 : nat, n <=2 n0 -> P n0."
      },
      {
        "type": "check",
        "content": "Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n."
      },
      {
        "type": "misc",
        "content": "Print nat_ind."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint build_proof\n         (P : nat -> Prop)\n         (evPO : P 0)\n         (evPS : forall n : nat, P n -> P (S n))\n         (n : nat) : P n :=\n  match n with\n  | 0 => evPO\n  | S k => evPS k (build_proof P evPO evPS k)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition nat_ind_tidy := build_proof."
      },
      {
        "type": "lemma",
        "content": "Lemma even_ev : forall n: nat, even n = true -> ev n.\nProof.\n  induction n; intros.\n  - apply ev_0.\n  - destruct n.\n    + simpl in H. inversion H.\n    + simpl in H.\n      apply ev_SS.\nAbort."
      },
      {
        "type": "definition",
        "content": "Definition nat_ind2 :\n  forall (P : nat -> Prop),\n  P 0 ->\n  P 1 ->\n  (forall n : nat, P n -> P (S(S n))) ->\n  forall n : nat , P n :=\n    fun P => fun P0 => fun P1 => fun PSS =>\n      fix f (n:nat) := match n with\n                         0 => P0\n                       | 1 => P1\n                       | S (S n') => PSS n' (f n')\n                       end."
      },
      {
        "type": "lemma",
        "content": "Lemma even_ev : forall n, even n = true -> ev n.\nProof.\n  intros.\n  induction n as [ | |n'] using nat_ind2.\n  - apply ev_0.\n  - simpl in H.\n    inversion H.\n  - simpl in H.\n    apply ev_SS.\n    apply IHn'.\n    apply H.\nQed."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : core_scope."
      },
      {
        "type": "inductive",
        "content": "Inductive t_tree (X : Type) : Type :=\n| t_leaf\n| t_branch : (t_tree X * X * t_tree X) -> t_tree X."
      },
      {
        "type": "misc",
        "content": "Arguments t_leaf {X}.\nArguments t_branch {X}."
      },
      {
        "type": "check",
        "content": "Check t_tree_ind."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition better_t_tree_ind_type : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition better_t_tree_ind : better_t_tree_ind_type\n  . Admitted."
      }
    ],
    "source_file": "IndPrinciples.v"
  },
  {
    "name": "ev_4",
    "statement": "Theorem ev_4 : ev 4.",
    "proof": "Proof.apply ev_SS. apply ev_SS. apply ev_0. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_4'",
    "statement": "Theorem ev_4' : ev 4.",
    "proof": "Proof.apply (ev_SS 2 (ev_SS 0 ev_0)). Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_plus4",
    "statement": "Theorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "proof": "Proof.intros n. simpl. intros Hn.  apply ev_SS. apply ev_SS. apply Hn.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_double",
    "statement": "Theorem ev_double : forall n,\n  ev (double n).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_inversion",
    "statement": "Theorem ev_inversion : forall (n : nat),\n    ev n ->\n    (n = 0) \\/ (exists n', n = S (S n') /\\ ev n').",
    "proof": "Proof.intros n E.  destruct E as [ | n' E'] eqn:EE.\n  -\n    left. reflexivity.\n  -\n    right. exists n'. split. reflexivity. apply E'.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "le_inversion",
    "statement": "Theorem le_inversion : forall (n m : nat),\n  le n m ->\n  (n = m) \\/ (exists m', m = S m' /\\ le n m').",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "evSS_ev",
    "statement": "Theorem evSS_ev : forall n, ev (S (S n)) -> ev n.",
    "proof": "Proof.intros n E. apply ev_inversion in E. destruct E as [H0|H1].\n  - discriminate H0.\n  - destruct H1 as [n' [Hnn' E']]. injection Hnn' as Hnn'.\n    rewrite Hnn'. apply E'.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "evSS_ev'",
    "statement": "Theorem evSS_ev' : forall n,\n  ev (S (S n)) -> ev n.",
    "proof": "Proof.intros n E.  inversion E as [| n' E' Hnn'].",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "one_not_even",
    "statement": "Theorem one_not_even : ~ ev 1.",
    "proof": "Proof.intros H. apply ev_inversion in H.  destruct H as [ | [m [Hm _]]].\n  - discriminate H.\n  - discriminate Hm.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "one_not_even'",
    "statement": "Theorem one_not_even' : ~ ev 1.",
    "proof": "Proof.intros H. inversion H. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "SSSSev__even",
    "statement": "Theorem SSSSev__even : forall n,\n  ev (S (S (S (S n)))) -> ev n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev5_nonsense",
    "statement": "Theorem ev5_nonsense :\n  ev 5 -> 2 + 2 = 9.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "inversion_ex1",
    "statement": "Theorem inversion_ex1 : forall (n m o : nat),\n  [n; m] = [o; o] -> [n] = [m].",
    "proof": "Proof.intros n m o H. inversion H. reflexivity. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "inversion_ex2",
    "statement": "Theorem inversion_ex2 : forall (n : nat),\n  S n = O -> 2 + 2 = 5.",
    "proof": "Proof.intros n contra. inversion contra. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_Even_iff",
    "statement": "Theorem ev_Even_iff : forall n,\n  ev n <-> Even n.",
    "proof": "Proof.intros n. split.\n  -  apply ev_Even.\n  -  unfold Even. intros [k Hk]. rewrite Hk. apply ev_double.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_sum",
    "statement": "Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_ev__ev",
    "statement": "Theorem ev_ev__ev : forall n m,\n  ev (n+m) -> ev n -> ev m.",
    "proof": "",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev_plus_plus",
    "statement": "Theorem ev_plus_plus : forall n m p,\n  ev (n+m) -> ev (n+p) -> ev (m+p).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "ev'_ev",
    "statement": "Theorem ev'_ev : forall n, ev' n <-> ev n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "test_le1",
    "statement": "Theorem test_le1 :\n  3 <= 3.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "test_le2",
    "statement": "Theorem test_le2 :\n  3 <= 6.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "test_le3",
    "statement": "Theorem test_le3 :\n  (2 <= 1) -> 2 + 2 = 5.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "O_le_n",
    "statement": "Theorem O_le_n : forall n,\n  0 <= n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "n_le_m__Sn_le_Sm",
    "statement": "Theorem n_le_m__Sn_le_Sm : forall n m,\n  n <= m -> S n <= S m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "Sn_le_Sm__n_le_m",
    "statement": "Theorem Sn_le_Sm__n_le_m : forall n m,\n  S n <= S m -> n <= m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "le_plus_l",
    "statement": "Theorem le_plus_l : forall a b,\n  a <= a + b.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "plus_le",
    "statement": "Theorem plus_le : forall n1 n2 m,\n  n1 + n2 <= m ->\n  n1 <= m /\\ n2 <= m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "plus_le_cases",
    "statement": "Theorem plus_le_cases : forall n m p q,\n  n + m <= p + q -> n <= p \\/ m <= q.",
    "proof": "",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "plus_le_compat_l",
    "statement": "Theorem plus_le_compat_l : forall n m p,\n  n <= m ->\n  p + n <= p + m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "plus_le_compat_r",
    "statement": "Theorem plus_le_compat_r : forall n m p,\n  n <= m ->\n  n + p <= m + p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "le_plus_trans",
    "statement": "Theorem le_plus_trans : forall n m p,\n  n <= m ->\n  n <= m + p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "lt_ge_cases",
    "statement": "Theorem lt_ge_cases : forall n m,\n  n < m \\/ n >= m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "n_lt_m__n_le_m",
    "statement": "Theorem n_lt_m__n_le_m : forall n m,\n  n < m ->\n  n <= m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "plus_lt",
    "statement": "Theorem plus_lt : forall n1 n2 m,\n  n1 + n2 < m ->\n  n1 < m /\\ n2 < m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "leb_complete",
    "statement": "Theorem leb_complete : forall n m,\n  n <=? m = true -> n <= m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "leb_correct",
    "statement": "Theorem leb_correct : forall n m,\n  n <= m ->\n  n <=? m = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "leb_iff",
    "statement": "Theorem leb_iff : forall n m,\n  n <=? m = true <-> n <= m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "leb_true_trans",
    "statement": "Theorem leb_true_trans : forall n m o,\n  n <=? m = true -> m <=? o = true -> n <=? o = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "R_equiv_fR",
    "statement": "Theorem R_equiv_fR : forall m n o, R m n o <-> fR m n = o.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "subseq_refl",
    "statement": "Theorem subseq_refl : forall (l : list nat), subseq l l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "subseq_app",
    "statement": "Theorem subseq_app : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l1 (l2 ++ l3).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "subseq_trans",
    "statement": "Theorem subseq_trans : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l2 l3 ->\n  subseq l1 l3.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "in_re_match",
    "statement": "Theorem in_re_match : forall T (s : list T) (re : reg_exp T) (x : T),\n  s =~ re ->\n  In x s ->\n  In x (re_chars re).",
    "proof": "Proof.intros T s re x Hmatch Hin.\n  induction Hmatch\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "filter_not_empty_In",
    "statement": "Theorem filter_not_empty_In : forall n l,\n  filter (fun x => n =? x) l <> [] -> In n l.",
    "proof": "Proof.intros n l. induction l as [|m l' IHl'].\n  -\n    simpl. intros H. apply H. reflexivity.\n  -\n    simpl. destruct (n =? m) eqn:H.\n    +\n      intros _. rewrite eqb_eq in H. rewrite H.\n      left. reflexivity.\n    +\n      intros H'. right. apply IHl'. apply H'.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "iff_reflect",
    "statement": "Theorem iff_reflect : forall P b, (P <-> b = true) -> reflect P b.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "reflect_iff",
    "statement": "Theorem reflect_iff : forall P b, reflect P b -> (P <-> b = true).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "filter_not_empty_In'",
    "statement": "Theorem filter_not_empty_In' : forall n l,\n  filter (fun x => n =? x) l <> [] ->\n  In n l.",
    "proof": "Proof.intros n l. induction l as [|m l' IHl'].\n  -\n    simpl. intros H. apply H. reflexivity.\n  -\n    simpl. destruct (eqbP n m) as [EQnm | NEQnm].\n    +\n      intros _. rewrite EQnm. left. reflexivity.\n    +\n      intros H'. right. apply IHl'. apply H'.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "eqbP_practice",
    "statement": "Theorem eqbP_practice : forall n l,\n  count n l = 0 -> ~(In n l).",
    "proof": "Proof.intros n l Hcount. induction l as [| m l' IHl'].\n   Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "merge_filter",
    "statement": "Theorem merge_filter : forall (X : Set) (test: X->bool) (l l1 l2 : list X),\n  merge l1 l2 l ->\n  All (fun n => test n = true) l1 ->\n  All (fun n => test n = false) l2 ->\n  filter test l = l1.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive nostutter {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_1: nostutter [3;1;4;1;5;6].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_2:  nostutter (@nil nat).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_3:  nostutter [5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_4:      not (nostutter [3;1;1;4]).\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_nostutter : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive merge {X:Type} : list X -> list X -> list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "pal_app_rev",
    "statement": "Theorem pal_app_rev : forall (X:Type) (l : list X),\n  pal (l ++ (rev l)).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive nostutter {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_1: nostutter [3;1;4;1;5;6].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_2:  nostutter (@nil nat).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_3:  nostutter [5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_4:      not (nostutter [3;1;1;4]).\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_nostutter : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive merge {X:Type} : list X -> list X -> list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive pal {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "pal_rev",
    "statement": "Theorem pal_rev : forall (X:Type) (l: list X) , pal l -> l = rev l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive nostutter {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_1: nostutter [3;1;4;1;5;6].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_2:  nostutter (@nil nat).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_3:  nostutter [5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_4:      not (nostutter [3;1;1;4]).\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_nostutter : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive merge {X:Type} : list X -> list X -> list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive pal {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "palindrome_converse",
    "statement": "Theorem palindrome_converse: forall {X: Type} (l: list X),\n    l = rev l -> pal l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive nostutter {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_1: nostutter [3;1;4;1;5;6].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_2:  nostutter (@nil nat).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_3:  nostutter [5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_4:      not (nostutter [3;1;1;4]).\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_nostutter : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive merge {X:Type} : list X -> list X -> list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive pal {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "pigeonhole_principle",
    "statement": "Theorem pigeonhole_principle: excluded_middle ->\n  forall (X:Type) (l1  l2:list X),\n  (forall x, In x l1 -> In x l2) ->\n  length l2 < length l1 ->\n  repeats l1.",
    "proof": "Proof.intros EM X l1. induction l1 as [|x l1' IHl1'].\n   Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive nostutter {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_1: nostutter [3;1;4;1;5;6].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_2:  nostutter (@nil nat).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_3:  nostutter [5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_4:      not (nostutter [3;1;1;4]).\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_nostutter : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive merge {X:Type} : list X -> list X -> list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive pal {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "module",
        "content": "Module RecallIn."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\/ In A x l'\n     end."
      },
      {
        "type": "end",
        "content": "End RecallIn."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_NoDup_disjoint_etc : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma in_split : forall (X:Type) (x:X) (l:list X),\n  In x l ->\n  exists l1 l2, l = l1 ++ x :: l2.\nProof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive repeats {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_check_repeats : option (nat*string) := None."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "regex_match_correct",
    "statement": "Theorem regex_match_correct : matches_regex regex_match.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Logic."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n)."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n."
      },
      {
        "type": "example",
        "content": "Example Collatz_holds_for_12 : Collatz_holds_for 12.\nProof.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_odd. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_even. reflexivity. simpl.\n  apply Chf_one.\nQed."
      },
      {
        "type": "misc",
        "content": "Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n."
      },
      {
        "type": "module",
        "content": "Module LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m) (at level 70)."
      },
      {
        "type": "example",
        "content": "Example le_3_5 : 3 <= 5.\nProof.\n  apply le_S. apply le_S. apply le_n. Qed."
      },
      {
        "type": "end",
        "content": "End LePlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive Person : Type := Sage | Cleo | Ridley | Moss."
      },
      {
        "type": "inductive",
        "content": "Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss."
      },
      {
        "type": "definition",
        "content": "Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of."
      },
      {
        "type": "example",
        "content": "Example ancestor_of_ex : ancestor_of Sage Moss.\nProof.\n  unfold ancestor_of. apply t_trans with Cleo.\n  - apply t_step. apply po_SC.\n  - apply t_step. apply po_CM. Qed."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z."
      },
      {
        "type": "definition",
        "content": "Definition cs (n m : nat) : Prop := csf n = m."
      },
      {
        "type": "definition",
        "content": "Definition cms n m := clos_refl_trans cs n m.\nConjecture collatz' : forall n, n <> 0 -> cms n 1."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_0 : ev 0.\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "module",
        "content": "Module EvPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))."
      },
      {
        "type": "end",
        "content": "End EvPlayground."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply perm3_trans with (l2:=[2;3;1]).\n  - apply perm3_trans with (l2:=[2;1;3]).\n    + apply perm3_swap12.\n    + apply perm3_swap23.\n  - apply perm3_swap12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].\nProof.\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "apply E'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even_firsttry : forall n,\n  ev n -> Even n.\nProof.\n   unfold Even."
      },
      {
        "type": "misc",
        "content": "intros n E. inversion E as [EQ' | n' E' EQ'].\n  -  exists 0. reflexivity.\n  -\n    assert (H: (exists k', n' = double k')\n               -> (exists n0, S (S n') = double n0)).\n        { intros [k' EQ'']. exists (S k'). simpl.\n          rewrite <- EQ''. reflexivity. }\n    apply H."
      },
      {
        "type": "misc",
        "content": "generalize dependent E'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma ev_Even : forall n,\n  ev n -> Even n.\nProof.\n  unfold Even. intros n E.\n  induction E as [|n' E' IH].\n  -\n    exists 0. reflexivity.\n  -\n    destruct IH as [k Hk]. rewrite Hk.\n    exists (S k). simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Proof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)."
      },
      {
        "type": "module",
        "content": "Module Perm3Reminder."
      },
      {
        "type": "inductive",
        "content": "Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3."
      },
      {
        "type": "end",
        "content": "End Perm3Reminder."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.\nProof.\n  intros X l1 l2 E.\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].\n  - apply perm3_swap12.\n  - apply perm3_swap23.\n  - apply (perm3_trans _ l2 _).\n    * apply IH23.\n    * apply IH12.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Playground."
      },
      {
        "type": "inductive",
        "content": "Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)."
      },
      {
        "type": "misc",
        "content": "Notation \"n <= m\" := (le n m)."
      },
      {
        "type": "misc",
        "content": "apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "apply le_S. apply le_S. apply le_S. apply le_n.  Qed."
      },
      {
        "type": "misc",
        "content": "intros H. inversion H. inversion H2.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition lt (n m : nat) := le (S n) m."
      },
      {
        "type": "misc",
        "content": "Notation \"n < m\" := (lt n m)."
      },
      {
        "type": "definition",
        "content": "Definition ge (m n : nat) : Prop := le n m.\nNotation \"m >= n\" := (ge m n)."
      },
      {
        "type": "end",
        "content": "End Playground."
      },
      {
        "type": "lemma",
        "content": "Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "Proof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module R."
      },
      {
        "type": "inductive",
        "content": "Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_R_provability : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition fR : nat -> nat -> nat\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End R."
      },
      {
        "type": "inductive",
        "content": "Inductive subseq : list nat -> list nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)."
      },
      {
        "type": "misc",
        "content": "Arguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _."
      },
      {
        "type": "misc",
        "content": "Reserved Notation \"s =~ re\" (at level 80)."
      },
      {
        "type": "inductive",
        "content": "Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)"
      },
      {
        "type": "misc",
        "content": "where \"s =~ re\" := (exp_match s re)."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex1 : [1] =~ Char 1.\nProof.\n  apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1]).\n  - apply MChar.\n  - apply MChar.\nQed."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. inversion H.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end."
      },
      {
        "type": "example",
        "content": "Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.\nProof.\n  intros T s re H.\n  rewrite <- (app_nil_r _ s).\n  apply MStarApp.\n  - apply H.\n  - apply MStar0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition EmptyStr' {T:Type} := @Star T (EmptySet)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end."
      },
      {
        "type": "misc",
        "content": "-\n    simpl in Hin. destruct Hin.\n  -\n    simpl. simpl in Hin.\n    apply Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in *.\n    destruct Hin as [Hin | Hin].\n    +\n      left. apply (IH1 Hin).\n    +\n      right. apply (IH2 Hin).\n  -\n    simpl. rewrite In_app_iff.\n    left. apply (IH Hin).\n  -\n    simpl. rewrite In_app_iff.\n    right. apply (IH Hin).\n  -\n    destruct Hin.\n  -\n    simpl."
      },
      {
        "type": "misc",
        "content": "rewrite In_app_iff in Hin.\n    destruct Hin as [Hin | Hin].\n    +\n      apply (IH1 Hin).\n    +\n      apply (IH2 Hin).\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-\n    simpl. intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-  intros H. simpl.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re re' : reg_exp T),\n  re' = Star re ->\n  s1 =~ re' ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn:Eq."
      },
      {
        "type": "misc",
        "content": "induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2]."
      },
      {
        "type": "misc",
        "content": "-   discriminate.\n  -    discriminate.\n  -     discriminate.\n  -  discriminate.\n  -  discriminate."
      },
      {
        "type": "misc",
        "content": "-\n    intros H. apply H."
      },
      {
        "type": "misc",
        "content": "-\n    intros H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * apply Eq.\n      * apply H1."
      },
      {
        "type": "misc",
        "content": "Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    /\\ forall s', In s' ss -> s' =~ re.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module Pumping."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\n  intros T re. induction re.\n  -\n    apply le_n.\n  -\n    apply le_n.\n  -\n    apply le_S. apply le_n.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  -\n    simpl. apply IHre.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  rewrite H in Hp1. inversion Hp1.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    length s1 + length s2 <= pumping_constant re /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  -\n    simpl. intros contra. inversion contra.\n   Admitted."
      },
      {
        "type": "end",
        "content": "End Pumping."
      },
      {
        "type": "inductive",
        "content": "Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false."
      },
      {
        "type": "misc",
        "content": "intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive nostutter {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_1: nostutter [3;1;4;1;5;6].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_2:  nostutter (@nil nat).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_3:  nostutter [5].\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nostutter_4:      not (nostutter [3;1;1;4]).\n Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_nostutter : option (nat*string) := None."
      },
      {
        "type": "inductive",
        "content": "Inductive merge {X:Type} : list X -> list X -> list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive pal {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "module",
        "content": "Module RecallIn."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\/ In A x l'\n     end."
      },
      {
        "type": "end",
        "content": "End RecallIn."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_NoDup_disjoint_etc : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma in_split : forall (X:Type) (x:X) (l:list X),\n  In x l ->\n  exists l1 l2, l = l1 ++ x :: l2.\nProof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive repeats {X:Type} : list X -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_check_repeats : option (nat*string) := None."
      },
      {
        "type": "require",
        "content": "Require Import Coq.Strings.Ascii."
      },
      {
        "type": "definition",
        "content": "Definition string := list ascii."
      },
      {
        "type": "lemma",
        "content": "Lemma provable_equiv_true : forall (P : Prop), P -> (P <-> True).\nProof.\n  intros.\n  split.\n  - intros. constructor.\n  - intros _. apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_equiv_false : forall (P : Prop), ~P -> (P <-> False).\nProof.\n  intros.\n  split.\n  - apply H.\n  - intros. destruct H0.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma null_matches_none : forall (s : string), (s =~ EmptySet) <-> False.\nProof.\n  intros.\n  apply not_equiv_false.\n  unfold not. intros. inversion H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma empty_matches_eps : forall (s : string), s =~ EmptyStr <-> s = [ ].\nProof.\n  split.\n  - intros. inversion H. reflexivity.\n  - intros. rewrite H. apply MEmpty.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma empty_nomatch_ne : forall (a : ascii) s, (a :: s =~ EmptyStr) <-> False.\nProof.\n  intros.\n  apply not_equiv_false.\n  unfold not. intros. inversion H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma char_nomatch_char :\n  forall (a b : ascii) s, b <> a -> (b :: s =~ Char a <-> False).\nProof.\n  intros.\n  apply not_equiv_false.\n  unfold not.\n  intros.\n  apply H.\n  inversion H0.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma char_eps_suffix : forall (a : ascii) s, a :: s =~ Char a <-> s = [ ].\nProof.\n  split.\n  - intros. inversion H. reflexivity.\n  - intros. rewrite H. apply MChar.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma app_exists : forall (s : string) re0 re1,\n  s =~ App re0 re1 <->\n  exists s0 s1, s = s0 ++ s1 /\\ s0 =~ re0 /\\ s1 =~ re1.\nProof.\n  intros.\n  split.\n  - intros. inversion H. exists s1, s2. split.\n    * reflexivity.\n    * split. apply H3. apply H4.\n  - intros [ s0 [ s1 [ Happ [ Hmat0 Hmat1 ] ] ] ].\n    rewrite Happ. apply (MApp s0 _ s1 _ Hmat0 Hmat1).\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma app_ne : forall (a : ascii) s re0 re1,\n  a :: s =~ (App re0 re1) <->\n  ([ ] =~ re0 /\\ a :: s =~ re1) \\/\n  exists s0 s1, s = s0 ++ s1 /\\ a :: s0 =~ re0 /\\ s1 =~ re1.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma union_disj : forall (s : string) re0 re1,\n  s =~ Union re0 re1 <-> s =~ re0 \\/ s =~ re1.\nProof.\n  intros. split.\n  - intros. inversion H.\n    + left. apply H2.\n    + right. apply H1.\n  - intros [ H | H ].\n    + apply MUnionL. apply H.\n    + apply MUnionR. apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma star_ne : forall (a : ascii) s re,\n  a :: s =~ Star re <->\n  exists s0 s1, s = s0 ++ s1 /\\ a :: s0 =~ re /\\ s1 =~ Star re.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition refl_matches_eps m :=\n  forall re : reg_exp ascii, reflect ([ ] =~ re) (m re)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint match_eps (re: reg_exp ascii) : bool\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma match_eps_refl : refl_matches_eps match_eps.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition is_der re (a : ascii) re' :=\n  forall s, a :: s =~ re <-> s =~ re'."
      },
      {
        "type": "definition",
        "content": "Definition derives d := forall a re, is_der re a (d a re)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint derive (a : ascii) (re : reg_exp ascii) : reg_exp ascii\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example c := ascii_of_nat 99."
      },
      {
        "type": "example",
        "content": "Example d := ascii_of_nat 100."
      },
      {
        "type": "example",
        "content": "Example test_der0 : match_eps (derive c (EmptySet)) = false.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_der1 : match_eps (derive c (Char c)) = true.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_der2 : match_eps (derive c (Char d)) = false.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_der3 : match_eps (derive c (App (Char c) EmptyStr)) = true.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_der4 : match_eps (derive c (App EmptyStr (Char c))) = true.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_der5 : match_eps (derive c (Star (Char c))) = true.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_der6 :\n  match_eps (derive d (derive c (App (Char c) (Char d)))) = true.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_der7 :\n  match_eps (derive d (derive c (App (Char d) (Char c)))) = false.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma derive_corr : derives derive.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition matches_regex m : Prop :=\n  forall (s : string) re, reflect (s =~ re) (m s re)."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint regex_match (s : string) (re : reg_exp ascii) : bool\n  . Admitted."
      }
    ],
    "source_file": "IndProp.v"
  },
  {
    "name": "add_0_r_firsttry",
    "statement": "Theorem add_0_r_firsttry : forall n:nat,\n  n + 0 = n.",
    "proof": "",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_0_r_secondtry",
    "statement": "Theorem add_0_r_secondtry : forall n:nat,\n  n + 0 = n.",
    "proof": "Proof.intros n. destruct n as [| n'] eqn:E.\n  -\n    reflexivity.\n  -\n    simpl.\nAbort.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_0_r",
    "statement": "Theorem add_0_r : forall n:nat, n + 0 = n.",
    "proof": "Proof.intros n. induction n as [| n' IHn'].\n  -     reflexivity.\n  -  simpl. rewrite -> IHn'. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "minus_n_n",
    "statement": "Theorem minus_n_n : forall n,\n  minus n n = 0.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "mul_0_r",
    "statement": "Theorem mul_0_r : forall n:nat,\n  n * 0 = 0.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "plus_n_Sm",
    "statement": "Theorem plus_n_Sm : forall n m : nat,\n  S (n + m) = n + (S m).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_comm",
    "statement": "Theorem add_comm : forall n m : nat,\n  n + m = m + n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_assoc",
    "statement": "Theorem add_assoc : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "eqb_refl",
    "statement": "Theorem eqb_refl : forall n : nat,\n  (n =? n) = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "even_S",
    "statement": "Theorem even_S : forall n : nat,\n  even (S n) = negb (even n).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "mult_0_plus'",
    "statement": "Theorem mult_0_plus' : forall n m : nat,\n  (n + 0 + 0) * m = n * m.",
    "proof": "Proof.intros n m.\n  assert (H: n + 0 + 0 = n).\n    { rewrite add_comm. simpl. rewrite add_comm. reflexivity. }\n  rewrite -> H.\n  reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "plus_rearrange_firsttry",
    "statement": "Theorem plus_rearrange_firsttry : forall n m p q : nat,\n  (n + m) + (p + q) = (m + n) + (p + q).",
    "proof": "Proof.intros n m p q.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "plus_rearrange",
    "statement": "Theorem plus_rearrange : forall n m p q : nat,\n  (n + m) + (p + q) = (m + n) + (p + q).",
    "proof": "Proof.intros n m p q.\n  assert (H: n + m = m + n).\n  { rewrite add_comm. reflexivity. }\n  rewrite H. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_assoc'",
    "statement": "Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "proof": "Proof.intros n m p. induction n as [| n' IHn']. reflexivity.\n  simpl. rewrite IHn'. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_assoc''",
    "statement": "Theorem add_assoc'' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "proof": "Proof.intros n m p. induction n as [| n' IHn'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite IHn'. reflexivity.   Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_shuffle3",
    "statement": "Theorem add_shuffle3 : forall n m p : nat,\n  n + (m + p) = m + (n + p).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "mul_comm",
    "statement": "Theorem mul_comm : forall m n : nat,\n  m * n = n * m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "plus_leb_compat_l",
    "statement": "Theorem plus_leb_compat_l : forall n m p : nat,\n  n <=? m = true -> (p + n) <=? (p + m) = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "leb_refl",
    "statement": "Theorem leb_refl : forall n:nat,\n  (n <=? n) = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "zero_neqb_S",
    "statement": "Theorem zero_neqb_S : forall n:nat,\n  0 =? (S n) = false.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "andb_false_r",
    "statement": "Theorem andb_false_r : forall b : bool,\n  andb b false = false.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "S_neqb_0",
    "statement": "Theorem S_neqb_0 : forall n:nat,\n  (S n) =? 0 = false.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "mult_1_l",
    "statement": "Theorem mult_1_l : forall n:nat, 1 * n = n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "all3_spec",
    "statement": "Theorem all3_spec : forall b c : bool,\n  orb\n    (andb b c)\n    (orb (negb b)\n         (negb c))\n  = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "mult_plus_distr_r",
    "statement": "Theorem mult_plus_distr_r : forall n m p : nat,\n  (n + m) * p = (n * p) + (m * p).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "mult_assoc",
    "statement": "Theorem mult_assoc : forall n m p : nat,\n  n * (m * p) = (n * m) * p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "add_shuffle3'",
    "statement": "Theorem add_shuffle3' : forall n m p : nat,\n  n + (m + p) = m + (n + p).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "bin_to_nat_pres_incr",
    "statement": "Theorem bin_to_nat_pres_incr : forall b : bin,\n  bin_to_nat (incr b) = 1 + bin_to_nat b.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      },
      {
        "type": "inductive",
        "content": "Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint incr (m:bin) : bin\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint bin_to_nat (m:bin) : nat\n  . Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "nat_bin_nat",
    "statement": "Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      },
      {
        "type": "inductive",
        "content": "Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint incr (m:bin) : bin\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint bin_to_nat (m:bin) : nat\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nat_to_bin (n:nat) : bin\n  . Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "bin_nat_bin_fails",
    "statement": "Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.\nAbort.",
    "proof": "",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      },
      {
        "type": "inductive",
        "content": "Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint incr (m:bin) : bin\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint bin_to_nat (m:bin) : nat\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nat_to_bin (n:nat) : bin\n  . Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "bin_nat_bin_fails",
    "statement": "Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.\nAbort.",
    "proof": "",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      },
      {
        "type": "inductive",
        "content": "Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint incr (m:bin) : bin\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint bin_to_nat (m:bin) : nat\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nat_to_bin (n:nat) : bin\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma double_incr : forall n : nat, double (S n) = S (S (double n)).\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition double_bin (b:bin) : bin\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example double_bin_zero : double_bin Z = Z.\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma double_incr_bin : forall b,\n    double_bin (incr b) = incr (incr (double_bin b)).\nProof.\n   Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "bin_nat_bin",
    "statement": "Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Basics."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros n.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "intros n. induction n as [| n' IHn'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end."
      },
      {
        "type": "lemma",
        "content": "Lemma double_plus : forall n, double n = n + n .\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_comm_informal : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "*)"
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None."
      },
      {
        "type": "check",
        "content": "Check leb."
      },
      {
        "type": "inductive",
        "content": "Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint incr (m:bin) : bin\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint bin_to_nat (m:bin) : nat\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nat_to_bin (n:nat) : bin\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma double_incr : forall n : nat, double (S n) = S (S (double n)).\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition double_bin (b:bin) : bin\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example double_bin_zero : double_bin Z = Z.\n Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma double_incr_bin : forall b,\n    double_bin (incr b) = incr (incr (double_bin b)).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint normalize (b:bin) : bin\n  . Admitted."
      }
    ],
    "source_file": "Induction.v"
  },
  {
    "name": "surjective_pairing'",
    "statement": "Theorem surjective_pairing' : forall (n m : nat),\n  (n,m) = (fst (n,m), snd (n,m)).",
    "proof": "Proof.reflexivity. Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "surjective_pairing_stuck",
    "statement": "Theorem surjective_pairing_stuck : forall (p : natprod),\n  p = (fst p, snd p).",
    "proof": "Proof.simpl.\nAbort.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "surjective_pairing",
    "statement": "Theorem surjective_pairing : forall (p : natprod),\n  p = (fst p, snd p).",
    "proof": "Proof.intros p. destruct p as [n m]. simpl. reflexivity. Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "snd_fst_is_swap",
    "statement": "Theorem snd_fst_is_swap : forall (p : natprod),\n  (snd p, fst p) = swap_pair p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "fst_swap_is_snd",
    "statement": "Theorem fst_swap_is_snd : forall (p : natprod),\n  fst (swap_pair p) = snd p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "nil_app",
    "statement": "Theorem nil_app : forall l : natlist,\n  [] ++ l = l.",
    "proof": "Proof.reflexivity. Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "tl_length_pred",
    "statement": "Theorem tl_length_pred : forall l:natlist,\n  pred (length l) = length (tl l).",
    "proof": "Proof.intros l. destruct l as [| n l'].\n  -\n    reflexivity.\n  -\n    reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "app_assoc",
    "statement": "Theorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).",
    "proof": "Proof.intros l1 l2 l3. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "repeat_double_firsttry",
    "statement": "Theorem repeat_double_firsttry : forall c n: nat,\n  repeat n c ++ repeat n c = repeat n (c + c).",
    "proof": "Proof.intros c. induction c as [| c' IHc'].\n  -\n    intros n. simpl. reflexivity.\n  -\n    intros n. simpl.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "repeat_plus",
    "statement": "Theorem repeat_plus: forall c1 c2 n: nat,\n    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2).",
    "proof": "Proof.intros c1 c2 n.\n  induction c1 as [| c1' IHc1'].\n  - simpl. reflexivity.\n  - simpl.\n    rewrite <- IHc1'.\n    reflexivity.\n  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "rev_length_firsttry",
    "statement": "Theorem rev_length_firsttry : forall l : natlist,\n  length (rev l) = length l.",
    "proof": "Proof.intros l. induction l as [| n l' IHl'].\n  -\n    reflexivity.\n  -",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "app_rev_length_S_firsttry",
    "statement": "Theorem app_rev_length_S_firsttry: forall l n,\n  length (rev l ++ [n]) = S (length (rev l)).",
    "proof": "Proof.intros l. induction l as [| m l' IHl'].\n  -\n    intros n. simpl. reflexivity.\n  -\n    intros n. simpl.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "app_length_S",
    "statement": "Theorem app_length_S: forall l n,\n  length (l ++ [n]) = S (length l).",
    "proof": "Proof.intros l n. induction l as [| m l' IHl'].\n  -\n    simpl. reflexivity.\n  -\n    simpl.\n    rewrite IHl'.\n    reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "app_length",
    "statement": "Theorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2).",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "rev_length",
    "statement": "Theorem rev_length : forall l : natlist,\n  length (rev l) = length l.",
    "proof": "Proof.intros l. induction l as [| n l' IHl'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> app_length.\n    simpl. rewrite -> IHl'. rewrite add_comm.\n    reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "app_nil_r",
    "statement": "Theorem app_nil_r : forall l : natlist,\n  l ++ [] = l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "rev_app_distr",
    "statement": "Theorem rev_app_distr: forall l1 l2 : natlist,\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "rev_involutive",
    "statement": "Theorem rev_involutive : forall l : natlist,\n  rev (rev l) = l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "app_assoc4",
    "statement": "Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,\n  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "eqblist_refl",
    "statement": "Theorem eqblist_refl : forall l:natlist,\n  true = eqblist l l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "count_member_nonzero",
    "statement": "Theorem count_member_nonzero : forall (s : bag),\n  1 <=? (count 1 (1 :: s)) = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "leb_n_Sn",
    "statement": "Theorem leb_n_Sn : forall n,\n  n <=? (S n) = true.",
    "proof": "Proof.intros n. induction n as [| n' IHn'].\n  -\n    simpl.  reflexivity.\n  -\n    simpl.  rewrite IHn'.  reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "remove_does_not_increase_count",
    "statement": "Theorem remove_does_not_increase_count: forall (s : bag),\n  (count 0 (remove_one 0 s)) <=? (count 0 s) = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "involution_injective",
    "statement": "Theorem involution_injective : forall (f : nat -> nat),\n    (forall n : nat, n = f (f n)) -> (forall n1 n2 : nat, f n1 = f n2 -> n1 = n2).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "rev_injective",
    "statement": "Theorem rev_injective : forall (l1 l2 : natlist),\n  rev l1 = rev l2 -> l1 = l2.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "option_elim_hd",
    "statement": "Theorem option_elim_hd : forall (l:natlist) (default:nat),\n  hd default l = option_elim default (hd_error l).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_bad (l:natlist) (n:nat) : nat :=\n  match l with\n  | nil => 42\n  | a :: l' => match n with\n               | 0 => a\n               | S n' => nth_bad l' n'\n               end\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive natoption : Type :=\n  | Some (n : nat)\n  | None."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition option_elim (d : nat) (o : natoption) : nat :=\n  match o with\n  | Some n' => n'\n  | None => d\n  end."
      },
      {
        "type": "definition",
        "content": "Definition hd_error (l : natlist) : natoption\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [] = None.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error [1] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error3 : hd_error [5;6] = Some 5.\n  Admitted."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "eqb_id_refl",
    "statement": "Theorem eqb_id_refl : forall x, eqb_id x x = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_bad (l:natlist) (n:nat) : nat :=\n  match l with\n  | nil => 42\n  | a :: l' => match n with\n               | 0 => a\n               | S n' => nth_bad l' n'\n               end\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive natoption : Type :=\n  | Some (n : nat)\n  | None."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition option_elim (d : nat) (o : natoption) : nat :=\n  match o with\n  | Some n' => n'\n  | None => d\n  end."
      },
      {
        "type": "definition",
        "content": "Definition hd_error (l : natlist) : natoption\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [] = None.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error [1] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error3 : hd_error [5;6] = Some 5.\n  Admitted."
      },
      {
        "type": "end",
        "content": "End NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive id : Type :=\n  | Id (n : nat)."
      },
      {
        "type": "definition",
        "content": "Definition eqb_id (x1 x2 : id) :=\n  match x1, x2 with\n  | Id n1, Id n2 => n1 =? n2\n  end."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "update_eq",
    "statement": "Theorem update_eq :\n  forall (d : partial_map) (x : id) (v: nat),\n    find x (update d x v) = Some v.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_bad (l:natlist) (n:nat) : nat :=\n  match l with\n  | nil => 42\n  | a :: l' => match n with\n               | 0 => a\n               | S n' => nth_bad l' n'\n               end\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive natoption : Type :=\n  | Some (n : nat)\n  | None."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition option_elim (d : nat) (o : natoption) : nat :=\n  match o with\n  | Some n' => n'\n  | None => d\n  end."
      },
      {
        "type": "definition",
        "content": "Definition hd_error (l : natlist) : natoption\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [] = None.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error [1] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error3 : hd_error [5;6] = Some 5.\n  Admitted."
      },
      {
        "type": "end",
        "content": "End NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive id : Type :=\n  | Id (n : nat)."
      },
      {
        "type": "definition",
        "content": "Definition eqb_id (x1 x2 : id) :=\n  match x1, x2 with\n  | Id n1, Id n2 => n1 =? n2\n  end."
      },
      {
        "type": "module",
        "content": "Module PartialMap."
      },
      {
        "type": "import",
        "content": "Export NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map)."
      },
      {
        "type": "definition",
        "content": "Definition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint find (x : id) (d : partial_map) : natoption :=\n  match d with\n  | empty         => None\n  | record y v d' => if eqb_id x y\n                     then Some v\n                     else find x d'\n  end."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "update_neq",
    "statement": "Theorem update_neq :\n  forall (d : partial_map) (x y : id) (o: nat),\n    eqb_id x y = false -> find x (update d y o) = find x d.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From LF Require Export Induction."
      },
      {
        "type": "module",
        "content": "Module NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive natprod : Type :=\n  | pair (n1 n2 : nat)."
      },
      {
        "type": "check",
        "content": "Check (pair 3 5) : natprod."
      },
      {
        "type": "definition",
        "content": "Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end."
      },
      {
        "type": "misc",
        "content": "Compute (fst (pair 3 5))."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Compute (fst (3,5))."
      },
      {
        "type": "definition",
        "content": "Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end."
      },
      {
        "type": "definition",
        "content": "Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition bad_fst (p : natprod) : nat :=\n          match p with\n          | x, y => x\n          end."
      },
      {
        "type": "definition",
        "content": "Definition bad_minus (n m : nat) : nat :=\n          match n, m with\n          | (O   , _   ) => O\n          | (S _ , O   ) => n\n          | (S n', S m') => bad_minus n' m'\n          end.\n*)"
      },
      {
        "type": "inductive",
        "content": "Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)."
      },
      {
        "type": "definition",
        "content": "Definition mylist := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..)."
      },
      {
        "type": "definition",
        "content": "Definition mylist1 := 1 :: (2 :: (3 :: nil))."
      },
      {
        "type": "definition",
        "content": "Definition mylist2 := 1 :: 2 :: 3 :: nil."
      },
      {
        "type": "definition",
        "content": "Definition mylist3 := [1;2;3]."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60)."
      },
      {
        "type": "example",
        "content": "Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app2:             nil ++ [4;5] = [4;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_app3:             [1;2;3] ++ nil = [1;2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_hd1:             hd 0 [1;2;3] = 1.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_hd2:             hd 0 [] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_tl:              tl [1;2;3] = [2;3].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nonzeros (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint oddmembers (l:natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers (l:natlist) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers3:\n  countoddmembers nil = 0.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint alternate (l1 l2 : natlist) : natlist\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_alternate4:\n  alternate [] [20;30] = [20;30].\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition bag := natlist."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint count (v : nat) (s : bag) : nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count1:              count 1 [1;2;3;1;4;1] = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_count2:              count 6 [1;2;3;1;4;1] = 0.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition sum : bag -> bag -> bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition add (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add1:                count 1 (add 1 [1;4;1]) = 3.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_add2:                count 5 (add 1 [1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint member (v : nat) (s : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member1:             member 1 [1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_member2:             member 2 [1;4;1] = false.\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_one (v : nat) (s : bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint remove_all (v:nat) (s:bag) : bag\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint included (s1 : bag) (s2 : bag) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included1:              included [1;2] [2;1;4;1] = true.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_included2:              included [1;2;2] [2;1;4;1] = false.\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_add_inc_count : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1:            rev [1;2;3] = [3;2;1].\nProof. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:            rev nil = nil.\nProof. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "simpl."
      },
      {
        "type": "misc",
        "content": "rewrite <- IHl'."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "intros l1 l2. induction l1 as [| n l1' IHl1'].\n  -\n    reflexivity.\n  -\n    simpl. rewrite -> IHl1'. reflexivity.  Qed."
      },
      {
        "type": "misc",
        "content": "Search rev."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _)."
      },
      {
        "type": "misc",
        "content": "Search (_ + _ = _ + _) inside Induction."
      },
      {
        "type": "misc",
        "content": "Search (?x + ?y = ?y + ?x)."
      },
      {
        "type": "lemma",
        "content": "Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).\nProof.\n   Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqblist (l1 l2 : natlist) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist1 :\n  (eqblist nil nil = true).\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.\n  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_bad (l:natlist) (n:nat) : nat :=\n  match l with\n  | nil => 42\n  | a :: l' => match n with\n               | 0 => a\n               | S n' => nth_bad l' n'\n               end\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive natoption : Type :=\n  | Some (n : nat)\n  | None."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition option_elim (d : nat) (o : natoption) : nat :=\n  match o with\n  | Some n' => n'\n  | None => d\n  end."
      },
      {
        "type": "definition",
        "content": "Definition hd_error (l : natlist) : natoption\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [] = None.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error [1] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error3 : hd_error [5;6] = Some 5.\n  Admitted."
      },
      {
        "type": "end",
        "content": "End NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive id : Type :=\n  | Id (n : nat)."
      },
      {
        "type": "definition",
        "content": "Definition eqb_id (x1 x2 : id) :=\n  match x1, x2 with\n  | Id n1, Id n2 => n1 =? n2\n  end."
      },
      {
        "type": "module",
        "content": "Module PartialMap."
      },
      {
        "type": "import",
        "content": "Export NatList."
      },
      {
        "type": "inductive",
        "content": "Inductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map)."
      },
      {
        "type": "definition",
        "content": "Definition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint find (x : id) (d : partial_map) : natoption :=\n  match d with\n  | empty         => None\n  | record y v d' => if eqb_id x y\n                     then Some v\n                     else find x d'\n  end."
      }
    ],
    "source_file": "Lists.v"
  },
  {
    "name": "plus_2_2_is_4",
    "statement": "Theorem plus_2_2_is_4 :\n  2 + 2 = 4.",
    "proof": "Proof.reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "plus_claim_is_true",
    "statement": "Theorem plus_claim_is_true :\n  plus_claim.",
    "proof": "Proof.reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "and_commut",
    "statement": "Theorem and_commut : forall P Q : Prop,\n  P /\\ Q -> Q /\\ P.",
    "proof": "Proof.intros P Q [HP HQ].\n  split.\n    -  apply HQ.\n    -  apply HP.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "and_assoc",
    "statement": "Theorem and_assoc : forall P Q R : Prop,\n  P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R.",
    "proof": "Proof.intros P Q R [HP [HQ HR]].\n   Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "or_commut",
    "statement": "Theorem or_commut : forall P Q : Prop,\n  P \\/ Q  -> Q \\/ P.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "ex_falso_quodlibet",
    "statement": "Theorem ex_falso_quodlibet : forall (P:Prop),\n  False -> P.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "not_implies_our_not",
    "statement": "Theorem not_implies_our_not : forall (P:Prop),\n  ~ P -> (forall (Q:Prop), P -> Q).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "zero_not_one",
    "statement": "Theorem zero_not_one : 0 <> 1.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "not_False",
    "statement": "Theorem not_False :\n  ~ False.",
    "proof": "Proof.unfold not. intros H. destruct H. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "contradiction_implies_anything",
    "statement": "Theorem contradiction_implies_anything : forall P Q : Prop,\n  (P /\\ ~P) -> Q.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "double_neg",
    "statement": "Theorem double_neg : forall P : Prop,\n  P -> ~~P.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "contrapositive",
    "statement": "Theorem contrapositive : forall (P Q : Prop),\n  (P -> Q) -> (~Q -> ~P).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "not_both_true_and_false",
    "statement": "Theorem not_both_true_and_false : forall P : Prop,\n  ~ (P /\\ ~P).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "de_morgan_not_or",
    "statement": "Theorem de_morgan_not_or : forall (P Q : Prop),\n    ~ (P \\/ Q) -> ~P /\\ ~Q.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "not_true_is_false",
    "statement": "Theorem not_true_is_false : forall b : bool,\n  b <> true -> b = false.",
    "proof": "Proof.intros b H. destruct b eqn:HE.\n  -\n    unfold not in H.\n    apply ex_falso_quodlibet.\n    apply H. reflexivity.\n  -\n    reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "not_true_is_false'",
    "statement": "Theorem not_true_is_false' : forall b : bool,\n  b <> true -> b = false.",
    "proof": "Proof.intros [] H.\n  -\n    unfold not in H.\n    exfalso.\n    apply H. reflexivity.\n  -  reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "disc_example",
    "statement": "Theorem disc_example : forall n, ~ (O = S n).",
    "proof": "Proof.intros n contra.\n  assert (H : disc_fn O). { simpl. apply I. }\n  rewrite contra in H. simpl in H. apply H.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "nil_is_not_cons",
    "statement": "Theorem nil_is_not_cons : forall X (x : X) (xs : list X), ~ (nil = x :: xs).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "iff_sym",
    "statement": "Theorem iff_sym : forall P Q : Prop,\n  (P <-> Q) -> (Q <-> P).",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "iff_refl",
    "statement": "Theorem iff_refl : forall P : Prop,\n  P <-> P.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "iff_trans",
    "statement": "Theorem iff_trans : forall P Q R : Prop,\n  (P <-> Q) -> (Q <-> R) -> (P <-> R).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "or_distributes_over_and",
    "statement": "Theorem or_distributes_over_and : forall P Q R : Prop,\n  P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "or_assoc",
    "statement": "Theorem or_assoc :\n  forall P Q R : Prop, P \\/ (Q \\/ R) <-> (P \\/ Q) \\/ R.",
    "proof": "Proof.intros P Q R. split.\n  - intros [H | [H | H]].\n    + left. left. apply H.\n    + left. right. apply H.\n    + right. apply H.\n  - intros [[H | H] | H].\n    + left. apply H.\n    + right. left. apply H.\n    + right. right. apply H.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "exists_example_2",
    "statement": "Theorem exists_example_2 : forall n,\n  (exists m, n = 4 + m) ->\n  (exists o, n = 2 + o).",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "dist_not_exists",
    "statement": "Theorem dist_not_exists : forall (X:Type) (P : X -> Prop),\n  (forall x, P x) -> ~ (exists x, ~ P x).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "dist_exists_or",
    "statement": "Theorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),\n  (exists x, P x \\/ Q x) <-> (exists x, P x) \\/ (exists x, Q x).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "leb_plus_exists",
    "statement": "Theorem leb_plus_exists : forall n m, n <=? m = true -> exists x, m = n+x.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "plus_exists_leb",
    "statement": "Theorem plus_exists_leb : forall n m, (exists x, m = n+x) -> n <=? m = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "In_map",
    "statement": "Theorem In_map :\n  forall (A B : Type) (f : A -> B) (l : list A) (x : A),\n         In x l ->\n         In (f x) (map f l).",
    "proof": "Proof.intros A B f l x.\n  induction l as [|x' l' IHl'].\n  -\n    simpl. intros [].\n  -\n    simpl. intros [H | H].\n    + rewrite H. left. reflexivity.\n    + right. apply IHl'. apply H.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "In_map_iff",
    "statement": "Theorem In_map_iff :\n  forall (A B : Type) (f : A -> B) (l : list A) (y : B),\n         In y (map f l) <->\n         exists x, f x = y /\\ In x l.",
    "proof": "Proof.intros A B f l y. split.\n  - induction l as [|x l' IHl'].\n     Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "In_app_iff",
    "statement": "Theorem In_app_iff : forall A l l' (a:A),\n  In a (l++l') <-> In a l \\/ In a l'.",
    "proof": "Proof.intros A l. induction l as [|a' l' IH].\n   Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "All_In",
    "statement": "Theorem All_In :\n  forall T (P : T -> Prop) (l : list T),\n    (forall x, In x l -> P x) <->\n    All P l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "combine_odd_even_intro",
    "statement": "Theorem combine_odd_even_intro :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    (odd n = true -> Podd n) ->\n    (odd n = false -> Peven n) ->\n    combine_odd_even Podd Peven n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "combine_odd_even_elim_odd",
    "statement": "Theorem combine_odd_even_elim_odd :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = true ->\n    Podd n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "combine_odd_even_elim_even",
    "statement": "Theorem combine_odd_even_elim_even :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = false ->\n    Peven n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "in_not_nil",
    "statement": "Theorem in_not_nil :\n  forall A (x : A) (l : list A), In x l -> l <> [].",
    "proof": "Proof.intros A x l H. unfold not. intro Hl.\n  rewrite Hl in H.\n  simpl in H.\n  apply H.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "even_bool_prop",
    "statement": "Theorem even_bool_prop : forall n,\n  even n = true <-> Even n.",
    "proof": "Proof.intros n. split.\n  - intros H. destruct (even_double_conv n) as [k Hk].\n    rewrite Hk. rewrite H. exists k. reflexivity.\n  - intros [k Hk]. rewrite Hk. apply even_double.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "eqb_eq",
    "statement": "Theorem eqb_eq : forall n1 n2 : nat,\n  n1 =? n2 = true <-> n1 = n2.",
    "proof": "Proof.intros n1 n2. split.\n  - apply eqb_true.\n  - intros H. rewrite H. rewrite eqb_refl. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "andb_true_iff",
    "statement": "Theorem andb_true_iff : forall b1 b2:bool,\n  b1 && b2 = true <-> b1 = true /\\ b2 = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "orb_true_iff",
    "statement": "Theorem orb_true_iff : forall b1 b2,\n  b1 || b2 = true <-> b1 = true \\/ b2 = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "eqb_neq",
    "statement": "Theorem eqb_neq : forall x y : nat,\n  x =? y = false <-> x <> y.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "eqb_list_true_iff",
    "statement": "Theorem eqb_list_true_iff :\n  forall A (eqb : A -> A -> bool),\n    (forall a1 a2, eqb a1 a2 = true <-> a1 = a2) ->\n    forall l1 l2, eqb_list eqb l1 l2 = true <-> l1 = l2.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  . Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "forallb_true_iff",
    "statement": "Theorem forallb_true_iff : forall X test (l : list X),\n  forallb test l = true <-> All (fun x => test x = true) l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "tr_rev_correct",
    "statement": "Theorem tr_rev_correct : forall X, @tr_rev X = @rev X.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  Fail reflexivity. Fail rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Axiom functional_extensionality : forall {X Y: Type}\n                                    {f g : X -> Y},\n  (forall (x:X), f x = g x) -> f = g."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  apply functional_extensionality. intros x.\n  apply add_comm.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tr_rev {X} (l : list X) : list X :=\n  rev_append l []."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "restricted_excluded_middle",
    "statement": "Theorem restricted_excluded_middle : forall P b,\n  (P <-> b = true) -> P \\/ ~ P.",
    "proof": "Proof.intros P [] H.\n  - left. rewrite H. reflexivity.\n  - right. rewrite H. intros contra. discriminate contra.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  Fail reflexivity. Fail rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Axiom functional_extensionality : forall {X Y: Type}\n                                    {f g : X -> Y},\n  (forall (x:X), f x = g x) -> f = g."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  apply functional_extensionality. intros x.\n  apply add_comm.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tr_rev {X} (l : list X) : list X :=\n  rev_append l []."
      },
      {
        "type": "definition",
        "content": "Definition excluded_middle := forall P : Prop,\n  P \\/ ~ P."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "restricted_excluded_middle_eq",
    "statement": "Theorem restricted_excluded_middle_eq : forall (n m : nat),\n  n = m \\/ n <> m.",
    "proof": "Proof.intros n m.\n  apply (restricted_excluded_middle (n = m) (n =? m)).\n  symmetry.\n  apply eqb_eq.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  Fail reflexivity. Fail rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Axiom functional_extensionality : forall {X Y: Type}\n                                    {f g : X -> Y},\n  (forall (x:X), f x = g x) -> f = g."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  apply functional_extensionality. intros x.\n  apply add_comm.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tr_rev {X} (l : list X) : list X :=\n  rev_append l []."
      },
      {
        "type": "definition",
        "content": "Definition excluded_middle := forall P : Prop,\n  P \\/ ~ P."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "excluded_middle_irrefutable",
    "statement": "Theorem excluded_middle_irrefutable: forall (P : Prop),\n  ~ ~ (P \\/ ~ P).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  Fail reflexivity. Fail rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Axiom functional_extensionality : forall {X Y: Type}\n                                    {f g : X -> Y},\n  (forall (x:X), f x = g x) -> f = g."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  apply functional_extensionality. intros x.\n  apply add_comm.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tr_rev {X} (l : list X) : list X :=\n  rev_append l []."
      },
      {
        "type": "definition",
        "content": "Definition excluded_middle := forall P : Prop,\n  P \\/ ~ P."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "not_exists_dist",
    "statement": "Theorem not_exists_dist :\n  excluded_middle ->\n  forall (X:Type) (P : X -> Prop),\n    ~ (exists x, ~ P x) -> (forall x, P x).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing\"."
      },
      {
        "type": "global_directive",
        "content": "Set Warnings \"-deprecated-hint-without-locality\"."
      },
      {
        "type": "require",
        "content": "Require Nat."
      },
      {
        "type": "import",
        "content": "From LF Require Export Tactics."
      },
      {
        "type": "check",
        "content": "Check (forall n m : nat, n + m = m + n) : Prop."
      },
      {
        "type": "check",
        "content": "Check 2 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check 3 = 2 : Prop."
      },
      {
        "type": "check",
        "content": "Check forall n : nat, n = 2 : Prop."
      },
      {
        "type": "definition",
        "content": "Definition plus_claim : Prop := 2 + 2 = 4."
      },
      {
        "type": "check",
        "content": "Check plus_claim : Prop."
      },
      {
        "type": "definition",
        "content": "Definition is_three (n : nat) : Prop :=\n  n = 3."
      },
      {
        "type": "check",
        "content": "Check is_three : nat -> Prop."
      },
      {
        "type": "definition",
        "content": "Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y."
      },
      {
        "type": "lemma",
        "content": "Lemma succ_inj : injective S.\nProof.\n  intros x y H. injection H as H1. apply H1.\nQed."
      },
      {
        "type": "check",
        "content": "Check @eq : forall A : Type, A -> A -> Prop."
      },
      {
        "type": "example",
        "content": "Example and_example : 3 + 4 = 7 /\\ 2 * 2 = 4."
      },
      {
        "type": "misc",
        "content": "Proof.\n  split.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "check",
        "content": "Check @conj : forall A B : Prop, A -> B -> A /\\ B."
      },
      {
        "type": "example",
        "content": "Example and_example' : 3 + 4 = 7 /\\ 2 * 2 = 4.\nProof.\n  apply conj.\n  -  reflexivity.\n  -  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 /\\ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2 :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  destruct H as [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2' :\n  forall n m : nat, n = 0 /\\ m = 0 -> n + m = 0.\nProof.\n  intros n m [Hn Hm].\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.\nProof.\n  intros n m Hn Hm.\n  rewrite Hn. rewrite Hm.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m H.\n  apply plus_is_O in H.\n  destruct H as [Hn Hm].\n  rewrite Hn. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj1 : forall P Q : Prop,\n  P /\\ Q -> P.\nProof.\n  intros P Q HPQ.\n  destruct HPQ as [HP _].\n  apply HP.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma proj2 : forall P Q : Prop,\n  P /\\ Q -> Q.\nProof.\n   Admitted."
      },
      {
        "type": "check",
        "content": "Check and : Prop -> Prop -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma factor_is_O:\n  forall n m : nat, n = 0 \\/ m = 0 -> n * m = 0.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m [Hn | Hm].\n  -\n    rewrite Hn. reflexivity.\n  -\n    rewrite Hm. rewrite <- mult_n_O.\n    reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma or_intro_l : forall A B : Prop, A -> A \\/ B.\nProof.\n  intros A B HA.\n  left.\n  apply HA.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma zero_or_succ :\n  forall n : nat, n = 0 \\/ n = S (pred n).\nProof."
      },
      {
        "type": "misc",
        "content": "intros [|n'].\n  - left. reflexivity.\n  - right. reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\/ m = 0.\nProof.\n   Admitted."
      },
      {
        "type": "module",
        "content": "Module NotPlayground."
      },
      {
        "type": "definition",
        "content": "Definition not (P:Prop) := P -> False."
      },
      {
        "type": "check",
        "content": "Check not : Prop -> Prop."
      },
      {
        "type": "misc",
        "content": "Notation \"~ x\" := (not x) : type_scope."
      },
      {
        "type": "end",
        "content": "End NotPlayground."
      },
      {
        "type": "misc",
        "content": "intros P contra.\n  destruct contra.  Qed."
      },
      {
        "type": "misc",
        "content": "Notation \"x <> y\" := (~(x = y)) : type_scope."
      },
      {
        "type": "misc",
        "content": "unfold not."
      },
      {
        "type": "misc",
        "content": "intros contra."
      },
      {
        "type": "misc",
        "content": "discriminate contra.\nQed."
      },
      {
        "type": "misc",
        "content": "intros P Q [HP HNP]. unfold not in HNP.\n  apply HNP in HP. destruct HP.  Qed."
      },
      {
        "type": "misc",
        "content": "intros P H. unfold not. intros G. apply G. apply H.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_double_neg_informal : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_not_PNP_informal : option (nat*string) := None."
      },
      {
        "type": "lemma",
        "content": "Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma True_is_true : True.\nProof. apply I. Qed."
      },
      {
        "type": "definition",
        "content": "Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end."
      },
      {
        "type": "module",
        "content": "Module IffPlayground."
      },
      {
        "type": "definition",
        "content": "Definition iff (P Q : Prop) := (P -> Q) /\\ (Q -> P)."
      },
      {
        "type": "misc",
        "content": "Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope."
      },
      {
        "type": "end",
        "content": "End IffPlayground."
      },
      {
        "type": "misc",
        "content": "intros P Q [HAB HBA].\n  split.\n  -  apply HBA.\n  -  apply HAB.  Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.\nProof."
      },
      {
        "type": "misc",
        "content": "intros b. split.\n  -  apply not_true_is_false.\n  -\n    intros H. rewrite H. intros H'. discriminate H'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).\nProof.\n  intros P Q R Hiff H HP. apply H. apply Hiff. apply HP.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).\nProof.\n  intros P Q R Hiff H HQ. apply H. apply Hiff. apply HQ.\nQed."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Setoids.Setoid."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\/ m = 0.\nProof.\n  split.\n  - apply mult_is_O.\n  - apply factor_is_O.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\/ m = 0 \\/ p = 0.\nProof.\n  intros n m p.\n  rewrite mul_eq_0. rewrite mul_eq_0. rewrite or_assoc.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition Even x := exists n : nat, x = double n."
      },
      {
        "type": "check",
        "content": "Check Even : nat -> Prop."
      },
      {
        "type": "lemma",
        "content": "Lemma four_is_Even : Even 4.\nProof.\n  unfold Even. exists 2. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "intros n [m Hm].\n  exists (2 + m).\n  apply Hm.  Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\/ In x l'\n  end."
      },
      {
        "type": "example",
        "content": "Example In_example_1 : In 4 [1; 2; 3; 4; 5].\nProof."
      },
      {
        "type": "misc",
        "content": "simpl. right. right. right. left. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.\nProof."
      },
      {
        "type": "misc",
        "content": "simpl.\n  intros n [H | [H | []]].\n  - exists 1. rewrite <- H. reflexivity.\n  - exists 2. rewrite <- H. reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "check",
        "content": "Check @rev : forall X, list X -> list X."
      },
      {
        "type": "check",
        "content": "Check add_comm        : forall n m : nat, n + m = m + n."
      },
      {
        "type": "check",
        "content": "Check plus_id_example : forall n m : nat, n = m -> n + n = m + m."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3 :\n  forall x y z, x + (y + z) = (z + y) + x."
      },
      {
        "type": "misc",
        "content": "Proof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  assert (H : y + z = z + y).\n    { rewrite add_comm. reflexivity. }\n  rewrite H.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite add_comm.\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.\nProof.\n  intros x y z.\n  rewrite (add_comm x (y + z)).\n  rewrite (add_comm y z).\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  Fail apply in_not_nil.\nAbort."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil with (x := 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply in_not_nil in H.\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil nat 42).\n  apply H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].\nProof.\n  intros l H.\n  apply (in_not_nil _ _ _ H).\nQed."
      },
      {
        "type": "example",
        "content": "Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.\nProof.\n  intros n ns H.\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].\n  rewrite mul_0_r in Hm. rewrite <- Hm. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example even_42_bool : even 42 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_42_prop : Even 42.\nProof. unfold Even. exists 21. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double : forall k, even (double k) = true.\nProof.\n  intros k. induction k as [|k' IHk'].\n  - reflexivity.\n  - simpl. apply IHk'.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).\nProof."
      },
      {
        "type": "misc",
        "content": "Admitted."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n = 2 then true\n  else false."
      },
      {
        "type": "definition",
        "content": "Definition is_even_prime n :=\n  if n =? 2 then true\n  else false."
      },
      {
        "type": "example",
        "content": "Example even_1000 : Even 1000."
      },
      {
        "type": "misc",
        "content": "Proof. unfold Even. exists 500. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000' : even 1000 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example even_1000'' : Even 1000.\nProof. apply even_bool_prop. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001 : even 1001 = false.\nProof.\n  reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example not_even_1001' : ~(Even 1001)."
      },
      {
        "type": "misc",
        "content": "Proof."
      },
      {
        "type": "misc",
        "content": "rewrite <- even_bool_prop.\n  unfold not.\n  simpl.\n  intro H.\n  discriminate H.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.\nProof."
      },
      {
        "type": "misc",
        "content": "intros n m p H.\n  rewrite eqb_eq in H.\n  rewrite H.\n  rewrite eqb_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  . Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  Fail reflexivity. Fail rewrite add_comm."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "Axiom functional_extensionality : forall {X Y: Type}\n                                    {f g : X -> Y},\n  (forall (x:X), f x = g x) -> f = g."
      },
      {
        "type": "example",
        "content": "Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  apply functional_extensionality. intros x.\n  apply add_comm.\nQed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end."
      },
      {
        "type": "definition",
        "content": "Definition tr_rev {X} (l : list X) : list X :=\n  rev_append l []."
      },
      {
        "type": "definition",
        "content": "Definition excluded_middle := forall P : Prop,\n  P \\/ ~ P."
      }
    ],
    "source_file": "Logic.v"
  },
  {
    "name": "t_update_neq",
    "statement": "Theorem t_update_neq : forall (A : Type) (m : total_map A) x1 x2 v,\n  x1 <> x2 ->\n  (x1 !-> v ; m) x2 = m x2.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Export Strings.String."
      },
      {
        "type": "import",
        "content": "From Coq Require Import FunctionalExtensionality."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List."
      },
      {
        "type": "import",
        "content": "Import ListNotations."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "misc",
        "content": "Locate \"+\"."
      },
      {
        "type": "misc",
        "content": "Print Init.Nat.add."
      },
      {
        "type": "check",
        "content": "Check String.eqb_refl :\n  forall x : string, (x =? x)%string = true."
      },
      {
        "type": "check",
        "content": "Check String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y)."
      },
      {
        "type": "definition",
        "content": "Definition total_map (A : Type) := string -> A."
      },
      {
        "type": "definition",
        "content": "Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v)."
      },
      {
        "type": "definition",
        "content": "Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'."
      },
      {
        "type": "definition",
        "content": "Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true."
      },
      {
        "type": "misc",
        "content": "Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity)."
      },
      {
        "type": "example",
        "content": "Example example_empty := (_ !-> false)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  )."
      },
      {
        "type": "example",
        "content": "Example update_example1 : examplemap' \"baz\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example2 : examplemap' \"foo\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example3 : examplemap' \"quux\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example4 : examplemap' \"bar\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Maps.v"
  },
  {
    "name": "t_update_same",
    "statement": "Theorem t_update_same : forall (A : Type) (m : total_map A) x,\n  (x !-> m x ; m) = m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Export Strings.String."
      },
      {
        "type": "import",
        "content": "From Coq Require Import FunctionalExtensionality."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List."
      },
      {
        "type": "import",
        "content": "Import ListNotations."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "misc",
        "content": "Locate \"+\"."
      },
      {
        "type": "misc",
        "content": "Print Init.Nat.add."
      },
      {
        "type": "check",
        "content": "Check String.eqb_refl :\n  forall x : string, (x =? x)%string = true."
      },
      {
        "type": "check",
        "content": "Check String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y)."
      },
      {
        "type": "definition",
        "content": "Definition total_map (A : Type) := string -> A."
      },
      {
        "type": "definition",
        "content": "Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v)."
      },
      {
        "type": "definition",
        "content": "Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'."
      },
      {
        "type": "definition",
        "content": "Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true."
      },
      {
        "type": "misc",
        "content": "Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity)."
      },
      {
        "type": "example",
        "content": "Example example_empty := (_ !-> false)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  )."
      },
      {
        "type": "example",
        "content": "Example update_example1 : examplemap' \"baz\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example2 : examplemap' \"foo\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example3 : examplemap' \"quux\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example4 : examplemap' \"bar\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).\nProof.\n   Admitted."
      }
    ],
    "source_file": "Maps.v"
  },
  {
    "name": "t_update_permute",
    "statement": "Theorem t_update_permute : forall (A : Type) (m : total_map A)\n                                  v1 v2 x1 x2,\n  x2 <> x1 ->\n  (x1 !-> v1 ; x2 !-> v2 ; m)\n  =\n  (x2 !-> v2 ; x1 !-> v1 ; m).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Export Strings.String."
      },
      {
        "type": "import",
        "content": "From Coq Require Import FunctionalExtensionality."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List."
      },
      {
        "type": "import",
        "content": "Import ListNotations."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "misc",
        "content": "Locate \"+\"."
      },
      {
        "type": "misc",
        "content": "Print Init.Nat.add."
      },
      {
        "type": "check",
        "content": "Check String.eqb_refl :\n  forall x : string, (x =? x)%string = true."
      },
      {
        "type": "check",
        "content": "Check String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y)."
      },
      {
        "type": "definition",
        "content": "Definition total_map (A : Type) := string -> A."
      },
      {
        "type": "definition",
        "content": "Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v)."
      },
      {
        "type": "definition",
        "content": "Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'."
      },
      {
        "type": "definition",
        "content": "Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true."
      },
      {
        "type": "misc",
        "content": "Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity)."
      },
      {
        "type": "example",
        "content": "Example example_empty := (_ !-> false)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  )."
      },
      {
        "type": "example",
        "content": "Example update_example1 : examplemap' \"baz\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example2 : examplemap' \"foo\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example3 : examplemap' \"quux\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example4 : examplemap' \"bar\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).\nProof.\n   Admitted."
      }
    ],
    "source_file": "Maps.v"
  },
  {
    "name": "update_neq",
    "statement": "Theorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,\n  x2 <> x1 ->\n  (x2 |-> v ; m) x1 = m x1.",
    "proof": "Proof.intros A m x1 x2 v H.\n  unfold update. rewrite t_update_neq.\n  - reflexivity.\n  - apply H.\nQed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Export Strings.String."
      },
      {
        "type": "import",
        "content": "From Coq Require Import FunctionalExtensionality."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List."
      },
      {
        "type": "import",
        "content": "Import ListNotations."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "misc",
        "content": "Locate \"+\"."
      },
      {
        "type": "misc",
        "content": "Print Init.Nat.add."
      },
      {
        "type": "check",
        "content": "Check String.eqb_refl :\n  forall x : string, (x =? x)%string = true."
      },
      {
        "type": "check",
        "content": "Check String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y)."
      },
      {
        "type": "definition",
        "content": "Definition total_map (A : Type) := string -> A."
      },
      {
        "type": "definition",
        "content": "Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v)."
      },
      {
        "type": "definition",
        "content": "Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'."
      },
      {
        "type": "definition",
        "content": "Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true."
      },
      {
        "type": "misc",
        "content": "Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity)."
      },
      {
        "type": "example",
        "content": "Example example_empty := (_ !-> false)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  )."
      },
      {
        "type": "example",
        "content": "Example update_example1 : examplemap' \"baz\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example2 : examplemap' \"foo\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example3 : examplemap' \"quux\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example4 : examplemap' \"bar\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition partial_map (A : Type) := total_map (option A)."
      },
      {
        "type": "definition",
        "content": "Definition empty {A : Type} : partial_map A :=\n  t_empty None."
      },
      {
        "type": "definition",
        "content": "Definition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '|->' v ';' m\" := (update m x v)\n  (at level 100, v at next level, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '|->' v\" := (update empty x v)\n  (at level 100)."
      },
      {
        "type": "definition",
        "content": "Definition examplepmap :=\n  (\"Church\" |-> true ; \"Turing\" |-> false)."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_empty : forall (A : Type) (x : string),\n  @empty A x = None.\nProof.\n  intros. unfold empty. rewrite t_apply_empty.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v.\nProof.\n  intros. unfold update. rewrite t_update_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "#[global] Hint Resolve update_eq : core."
      }
    ],
    "source_file": "Maps.v"
  },
  {
    "name": "update_same",
    "statement": "Theorem update_same : forall (A : Type) (m : partial_map A) x v,\n  m x = Some v ->\n  (x |-> v ; m) = m.",
    "proof": "Proof.intros A m x v H. unfold update. rewrite <- H.\n  apply t_update_same.\nQed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Export Strings.String."
      },
      {
        "type": "import",
        "content": "From Coq Require Import FunctionalExtensionality."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List."
      },
      {
        "type": "import",
        "content": "Import ListNotations."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "misc",
        "content": "Locate \"+\"."
      },
      {
        "type": "misc",
        "content": "Print Init.Nat.add."
      },
      {
        "type": "check",
        "content": "Check String.eqb_refl :\n  forall x : string, (x =? x)%string = true."
      },
      {
        "type": "check",
        "content": "Check String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y)."
      },
      {
        "type": "definition",
        "content": "Definition total_map (A : Type) := string -> A."
      },
      {
        "type": "definition",
        "content": "Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v)."
      },
      {
        "type": "definition",
        "content": "Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'."
      },
      {
        "type": "definition",
        "content": "Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true."
      },
      {
        "type": "misc",
        "content": "Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity)."
      },
      {
        "type": "example",
        "content": "Example example_empty := (_ !-> false)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  )."
      },
      {
        "type": "example",
        "content": "Example update_example1 : examplemap' \"baz\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example2 : examplemap' \"foo\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example3 : examplemap' \"quux\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example4 : examplemap' \"bar\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition partial_map (A : Type) := total_map (option A)."
      },
      {
        "type": "definition",
        "content": "Definition empty {A : Type} : partial_map A :=\n  t_empty None."
      },
      {
        "type": "definition",
        "content": "Definition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '|->' v ';' m\" := (update m x v)\n  (at level 100, v at next level, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '|->' v\" := (update empty x v)\n  (at level 100)."
      },
      {
        "type": "definition",
        "content": "Definition examplepmap :=\n  (\"Church\" |-> true ; \"Turing\" |-> false)."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_empty : forall (A : Type) (x : string),\n  @empty A x = None.\nProof.\n  intros. unfold empty. rewrite t_apply_empty.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v.\nProof.\n  intros. unfold update. rewrite t_update_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "#[global] Hint Resolve update_eq : core."
      },
      {
        "type": "lemma",
        "content": "Lemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,\n  (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m).\nProof.\n  intros A m x v1 v2. unfold update. rewrite t_update_shadow.\n  reflexivity.\nQed."
      }
    ],
    "source_file": "Maps.v"
  },
  {
    "name": "update_permute",
    "statement": "Theorem update_permute : forall (A : Type) (m : partial_map A)\n                                x1 x2 v1 v2,\n  x2 <> x1 ->\n  (x1 |-> v1 ; x2 |-> v2 ; m) = (x2 |-> v2 ; x1 |-> v1 ; m).",
    "proof": "Proof.intros A m x1 x2 v1 v2. unfold update.\n  apply t_update_permute.\nQed.",
    "dependencies": [
      {
        "type": "import",
        "content": "From Coq Require Import Arith."
      },
      {
        "type": "import",
        "content": "From Coq Require Import Bool."
      },
      {
        "type": "import",
        "content": "From Coq Require Export Strings.String."
      },
      {
        "type": "import",
        "content": "From Coq Require Import FunctionalExtensionality."
      },
      {
        "type": "import",
        "content": "From Coq Require Import List."
      },
      {
        "type": "import",
        "content": "Import ListNotations."
      },
      {
        "type": "global_directive",
        "content": "Set Default Goal Selector \"!\"."
      },
      {
        "type": "misc",
        "content": "Locate \"+\"."
      },
      {
        "type": "misc",
        "content": "Print Init.Nat.add."
      },
      {
        "type": "check",
        "content": "Check String.eqb_refl :\n  forall x : string, (x =? x)%string = true."
      },
      {
        "type": "check",
        "content": "Check String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m."
      },
      {
        "type": "check",
        "content": "Check String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y)."
      },
      {
        "type": "definition",
        "content": "Definition total_map (A : Type) := string -> A."
      },
      {
        "type": "definition",
        "content": "Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v)."
      },
      {
        "type": "definition",
        "content": "Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'."
      },
      {
        "type": "definition",
        "content": "Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true."
      },
      {
        "type": "misc",
        "content": "Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity)."
      },
      {
        "type": "example",
        "content": "Example example_empty := (_ !-> false)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  )."
      },
      {
        "type": "example",
        "content": "Example update_example1 : examplemap' \"baz\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example2 : examplemap' \"foo\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example3 : examplemap' \"quux\" = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example update_example4 : examplemap' \"bar\" = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.\nProof.\n   Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition partial_map (A : Type) := total_map (option A)."
      },
      {
        "type": "definition",
        "content": "Definition empty {A : Type} : partial_map A :=\n  t_empty None."
      },
      {
        "type": "definition",
        "content": "Definition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '|->' v ';' m\" := (update m x v)\n  (at level 100, v at next level, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"x '|->' v\" := (update empty x v)\n  (at level 100)."
      },
      {
        "type": "definition",
        "content": "Definition examplepmap :=\n  (\"Church\" |-> true ; \"Turing\" |-> false)."
      },
      {
        "type": "lemma",
        "content": "Lemma apply_empty : forall (A : Type) (x : string),\n  @empty A x = None.\nProof.\n  intros. unfold empty. rewrite t_apply_empty.\n  reflexivity.\nQed."
      },
      {
        "type": "lemma",
        "content": "Lemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v.\nProof.\n  intros. unfold update. rewrite t_update_eq.\n  reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "#[global] Hint Resolve update_eq : core."
      },
      {
        "type": "lemma",
        "content": "Lemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,\n  (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m).\nProof.\n  intros A m x v1 v2. unfold update. rewrite t_update_shadow.\n  reflexivity.\nQed."
      }
    ],
    "source_file": "Maps.v"
  },
  {
    "name": "app_nil_r",
    "statement": "Theorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "app_assoc",
    "statement": "Theorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "rev_app_distr",
    "statement": "Theorem rev_app_distr: forall X (l1 l2 : list X),\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      },
      {
        "type": "lemma",
        "content": "Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "rev_involutive",
    "statement": "Theorem rev_involutive : forall X : Type, forall l : list X,\n  rev (rev l) = l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      },
      {
        "type": "lemma",
        "content": "Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "map_rev",
    "statement": "Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),\n  map f (rev l) = rev (map f l).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      },
      {
        "type": "lemma",
        "content": "Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.\nProof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y)."
      },
      {
        "type": "misc",
        "content": "Arguments pair {X} {Y}."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"X * Y\" := (prod X Y) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n           : list (X*Y) :=\n  match lx, ly with\n  | [], _ => []\n  | _, [] => []\n  | x :: tx, y :: ty => (x, y) :: (combine tx ty)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_split:\n  split [(1,false);(2,false)] = ([1;2],[false;false]).\nProof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module OptionPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive option (X:Type) : Type :=\n  | Some (x : X)\n  | None."
      },
      {
        "type": "misc",
        "content": "Arguments Some {X}.\nArguments None {X}."
      },
      {
        "type": "end",
        "content": "End OptionPlayground."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [true] 2 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd_error {X : Type} (l : list X) : option X\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check @hd_error : forall X : Type, list X -> option X."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [1;2] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition doit3times {X : Type} (f : X->X) (n : X) : X :=\n  f (f (f n))."
      },
      {
        "type": "check",
        "content": "Check @doit3times : forall X : Type, (X -> X) -> X -> X."
      },
      {
        "type": "example",
        "content": "Example test_doit3times: doit3times minustwo 9 = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_doit3times': doit3times negb true = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_filter1: filter even [1;2;3;4] = [2;4].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition length_is_1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1."
      },
      {
        "type": "example",
        "content": "Example test_filter2:\n    filter length_is_1\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers' (l:list nat) : nat :=\n  length (filter odd l)."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'3:   countoddmembers' nil = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_anon_fun':\n  doit3times (fun n => n * n) 2 = 256.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition filter_even_gt7 (l : list nat) : list nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_1 :\n  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_2 :\n  filter_even_gt7 [5;2;6;19;129] = [].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition partition {X : Type}\n                     (test : X -> bool)\n                     (l : list X)\n                   : list X * list X\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map2:\n  map odd [2;1;2;5] = [false;true;false;true].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map3:\n    map (fun n => [even n;odd n]) [2;1;2;5]\n  = [[true;false];[false;true];[true;false];[false;true]].\nProof. reflexivity. Qed."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "fold_length_correct",
    "statement": "Theorem fold_length_correct : forall X (l : list X),\n  fold_length l = length l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      },
      {
        "type": "lemma",
        "content": "Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.\nProof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y)."
      },
      {
        "type": "misc",
        "content": "Arguments pair {X} {Y}."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"X * Y\" := (prod X Y) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n           : list (X*Y) :=\n  match lx, ly with\n  | [], _ => []\n  | _, [] => []\n  | x :: tx, y :: ty => (x, y) :: (combine tx ty)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_split:\n  split [(1,false);(2,false)] = ([1;2],[false;false]).\nProof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module OptionPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive option (X:Type) : Type :=\n  | Some (x : X)\n  | None."
      },
      {
        "type": "misc",
        "content": "Arguments Some {X}.\nArguments None {X}."
      },
      {
        "type": "end",
        "content": "End OptionPlayground."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [true] 2 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd_error {X : Type} (l : list X) : option X\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check @hd_error : forall X : Type, list X -> option X."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [1;2] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition doit3times {X : Type} (f : X->X) (n : X) : X :=\n  f (f (f n))."
      },
      {
        "type": "check",
        "content": "Check @doit3times : forall X : Type, (X -> X) -> X -> X."
      },
      {
        "type": "example",
        "content": "Example test_doit3times: doit3times minustwo 9 = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_doit3times': doit3times negb true = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_filter1: filter even [1;2;3;4] = [2;4].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition length_is_1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1."
      },
      {
        "type": "example",
        "content": "Example test_filter2:\n    filter length_is_1\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers' (l:list nat) : nat :=\n  length (filter odd l)."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'3:   countoddmembers' nil = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_anon_fun':\n  doit3times (fun n => n * n) 2 = 256.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition filter_even_gt7 (l : list nat) : list nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_1 :\n  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_2 :\n  filter_even_gt7 [5;2;6;19;129] = [].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition partition {X : Type}\n                     (test : X -> bool)\n                     (l : list X)\n                   : list X * list X\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map2:\n  map odd [2;1;2;5] = [false;true;false;true].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map3:\n    map (fun n => [even n;odd n]) [2;1;2;5]\n  = [[true;false];[false;true];[true;false];[false;true]].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)\n                   : list Y\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_flat_map1:\n  flat_map (fun n => [n;n;n]) [1;5;4]\n  = [1; 1; 1; 5; 5; 5; 4; 4; 4].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end."
      },
      {
        "type": "check",
        "content": "Check (fold andb) : list bool -> bool -> bool."
      },
      {
        "type": "example",
        "content": "Example fold_example1 :\n  fold andb [true;true;false;true] true = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example fold_example2 :\n  fold mult [1;2;3;4] 1 = 24.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example fold_example3 :\n  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x."
      },
      {
        "type": "definition",
        "content": "Definition ftrue := constfun true."
      },
      {
        "type": "example",
        "content": "Example constfun_example1 : ftrue 0 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example constfun_example2 : (constfun 5) 99 = 5.\nProof. reflexivity. Qed."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "definition",
        "content": "Definition plus3 := plus 3."
      },
      {
        "type": "check",
        "content": "Check plus3 : nat -> nat."
      },
      {
        "type": "example",
        "content": "Example test_plus3 :    plus3 4 = 7.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_plus3' :   doit3times plus3 0 = 9.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_plus3'' :  doit3times (plus 3) 0 = 9.\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module Exercises."
      },
      {
        "type": "definition",
        "content": "Definition fold_length {X : Type} (l : list X) : nat :=\n  fold (fun _ n => S n) l 0."
      },
      {
        "type": "example",
        "content": "Example test_fold_length1 : fold_length [4;7;0] = 3.\nProof. reflexivity. Qed."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "uncurry_curry",
    "statement": "Theorem uncurry_curry : forall (X Y Z : Type)\n                        (f : X -> Y -> Z)\n                        x y,\n  prod_curry (prod_uncurry f) x y = f x y.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      },
      {
        "type": "lemma",
        "content": "Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.\nProof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y)."
      },
      {
        "type": "misc",
        "content": "Arguments pair {X} {Y}."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"X * Y\" := (prod X Y) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n           : list (X*Y) :=\n  match lx, ly with\n  | [], _ => []\n  | _, [] => []\n  | x :: tx, y :: ty => (x, y) :: (combine tx ty)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_split:\n  split [(1,false);(2,false)] = ([1;2],[false;false]).\nProof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module OptionPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive option (X:Type) : Type :=\n  | Some (x : X)\n  | None."
      },
      {
        "type": "misc",
        "content": "Arguments Some {X}.\nArguments None {X}."
      },
      {
        "type": "end",
        "content": "End OptionPlayground."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [true] 2 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd_error {X : Type} (l : list X) : option X\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check @hd_error : forall X : Type, list X -> option X."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [1;2] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition doit3times {X : Type} (f : X->X) (n : X) : X :=\n  f (f (f n))."
      },
      {
        "type": "check",
        "content": "Check @doit3times : forall X : Type, (X -> X) -> X -> X."
      },
      {
        "type": "example",
        "content": "Example test_doit3times: doit3times minustwo 9 = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_doit3times': doit3times negb true = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_filter1: filter even [1;2;3;4] = [2;4].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition length_is_1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1."
      },
      {
        "type": "example",
        "content": "Example test_filter2:\n    filter length_is_1\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers' (l:list nat) : nat :=\n  length (filter odd l)."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'3:   countoddmembers' nil = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_anon_fun':\n  doit3times (fun n => n * n) 2 = 256.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition filter_even_gt7 (l : list nat) : list nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_1 :\n  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_2 :\n  filter_even_gt7 [5;2;6;19;129] = [].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition partition {X : Type}\n                     (test : X -> bool)\n                     (l : list X)\n                   : list X * list X\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map2:\n  map odd [2;1;2;5] = [false;true;false;true].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map3:\n    map (fun n => [even n;odd n]) [2;1;2;5]\n  = [[true;false];[false;true];[true;false];[false;true]].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)\n                   : list Y\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_flat_map1:\n  flat_map (fun n => [n;n;n]) [1;5;4]\n  = [1; 1; 1; 5; 5; 5; 4; 4; 4].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end."
      },
      {
        "type": "check",
        "content": "Check (fold andb) : list bool -> bool -> bool."
      },
      {
        "type": "example",
        "content": "Example fold_example1 :\n  fold andb [true;true;false;true] true = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example fold_example2 :\n  fold mult [1;2;3;4] 1 = 24.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example fold_example3 :\n  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x."
      },
      {
        "type": "definition",
        "content": "Definition ftrue := constfun true."
      },
      {
        "type": "example",
        "content": "Example constfun_example1 : ftrue 0 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example constfun_example2 : (constfun 5) 99 = 5.\nProof. reflexivity. Qed."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "definition",
        "content": "Definition plus3 := plus 3."
      },
      {
        "type": "check",
        "content": "Check plus3 : nat -> nat."
      },
      {
        "type": "example",
        "content": "Example test_plus3 :    plus3 4 = 7.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_plus3' :   doit3times plus3 0 = 9.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_plus3'' :  doit3times (plus 3) 0 = 9.\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module Exercises."
      },
      {
        "type": "definition",
        "content": "Definition fold_length {X : Type} (l : list X) : nat :=\n  fold (fun _ n => S n) l 0."
      },
      {
        "type": "example",
        "content": "Example test_fold_length1 : fold_length [4;7;0] = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_fold_map : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition prod_curry {X Y Z : Type}\n  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y)."
      },
      {
        "type": "definition",
        "content": "Definition prod_uncurry {X Y Z : Type}\n  (f : X -> Y -> Z) (p : X * Y) : Z\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_map1': map (plus 3) [2;0;2] = [5;3;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "check",
        "content": "Check @prod_curry."
      },
      {
        "type": "check",
        "content": "Check @prod_uncurry."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "curry_uncurry",
    "statement": "Theorem curry_uncurry : forall (X Y Z : Type)\n                        (f : (X * Y) -> Z) (p : X * Y),\n  prod_uncurry (prod_curry f) p = f p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Lists."
      },
      {
        "type": "inductive",
        "content": "Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)."
      },
      {
        "type": "inductive",
        "content": "Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)."
      },
      {
        "type": "check",
        "content": "Check list : Type -> Type."
      },
      {
        "type": "check",
        "content": "Check (nil nat) : list nat."
      },
      {
        "type": "check",
        "content": "Check (cons nat 3 (nil nat)) : list nat."
      },
      {
        "type": "check",
        "content": "Check nil : forall X : Type, list X."
      },
      {
        "type": "check",
        "content": "Check cons : forall X : Type, X -> list X -> list X."
      },
      {
        "type": "check",
        "content": "Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module MumbleGrumble."
      },
      {
        "type": "inductive",
        "content": "Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c."
      },
      {
        "type": "inductive",
        "content": "Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)."
      },
      {
        "type": "end",
        "content": "End MumbleGrumble."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end."
      },
      {
        "type": "check",
        "content": "Check repeat'\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "check",
        "content": "Check repeat\n  : forall X : Type, X -> nat -> list X."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end."
      },
      {
        "type": "definition",
        "content": "Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))."
      },
      {
        "type": "definition",
        "content": "Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))."
      },
      {
        "type": "misc",
        "content": "Arguments nil {X}.\nArguments cons {X}.\nArguments repeat {X}."
      },
      {
        "type": "definition",
        "content": "Definition list123'' := cons 1 (cons 2 (cons 3 nil))."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end."
      },
      {
        "type": "inductive",
        "content": "Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end."
      },
      {
        "type": "example",
        "content": "Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_rev2:\n  rev (cons true nil) = cons true nil.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "misc",
        "content": "Fail Definition mynil := nil."
      },
      {
        "type": "definition",
        "content": "Definition mynil : list nat := nil."
      },
      {
        "type": "check",
        "content": "Check @nil : forall X : Type, list X."
      },
      {
        "type": "definition",
        "content": "Definition mynil' := @nil nat."
      },
      {
        "type": "misc",
        "content": "Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "misc",
        "content": "Notation \"[ ]\" := nil."
      },
      {
        "type": "misc",
        "content": "Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..)."
      },
      {
        "type": "misc",
        "content": "Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity)."
      },
      {
        "type": "definition",
        "content": "Definition list123''' := [1; 2; 3]."
      },
      {
        "type": "lemma",
        "content": "Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.\nProof.\n   Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y)."
      },
      {
        "type": "misc",
        "content": "Arguments pair {X} {Y}."
      },
      {
        "type": "misc",
        "content": "Notation \"( x , y )\" := (pair x y)."
      },
      {
        "type": "misc",
        "content": "Notation \"X * Y\" := (prod X Y) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end."
      },
      {
        "type": "definition",
        "content": "Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n           : list (X*Y) :=\n  match lx, ly with\n  | [], _ => []\n  | _, [] => []\n  | x :: tx, y :: ty => (x, y) :: (combine tx ty)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_split:\n  split [(1,false);(2,false)] = ([1;2],[false;false]).\nProof.\n Admitted."
      },
      {
        "type": "module",
        "content": "Module OptionPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive option (X:Type) : Type :=\n  | Some (x : X)\n  | None."
      },
      {
        "type": "misc",
        "content": "Arguments Some {X}.\nArguments None {X}."
      },
      {
        "type": "end",
        "content": "End OptionPlayground."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end."
      },
      {
        "type": "example",
        "content": "Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_nth_error3 : nth_error [true] 2 = None.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition hd_error {X : Type} (l : list X) : option X\n  . Admitted."
      },
      {
        "type": "check",
        "content": "Check @hd_error : forall X : Type, list X -> option X."
      },
      {
        "type": "example",
        "content": "Example test_hd_error1 : hd_error [1;2] = Some 1.\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition doit3times {X : Type} (f : X->X) (n : X) : X :=\n  f (f (f n))."
      },
      {
        "type": "check",
        "content": "Check @doit3times : forall X : Type, (X -> X) -> X -> X."
      },
      {
        "type": "example",
        "content": "Example test_doit3times: doit3times minustwo 9 = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_doit3times': doit3times negb true = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end."
      },
      {
        "type": "example",
        "content": "Example test_filter1: filter even [1;2;3;4] = [2;4].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition length_is_1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1."
      },
      {
        "type": "example",
        "content": "Example test_filter2:\n    filter length_is_1\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition countoddmembers' (l:list nat) : nat :=\n  length (filter odd l)."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_countoddmembers'3:   countoddmembers' nil = 0.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_anon_fun':\n  doit3times (fun n => n * n) 2 = 256.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition filter_even_gt7 (l : list nat) : list nat\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_1 :\n  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].\n  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_filter_even_gt7_2 :\n  filter_even_gt7 [5;2;6;19;129] = [].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition partition {X : Type}\n                     (test : X -> bool)\n                     (l : list X)\n                   : list X * list X\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).\n Admitted."
      },
      {
        "type": "example",
        "content": "Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).\n Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end."
      },
      {
        "type": "example",
        "content": "Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map2:\n  map odd [2;1;2;5] = [false;true;false;true].\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_map3:\n    map (fun n => [even n;odd n]) [2;1;2;5]\n  = [[true;false];[false;true];[true;false];[false;true]].\nProof. reflexivity. Qed."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)\n                   : list Y\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_flat_map1:\n  flat_map (fun n => [n;n;n]) [1;5;4]\n  = [1; 1; 1; 5; 5; 5; 4; 4; 4].\n  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end."
      },
      {
        "type": "check",
        "content": "Check (fold andb) : list bool -> bool -> bool."
      },
      {
        "type": "example",
        "content": "Example fold_example1 :\n  fold andb [true;true;false;true] true = false.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example fold_example2 :\n  fold mult [1;2;3;4] 1 = 24.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example fold_example3 :\n  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x."
      },
      {
        "type": "definition",
        "content": "Definition ftrue := constfun true."
      },
      {
        "type": "example",
        "content": "Example constfun_example1 : ftrue 0 = true.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example constfun_example2 : (constfun 5) 99 = 5.\nProof. reflexivity. Qed."
      },
      {
        "type": "check",
        "content": "Check plus : nat -> nat -> nat."
      },
      {
        "type": "definition",
        "content": "Definition plus3 := plus 3."
      },
      {
        "type": "check",
        "content": "Check plus3 : nat -> nat."
      },
      {
        "type": "example",
        "content": "Example test_plus3 :    plus3 4 = 7.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_plus3' :   doit3times plus3 0 = 9.\nProof. reflexivity. Qed."
      },
      {
        "type": "example",
        "content": "Example test_plus3'' :  doit3times (plus 3) 0 = 9.\nProof. reflexivity. Qed."
      },
      {
        "type": "module",
        "content": "Module Exercises."
      },
      {
        "type": "definition",
        "content": "Definition fold_length {X : Type} (l : list X) : nat :=\n  fold (fun _ n => S n) l 0."
      },
      {
        "type": "example",
        "content": "Example test_fold_length1 : fold_length [4;7;0] = 3.\nProof. reflexivity. Qed."
      },
      {
        "type": "definition",
        "content": "Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_fold_map : option (nat*string) := None."
      },
      {
        "type": "definition",
        "content": "Definition prod_curry {X Y Z : Type}\n  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y)."
      },
      {
        "type": "definition",
        "content": "Definition prod_uncurry {X Y Z : Type}\n  (f : X -> Y -> Z) (p : X * Y) : Z\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_map1': map (plus 3) [2;0;2] = [5;3;5].\nProof. reflexivity. Qed."
      },
      {
        "type": "check",
        "content": "Check @prod_curry."
      },
      {
        "type": "check",
        "content": "Check @prod_uncurry."
      }
    ],
    "source_file": "Poly.v"
  },
  {
    "name": "ev_4",
    "statement": "Theorem ev_4 : ev 4.",
    "proof": "Proof.apply ev_SS. apply ev_SS. apply ev_0. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "ev_4'",
    "statement": "Theorem ev_4': ev 4.",
    "proof": "Proof.apply (ev_SS 2 (ev_SS 0 ev_0)).\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "ev_4''",
    "statement": "Theorem ev_4'' : ev 4.",
    "proof": "Proof.Show",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "ev_8",
    "statement": "Theorem ev_8 : ev 8.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "ev_plus4",
    "statement": "Theorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "proof": "Proof.intros n H. simpl.\n  apply ev_SS.\n  apply ev_SS.\n  apply H.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      },
      {
        "type": "definition",
        "content": "Definition ev_8' : ev 8\n  . Admitted."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "proj1'",
    "statement": "Theorem proj1' : forall P Q,\n  P /\\ Q -> P.",
    "proof": "Proof.intros P Q HPQ. destruct HPQ as [HP HQ]. apply HP.\n  Show",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      },
      {
        "type": "definition",
        "content": "Definition ev_8' : ev 8\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "check",
        "content": "Check ev_plus4'' : forall n : nat, ev n -> ev (4 + n)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition add1 : nat -> nat.\nintro n.\nShow Proof.\napply S.\nShow Proof.\napply n. Defined."
      },
      {
        "type": "misc",
        "content": "Print add1."
      },
      {
        "type": "misc",
        "content": "Compute add1 2."
      },
      {
        "type": "module",
        "content": "Module Props."
      },
      {
        "type": "module",
        "content": "Module And."
      },
      {
        "type": "inductive",
        "content": "Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q."
      },
      {
        "type": "misc",
        "content": "Arguments conj [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P /\\ Q\" := (and P Q) : type_scope."
      },
      {
        "type": "misc",
        "content": "Print prod."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "inj_l'",
    "statement": "Theorem inj_l' : forall (P Q : Prop), P -> P \\/ Q.",
    "proof": "Proof.intros P Q HP. left. apply HP.\n  Show",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      },
      {
        "type": "definition",
        "content": "Definition ev_8' : ev 8\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "check",
        "content": "Check ev_plus4'' : forall n : nat, ev n -> ev (4 + n)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition add1 : nat -> nat.\nintro n.\nShow Proof.\napply S.\nShow Proof.\napply n. Defined."
      },
      {
        "type": "misc",
        "content": "Print add1."
      },
      {
        "type": "misc",
        "content": "Compute add1 2."
      },
      {
        "type": "module",
        "content": "Module Props."
      },
      {
        "type": "module",
        "content": "Module And."
      },
      {
        "type": "inductive",
        "content": "Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q."
      },
      {
        "type": "misc",
        "content": "Arguments conj [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P /\\ Q\" := (and P Q) : type_scope."
      },
      {
        "type": "misc",
        "content": "Print prod."
      },
      {
        "type": "lemma",
        "content": "Lemma and_comm : forall P Q : Prop, P /\\ Q <-> Q /\\ P.\nProof.\n  intros P Q. split.\n  - intros [HP HQ]. split.\n    + apply HQ.\n    + apply HP.\n  - intros [HQ HP]. split.\n    + apply HP.\n    + apply HQ.\nQed."
      },
      {
        "type": "end",
        "content": "End And."
      },
      {
        "type": "definition",
        "content": "Definition proj1'' P Q (HPQ : P /\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm'_aux P Q (H : P /\\ Q) : Q /\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm' P Q : P /\\ Q <-> Q /\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P)."
      },
      {
        "type": "definition",
        "content": "Definition conj_fact : forall P Q R, P /\\ Q -> Q /\\ R -> P /\\ R\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Or."
      },
      {
        "type": "inductive",
        "content": "Inductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q."
      },
      {
        "type": "misc",
        "content": "Arguments or_introl [P] [Q].\nArguments or_intror [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P \\/ Q\" := (or P Q) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition inj_l : forall (P Q : Prop), P -> P \\/ Q :=\n  fun P Q HP => or_introl HP."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "or_elim'",
    "statement": "Theorem or_elim' : forall (P Q R : Prop), (P \\/ Q) -> (P -> R) -> (Q -> R) -> R.",
    "proof": "Proof.intros P Q R HPQ HPR HQR.\n  destruct HPQ as [HP | HQ].\n  - apply HPR. apply HP.\n  - apply HQR. apply HQ.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      },
      {
        "type": "definition",
        "content": "Definition ev_8' : ev 8\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "check",
        "content": "Check ev_plus4'' : forall n : nat, ev n -> ev (4 + n)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition add1 : nat -> nat.\nintro n.\nShow Proof.\napply S.\nShow Proof.\napply n. Defined."
      },
      {
        "type": "misc",
        "content": "Print add1."
      },
      {
        "type": "misc",
        "content": "Compute add1 2."
      },
      {
        "type": "module",
        "content": "Module Props."
      },
      {
        "type": "module",
        "content": "Module And."
      },
      {
        "type": "inductive",
        "content": "Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q."
      },
      {
        "type": "misc",
        "content": "Arguments conj [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P /\\ Q\" := (and P Q) : type_scope."
      },
      {
        "type": "misc",
        "content": "Print prod."
      },
      {
        "type": "lemma",
        "content": "Lemma and_comm : forall P Q : Prop, P /\\ Q <-> Q /\\ P.\nProof.\n  intros P Q. split.\n  - intros [HP HQ]. split.\n    + apply HQ.\n    + apply HP.\n  - intros [HQ HP]. split.\n    + apply HP.\n    + apply HQ.\nQed."
      },
      {
        "type": "end",
        "content": "End And."
      },
      {
        "type": "definition",
        "content": "Definition proj1'' P Q (HPQ : P /\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm'_aux P Q (H : P /\\ Q) : Q /\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm' P Q : P /\\ Q <-> Q /\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P)."
      },
      {
        "type": "definition",
        "content": "Definition conj_fact : forall P Q R, P /\\ Q -> Q /\\ R -> P /\\ R\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Or."
      },
      {
        "type": "inductive",
        "content": "Inductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q."
      },
      {
        "type": "misc",
        "content": "Arguments or_introl [P] [Q].\nArguments or_intror [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P \\/ Q\" := (or P Q) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition inj_l : forall (P Q : Prop), P -> P \\/ Q :=\n  fun P Q HP => or_introl HP."
      },
      {
        "type": "definition",
        "content": "Definition or_elim : forall (P Q R : Prop), (P \\/ Q) -> (P -> R) -> (Q -> R) -> R :=\n  fun P Q R HPQ HPR HQR =>\n    match HPQ with\n    | or_introl HP => HPR HP\n    | or_intror HQ => HQR HQ\n    end."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "eq_add'",
    "statement": "Theorem eq_add' : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2).",
    "proof": "Proof.intros n1 n2 Heq.\n  Fail rewrite Heq.\n  destruct Heq as [n].\n  Fail reflexivity.\n  apply eq_refl.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      },
      {
        "type": "definition",
        "content": "Definition ev_8' : ev 8\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "check",
        "content": "Check ev_plus4'' : forall n : nat, ev n -> ev (4 + n)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition add1 : nat -> nat.\nintro n.\nShow Proof.\napply S.\nShow Proof.\napply n. Defined."
      },
      {
        "type": "misc",
        "content": "Print add1."
      },
      {
        "type": "misc",
        "content": "Compute add1 2."
      },
      {
        "type": "module",
        "content": "Module Props."
      },
      {
        "type": "module",
        "content": "Module And."
      },
      {
        "type": "inductive",
        "content": "Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q."
      },
      {
        "type": "misc",
        "content": "Arguments conj [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P /\\ Q\" := (and P Q) : type_scope."
      },
      {
        "type": "misc",
        "content": "Print prod."
      },
      {
        "type": "lemma",
        "content": "Lemma and_comm : forall P Q : Prop, P /\\ Q <-> Q /\\ P.\nProof.\n  intros P Q. split.\n  - intros [HP HQ]. split.\n    + apply HQ.\n    + apply HP.\n  - intros [HQ HP]. split.\n    + apply HP.\n    + apply HQ.\nQed."
      },
      {
        "type": "end",
        "content": "End And."
      },
      {
        "type": "definition",
        "content": "Definition proj1'' P Q (HPQ : P /\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm'_aux P Q (H : P /\\ Q) : Q /\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm' P Q : P /\\ Q <-> Q /\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P)."
      },
      {
        "type": "definition",
        "content": "Definition conj_fact : forall P Q R, P /\\ Q -> Q /\\ R -> P /\\ R\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Or."
      },
      {
        "type": "inductive",
        "content": "Inductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q."
      },
      {
        "type": "misc",
        "content": "Arguments or_introl [P] [Q].\nArguments or_intror [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P \\/ Q\" := (or P Q) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition inj_l : forall (P Q : Prop), P -> P \\/ Q :=\n  fun P Q HP => or_introl HP."
      },
      {
        "type": "definition",
        "content": "Definition or_elim : forall (P Q R : Prop), (P \\/ Q) -> (P -> R) -> (Q -> R) -> R :=\n  fun P Q R HPQ HPR HQR =>\n    match HPQ with\n    | or_introl HP => HPR HP\n    | or_intror HQ => HQR HQ\n    end."
      },
      {
        "type": "end",
        "content": "End Or."
      },
      {
        "type": "definition",
        "content": "Definition or_commut' : forall P Q, P \\/ Q -> Q \\/ P\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Ex."
      },
      {
        "type": "inductive",
        "content": "Inductive ex {A : Type} (P : A -> Prop) : Prop :=\n  | ex_intro : forall x : A, P x -> ex P."
      },
      {
        "type": "misc",
        "content": "Notation \"'exists' x , p\" :=\n  (ex (fun x => p))\n    (at level 200, right associativity) : type_scope."
      },
      {
        "type": "end",
        "content": "End Ex."
      },
      {
        "type": "check",
        "content": "Check ex (fun n => ev n) : Prop."
      },
      {
        "type": "definition",
        "content": "Definition some_nat_is_even : exists n, ev n :=\n  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0))."
      },
      {
        "type": "definition",
        "content": "Definition ex_ev_Sn : ex (fun n => ev (S n))\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition dist_exists_or_term (X:Type) (P Q : X -> Prop) :\n  (exists x, P x \\/ Q x) -> (exists x, P x) \\/ (exists x, Q x) :=\n  fun H => match H with\n           | ex_intro _ x Hx =>\n               match Hx with\n               | or_introl HPx => or_introl (ex_intro _ x HPx)\n               | or_intror HQx => or_intror (ex_intro _ x HQx)\n               end\n           end."
      },
      {
        "type": "definition",
        "content": "Definition ex_match : forall (A : Type) (P Q : A -> Prop),\n  (forall x, P x -> Q x) ->\n  (exists x, P x) -> (exists x, Q x)\n  . Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive True : Prop :=\n  | I : True."
      },
      {
        "type": "definition",
        "content": "Definition p_implies_true : forall P, P -> True\n  . Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive False : Prop := ."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition contra : False :=\n  42."
      },
      {
        "type": "definition",
        "content": "Definition false_implies_zero_eq_one : False -> 0 = 1 :=\n  fun contra => match contra with end."
      },
      {
        "type": "definition",
        "content": "Definition ex_falso_quodlibet' : forall P, False -> P\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End Props."
      },
      {
        "type": "module",
        "content": "Module EqualityPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive eq {X:Type} : X -> X -> Prop :=\n  | eq_refl : forall x, eq x x."
      },
      {
        "type": "misc",
        "content": "Notation \"x == y\" := (eq x y)\n                       (at level 70, no associativity)\n                     : type_scope."
      },
      {
        "type": "lemma",
        "content": "Lemma four: 2 + 2 == 1 + 3.\nProof.\n  apply eq_refl.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition four' : 2 + 2 == 1 + 3 :=\n  eq_refl 4."
      },
      {
        "type": "definition",
        "content": "Definition singleton : forall (X:Type) (x:X), []++[x] == x::[]  :=\n  fun (X:Type) (x:X) => eq_refl [x]."
      },
      {
        "type": "definition",
        "content": "Definition eq_add : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2) :=\n  fun n1 n2 Heq =>\n    match Heq with\n    | eq_refl n => eq_refl (S n)\n    end."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "pe_implies_or_eq",
    "statement": "Theorem pe_implies_or_eq :\n  propositional_extensionality ->\n  forall (P Q : Prop), (P \\/ Q) = (Q \\/ P).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      },
      {
        "type": "definition",
        "content": "Definition ev_8' : ev 8\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "check",
        "content": "Check ev_plus4'' : forall n : nat, ev n -> ev (4 + n)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition add1 : nat -> nat.\nintro n.\nShow Proof.\napply S.\nShow Proof.\napply n. Defined."
      },
      {
        "type": "misc",
        "content": "Print add1."
      },
      {
        "type": "misc",
        "content": "Compute add1 2."
      },
      {
        "type": "module",
        "content": "Module Props."
      },
      {
        "type": "module",
        "content": "Module And."
      },
      {
        "type": "inductive",
        "content": "Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q."
      },
      {
        "type": "misc",
        "content": "Arguments conj [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P /\\ Q\" := (and P Q) : type_scope."
      },
      {
        "type": "misc",
        "content": "Print prod."
      },
      {
        "type": "lemma",
        "content": "Lemma and_comm : forall P Q : Prop, P /\\ Q <-> Q /\\ P.\nProof.\n  intros P Q. split.\n  - intros [HP HQ]. split.\n    + apply HQ.\n    + apply HP.\n  - intros [HQ HP]. split.\n    + apply HP.\n    + apply HQ.\nQed."
      },
      {
        "type": "end",
        "content": "End And."
      },
      {
        "type": "definition",
        "content": "Definition proj1'' P Q (HPQ : P /\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm'_aux P Q (H : P /\\ Q) : Q /\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm' P Q : P /\\ Q <-> Q /\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P)."
      },
      {
        "type": "definition",
        "content": "Definition conj_fact : forall P Q R, P /\\ Q -> Q /\\ R -> P /\\ R\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Or."
      },
      {
        "type": "inductive",
        "content": "Inductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q."
      },
      {
        "type": "misc",
        "content": "Arguments or_introl [P] [Q].\nArguments or_intror [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P \\/ Q\" := (or P Q) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition inj_l : forall (P Q : Prop), P -> P \\/ Q :=\n  fun P Q HP => or_introl HP."
      },
      {
        "type": "definition",
        "content": "Definition or_elim : forall (P Q R : Prop), (P \\/ Q) -> (P -> R) -> (Q -> R) -> R :=\n  fun P Q R HPQ HPR HQR =>\n    match HPQ with\n    | or_introl HP => HPR HP\n    | or_intror HQ => HQR HQ\n    end."
      },
      {
        "type": "end",
        "content": "End Or."
      },
      {
        "type": "definition",
        "content": "Definition or_commut' : forall P Q, P \\/ Q -> Q \\/ P\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Ex."
      },
      {
        "type": "inductive",
        "content": "Inductive ex {A : Type} (P : A -> Prop) : Prop :=\n  | ex_intro : forall x : A, P x -> ex P."
      },
      {
        "type": "misc",
        "content": "Notation \"'exists' x , p\" :=\n  (ex (fun x => p))\n    (at level 200, right associativity) : type_scope."
      },
      {
        "type": "end",
        "content": "End Ex."
      },
      {
        "type": "check",
        "content": "Check ex (fun n => ev n) : Prop."
      },
      {
        "type": "definition",
        "content": "Definition some_nat_is_even : exists n, ev n :=\n  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0))."
      },
      {
        "type": "definition",
        "content": "Definition ex_ev_Sn : ex (fun n => ev (S n))\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition dist_exists_or_term (X:Type) (P Q : X -> Prop) :\n  (exists x, P x \\/ Q x) -> (exists x, P x) \\/ (exists x, Q x) :=\n  fun H => match H with\n           | ex_intro _ x Hx =>\n               match Hx with\n               | or_introl HPx => or_introl (ex_intro _ x HPx)\n               | or_intror HQx => or_intror (ex_intro _ x HQx)\n               end\n           end."
      },
      {
        "type": "definition",
        "content": "Definition ex_match : forall (A : Type) (P Q : A -> Prop),\n  (forall x, P x -> Q x) ->\n  (exists x, P x) -> (exists x, Q x)\n  . Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive True : Prop :=\n  | I : True."
      },
      {
        "type": "definition",
        "content": "Definition p_implies_true : forall P, P -> True\n  . Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive False : Prop := ."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition contra : False :=\n  42."
      },
      {
        "type": "definition",
        "content": "Definition false_implies_zero_eq_one : False -> 0 = 1 :=\n  fun contra => match contra with end."
      },
      {
        "type": "definition",
        "content": "Definition ex_falso_quodlibet' : forall P, False -> P\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End Props."
      },
      {
        "type": "module",
        "content": "Module EqualityPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive eq {X:Type} : X -> X -> Prop :=\n  | eq_refl : forall x, eq x x."
      },
      {
        "type": "misc",
        "content": "Notation \"x == y\" := (eq x y)\n                       (at level 70, no associativity)\n                     : type_scope."
      },
      {
        "type": "lemma",
        "content": "Lemma four: 2 + 2 == 1 + 3.\nProof.\n  apply eq_refl.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition four' : 2 + 2 == 1 + 3 :=\n  eq_refl 4."
      },
      {
        "type": "definition",
        "content": "Definition singleton : forall (X:Type) (x:X), []++[x] == x::[]  :=\n  fun (X:Type) (x:X) => eq_refl [x]."
      },
      {
        "type": "definition",
        "content": "Definition eq_add : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2) :=\n  fun n1 n2 Heq =>\n    match Heq with\n    | eq_refl n => eq_refl (S n)\n    end."
      },
      {
        "type": "definition",
        "content": "Definition eq_cons : forall (X : Type) (h1 h2 : X) (t1 t2 : list X),\n    h1 == h2 -> t1 == t2 -> h1 :: t1 == h2 :: t2\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma equality__leibniz_equality : forall (X : Type) (x y: X),\n  x == y -> forall (P : X -> Prop), P x -> P y.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition equality__leibniz_equality_term : forall (X : Type) (x y: X),\n    x == y -> forall P : (X -> Prop), P x -> P y\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma leibniz_equality__equality : forall (X : Type) (x y: X),\n  (forall P:X->Prop, P x -> P y) -> x == y.\nProof.\n Admitted."
      },
      {
        "type": "end",
        "content": "End EqualityPlayground."
      },
      {
        "type": "misc",
        "content": "Fail Definition or_bogus : forall P Q, P \\/ Q -> P :=\n  fun (P Q : Prop) (A : P \\/ Q) =>\n    match A with\n    | or_introl H => H\n    end."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint infinite_loop {X : Type} (n : nat) {struct n} : X :=\n  infinite_loop n."
      },
      {
        "type": "misc",
        "content": "Fail Definition falso : False := infinite_loop 0."
      },
      {
        "type": "definition",
        "content": "Definition and_assoc : forall P Q R : Prop,\n    P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition or_distributes_over_and : forall P Q R : Prop,\n    P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R)\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition double_neg : forall P : Prop,\n    P -> ~~P\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition contradiction_implies_anything : forall P Q : Prop,\n    (P /\\ ~P) -> Q\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\/ Q) -> ~P /\\ ~Q\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition curry : forall P Q R : Prop,\n    ((P /\\ Q) -> R) -> (P -> (Q -> R))\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition uncurry : forall P Q R : Prop,\n    (P -> (Q -> R)) -> ((P /\\ Q) -> R)\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition propositional_extensionality : Prop :=\n  forall (P Q : Prop), (P <-> Q) -> P = Q."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "pe_implies_pi",
    "statement": "Theorem pe_implies_pi :\n  propositional_extensionality -> proof_irrelevance.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "inductive",
        "content": "Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))."
      },
      {
        "type": "check",
        "content": "Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n))."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "check",
        "content": "Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4."
      },
      {
        "type": "definition",
        "content": "Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)."
      },
      {
        "type": "misc",
        "content": "Print ev_4."
      },
      {
        "type": "misc",
        "content": "Print ev_4'."
      },
      {
        "type": "misc",
        "content": "Print ev_4''."
      },
      {
        "type": "misc",
        "content": "Print ev_4'''."
      },
      {
        "type": "definition",
        "content": "Definition ev_8' : ev 8\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H)."
      },
      {
        "type": "check",
        "content": "Check ev_plus4'' : forall n : nat, ev n -> ev (4 + n)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)."
      },
      {
        "type": "definition",
        "content": "Definition add1 : nat -> nat.\nintro n.\nShow Proof.\napply S.\nShow Proof.\napply n. Defined."
      },
      {
        "type": "misc",
        "content": "Print add1."
      },
      {
        "type": "misc",
        "content": "Compute add1 2."
      },
      {
        "type": "module",
        "content": "Module Props."
      },
      {
        "type": "module",
        "content": "Module And."
      },
      {
        "type": "inductive",
        "content": "Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q."
      },
      {
        "type": "misc",
        "content": "Arguments conj [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P /\\ Q\" := (and P Q) : type_scope."
      },
      {
        "type": "misc",
        "content": "Print prod."
      },
      {
        "type": "lemma",
        "content": "Lemma and_comm : forall P Q : Prop, P /\\ Q <-> Q /\\ P.\nProof.\n  intros P Q. split.\n  - intros [HP HQ]. split.\n    + apply HQ.\n    + apply HP.\n  - intros [HQ HP]. split.\n    + apply HP.\n    + apply HQ.\nQed."
      },
      {
        "type": "end",
        "content": "End And."
      },
      {
        "type": "definition",
        "content": "Definition proj1'' P Q (HPQ : P /\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm'_aux P Q (H : P /\\ Q) : Q /\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end."
      },
      {
        "type": "definition",
        "content": "Definition and_comm' P Q : P /\\ Q <-> Q /\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P)."
      },
      {
        "type": "definition",
        "content": "Definition conj_fact : forall P Q R, P /\\ Q -> Q /\\ R -> P /\\ R\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Or."
      },
      {
        "type": "inductive",
        "content": "Inductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q."
      },
      {
        "type": "misc",
        "content": "Arguments or_introl [P] [Q].\nArguments or_intror [P] [Q]."
      },
      {
        "type": "misc",
        "content": "Notation \"P \\/ Q\" := (or P Q) : type_scope."
      },
      {
        "type": "definition",
        "content": "Definition inj_l : forall (P Q : Prop), P -> P \\/ Q :=\n  fun P Q HP => or_introl HP."
      },
      {
        "type": "definition",
        "content": "Definition or_elim : forall (P Q R : Prop), (P \\/ Q) -> (P -> R) -> (Q -> R) -> R :=\n  fun P Q R HPQ HPR HQR =>\n    match HPQ with\n    | or_introl HP => HPR HP\n    | or_intror HQ => HQR HQ\n    end."
      },
      {
        "type": "end",
        "content": "End Or."
      },
      {
        "type": "definition",
        "content": "Definition or_commut' : forall P Q, P \\/ Q -> Q \\/ P\n  . Admitted."
      },
      {
        "type": "module",
        "content": "Module Ex."
      },
      {
        "type": "inductive",
        "content": "Inductive ex {A : Type} (P : A -> Prop) : Prop :=\n  | ex_intro : forall x : A, P x -> ex P."
      },
      {
        "type": "misc",
        "content": "Notation \"'exists' x , p\" :=\n  (ex (fun x => p))\n    (at level 200, right associativity) : type_scope."
      },
      {
        "type": "end",
        "content": "End Ex."
      },
      {
        "type": "check",
        "content": "Check ex (fun n => ev n) : Prop."
      },
      {
        "type": "definition",
        "content": "Definition some_nat_is_even : exists n, ev n :=\n  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0))."
      },
      {
        "type": "definition",
        "content": "Definition ex_ev_Sn : ex (fun n => ev (S n))\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition dist_exists_or_term (X:Type) (P Q : X -> Prop) :\n  (exists x, P x \\/ Q x) -> (exists x, P x) \\/ (exists x, Q x) :=\n  fun H => match H with\n           | ex_intro _ x Hx =>\n               match Hx with\n               | or_introl HPx => or_introl (ex_intro _ x HPx)\n               | or_intror HQx => or_intror (ex_intro _ x HQx)\n               end\n           end."
      },
      {
        "type": "definition",
        "content": "Definition ex_match : forall (A : Type) (P Q : A -> Prop),\n  (forall x, P x -> Q x) ->\n  (exists x, P x) -> (exists x, Q x)\n  . Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive True : Prop :=\n  | I : True."
      },
      {
        "type": "definition",
        "content": "Definition p_implies_true : forall P, P -> True\n  . Admitted."
      },
      {
        "type": "inductive",
        "content": "Inductive False : Prop := ."
      },
      {
        "type": "misc",
        "content": "Fail"
      },
      {
        "type": "definition",
        "content": "Definition contra : False :=\n  42."
      },
      {
        "type": "definition",
        "content": "Definition false_implies_zero_eq_one : False -> 0 = 1 :=\n  fun contra => match contra with end."
      },
      {
        "type": "definition",
        "content": "Definition ex_falso_quodlibet' : forall P, False -> P\n  . Admitted."
      },
      {
        "type": "end",
        "content": "End Props."
      },
      {
        "type": "module",
        "content": "Module EqualityPlayground."
      },
      {
        "type": "inductive",
        "content": "Inductive eq {X:Type} : X -> X -> Prop :=\n  | eq_refl : forall x, eq x x."
      },
      {
        "type": "misc",
        "content": "Notation \"x == y\" := (eq x y)\n                       (at level 70, no associativity)\n                     : type_scope."
      },
      {
        "type": "lemma",
        "content": "Lemma four: 2 + 2 == 1 + 3.\nProof.\n  apply eq_refl.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition four' : 2 + 2 == 1 + 3 :=\n  eq_refl 4."
      },
      {
        "type": "definition",
        "content": "Definition singleton : forall (X:Type) (x:X), []++[x] == x::[]  :=\n  fun (X:Type) (x:X) => eq_refl [x]."
      },
      {
        "type": "definition",
        "content": "Definition eq_add : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2) :=\n  fun n1 n2 Heq =>\n    match Heq with\n    | eq_refl n => eq_refl (S n)\n    end."
      },
      {
        "type": "definition",
        "content": "Definition eq_cons : forall (X : Type) (h1 h2 : X) (t1 t2 : list X),\n    h1 == h2 -> t1 == t2 -> h1 :: t1 == h2 :: t2\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma equality__leibniz_equality : forall (X : Type) (x y: X),\n  x == y -> forall (P : X -> Prop), P x -> P y.\nProof.\n   Admitted."
      },
      {
        "type": "definition",
        "content": "Definition equality__leibniz_equality_term : forall (X : Type) (x y: X),\n    x == y -> forall P : (X -> Prop), P x -> P y\n  . Admitted."
      },
      {
        "type": "lemma",
        "content": "Lemma leibniz_equality__equality : forall (X : Type) (x y: X),\n  (forall P:X->Prop, P x -> P y) -> x == y.\nProof.\n Admitted."
      },
      {
        "type": "end",
        "content": "End EqualityPlayground."
      },
      {
        "type": "misc",
        "content": "Fail Definition or_bogus : forall P Q, P \\/ Q -> P :=\n  fun (P Q : Prop) (A : P \\/ Q) =>\n    match A with\n    | or_introl H => H\n    end."
      },
      {
        "type": "misc",
        "content": "Fail Fixpoint infinite_loop {X : Type} (n : nat) {struct n} : X :=\n  infinite_loop n."
      },
      {
        "type": "misc",
        "content": "Fail Definition falso : False := infinite_loop 0."
      },
      {
        "type": "definition",
        "content": "Definition and_assoc : forall P Q R : Prop,\n    P /\\ (Q /\\ R) -> (P /\\ Q) /\\ R\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition or_distributes_over_and : forall P Q R : Prop,\n    P \\/ (Q /\\ R) <-> (P \\/ Q) /\\ (P \\/ R)\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition double_neg : forall P : Prop,\n    P -> ~~P\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition contradiction_implies_anything : forall P Q : Prop,\n    (P /\\ ~P) -> Q\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\/ Q) -> ~P /\\ ~Q\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition curry : forall P Q R : Prop,\n    ((P /\\ Q) -> R) -> (P -> (Q -> R))\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition uncurry : forall P Q R : Prop,\n    (P -> (Q -> R)) -> ((P /\\ Q) -> R)\n  . Admitted."
      },
      {
        "type": "definition",
        "content": "Definition propositional_extensionality : Prop :=\n  forall (P Q : Prop), (P <-> Q) -> P = Q."
      },
      {
        "type": "lemma",
        "content": "Lemma pe_implies_true_eq :\n  propositional_extensionality ->\n  forall (P : Prop), P -> True = P.\nProof.  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition proof_irrelevance : Prop :=\n  forall (P : Prop) (pf1 pf2 : P), pf1 = pf2."
      }
    ],
    "source_file": "ProofObjects.v"
  },
  {
    "name": "next_nat_partial_function",
    "statement": "Theorem next_nat_partial_function :\n  partial_function next_nat.",
    "proof": "Proof.unfold partial_function.\n  intros x y1 y2 H1 H2.\n  inversion H1. inversion H2.\n  reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_not_a_partial_function",
    "statement": "Theorem le_not_a_partial_function :\n  ~ (partial_function le).",
    "proof": "Proof.unfold not. unfold partial_function. intros Hc.\n  assert (0 = 1) as Nonsense. {\n    apply Hc with (x := 0).\n    - apply le_n.\n    - apply le_S. apply le_n. }\n  discriminate Nonsense.   Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "total_relation_not_partial_function",
    "statement": "Theorem total_relation_not_partial_function :\n  ~ (partial_function total_relation).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "empty_relation_partial_function",
    "statement": "Theorem empty_relation_partial_function :\n  partial_function empty_relation.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_reflexive",
    "statement": "Theorem le_reflexive :\n  reflexive le.",
    "proof": "Proof.unfold reflexive. intros n. apply le_n.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_trans",
    "statement": "Theorem le_trans :\n  transitive le.",
    "proof": "Proof.intros n m o Hnm Hmo.\n  induction Hmo.\n  -  apply Hnm.\n  -  apply le_S. apply IHHmo.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "lt_trans",
    "statement": "Theorem lt_trans:\n  transitive lt.",
    "proof": "Proof.unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  apply le_S in Hnm.\n  apply le_trans with (a := (S n)) (b := (S m)) (c := o).\n  apply Hnm.\n  apply Hmo. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "lt_trans'",
    "statement": "Theorem lt_trans' :\n  transitive lt.",
    "proof": "Proof.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "lt_trans''",
    "statement": "Theorem lt_trans'' :\n  transitive lt.",
    "proof": "Proof.unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction o as [| o'].\n   Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_Sn_le",
    "statement": "Theorem le_Sn_le : forall n m, S n <= m -> n <= m.",
    "proof": "Proof.intros n m H. apply le_trans with (S n).\n  - apply le_S. apply le_n.\n  - apply H.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_S_n",
    "statement": "Theorem le_S_n : forall n m,\n  (S n <= S m) -> (n <= m).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_Sn_n",
    "statement": "Theorem le_Sn_n : forall n,\n  ~ (S n <= n).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_not_symmetric",
    "statement": "Theorem le_not_symmetric :\n  ~ (symmetric le).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      },
      {
        "type": "definition",
        "content": "Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a)."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_antisymmetric",
    "statement": "Theorem le_antisymmetric :\n  antisymmetric le.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      },
      {
        "type": "definition",
        "content": "Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a)."
      },
      {
        "type": "definition",
        "content": "Definition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_step",
    "statement": "Theorem le_step : forall n m p,\n  n < m ->\n  m <= S p ->\n  n <= p.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      },
      {
        "type": "definition",
        "content": "Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a)."
      },
      {
        "type": "definition",
        "content": "Definition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "le_order",
    "statement": "Theorem le_order :\n  order le.",
    "proof": "Proof.unfold order. split.\n    -  apply le_reflexive.\n    - split.\n      +  apply le_antisymmetric.\n      +  apply le_trans.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      },
      {
        "type": "definition",
        "content": "Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a)."
      },
      {
        "type": "definition",
        "content": "Definition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b."
      },
      {
        "type": "definition",
        "content": "Definition equivalence {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (symmetric R) /\\ (transitive R)."
      },
      {
        "type": "definition",
        "content": "Definition order {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (antisymmetric R) /\\ (transitive R)."
      },
      {
        "type": "definition",
        "content": "Definition preorder {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (transitive R)."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "next_nat_closure_is_le",
    "statement": "Theorem next_nat_closure_is_le : forall n m,\n  (n <= m) <-> ((clos_refl_trans next_nat) n m).",
    "proof": "Proof.intros n m. split.\n  -\n    intro H. induction H.\n    +  apply rt_refl.\n    +\n      apply rt_trans with m. apply IHle. apply rt_step.\n      apply nn.\n  -\n    intro H. induction H.\n    +  inversion H. apply le_S. apply le_n.\n    +  apply le_n.\n    +\n      apply le_trans with y.\n      apply IHclos_refl_trans1.\n      apply IHclos_refl_trans2. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      },
      {
        "type": "definition",
        "content": "Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a)."
      },
      {
        "type": "definition",
        "content": "Definition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b."
      },
      {
        "type": "definition",
        "content": "Definition equivalence {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (symmetric R) /\\ (transitive R)."
      },
      {
        "type": "definition",
        "content": "Definition order {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (antisymmetric R) /\\ (transitive R)."
      },
      {
        "type": "definition",
        "content": "Definition preorder {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (transitive R)."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "rtc_rsc_coincide",
    "statement": "Theorem rtc_rsc_coincide :\n  forall (X:Type) (R: relation X) (x y : X),\n    clos_refl_trans R x y <-> clos_refl_trans_1n R x y.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export IndProp."
      },
      {
        "type": "definition",
        "content": "Definition relation (X: Type) := X -> X -> Prop."
      },
      {
        "type": "misc",
        "content": "Print le."
      },
      {
        "type": "check",
        "content": "Check le : nat -> nat -> Prop."
      },
      {
        "type": "check",
        "content": "Check le : relation nat."
      },
      {
        "type": "definition",
        "content": "Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2."
      },
      {
        "type": "inductive",
        "content": "Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)."
      },
      {
        "type": "check",
        "content": "Check next_nat : relation nat."
      },
      {
        "type": "inductive",
        "content": "Inductive total_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "inductive",
        "content": "Inductive empty_relation : nat -> nat -> Prop :="
      },
      {
        "type": "misc",
        "content": "."
      },
      {
        "type": "definition",
        "content": "Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a."
      },
      {
        "type": "definition",
        "content": "Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)."
      },
      {
        "type": "misc",
        "content": "unfold lt. unfold transitive.\n  intros n m o Hnm Hmo.\n  induction Hmo as [| m' Hm'o].\n     Admitted."
      },
      {
        "type": "definition",
        "content": "Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a)."
      },
      {
        "type": "definition",
        "content": "Definition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b."
      },
      {
        "type": "definition",
        "content": "Definition equivalence {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (symmetric R) /\\ (transitive R)."
      },
      {
        "type": "definition",
        "content": "Definition order {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (antisymmetric R) /\\ (transitive R)."
      },
      {
        "type": "definition",
        "content": "Definition preorder {X:Type} (R: relation X) :=\n  (reflexive R) /\\ (transitive R)."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z."
      },
      {
        "type": "inductive",
        "content": "Inductive clos_refl_trans_1n {A : Type}\n                             (R : relation A) (x : A)\n                             : A -> Prop :=\n  | rt1n_refl : clos_refl_trans_1n R x x\n  | rt1n_trans (y z : A)\n      (Hxy : R x y) (Hrest : clos_refl_trans_1n R y z) :\n      clos_refl_trans_1n R x z."
      },
      {
        "type": "lemma",
        "content": "Lemma rsc_R : forall (X:Type) (R:relation X) (x y : X),\n  R x y -> clos_refl_trans_1n R x y.\nProof.\n  intros X R x y H.\n  apply rt1n_trans with y. apply H. apply rt1n_refl.   Qed."
      },
      {
        "type": "lemma",
        "content": "Lemma rsc_trans :\n  forall (X:Type) (R: relation X) (x y z : X),\n      clos_refl_trans_1n R x y  ->\n      clos_refl_trans_1n R y z ->\n      clos_refl_trans_1n R x z.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Rel.v"
  },
  {
    "name": "silly1",
    "statement": "Theorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.",
    "proof": "Proof.intros n m eq.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "silly2",
    "statement": "Theorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].",
    "proof": "Proof.intros n m o p eq1 eq2.\n  apply eq2. apply eq1.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "silly2a",
    "statement": "Theorem silly2a : forall (n m : nat),\n  (n,n) = (m,m)  ->\n  (forall (q r : nat), (q,q) = (r,r) -> [q] = [r]) ->\n  [n] = [m].",
    "proof": "Proof.intros n m eq1 eq2.\n  apply eq2. apply eq1.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "silly_ex",
    "statement": "Theorem silly_ex : forall p,\n  (forall n, even n = true -> even (S n) = false) ->\n  (forall n, even n = false -> odd n = true) ->\n  even p = true ->\n  odd (S p) = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "silly3",
    "statement": "Theorem silly3 : forall (n m : nat),\n  n = m ->\n  m = n.",
    "proof": "Proof.intros n m H.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "rev_exercise1",
    "statement": "Theorem rev_exercise1 : forall (l l' : list nat),\n  l = rev l' ->\n  l' = rev l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "trans_eq",
    "statement": "Theorem trans_eq : forall (X:Type) (n m o : X),\n  n = m -> m = o -> n = o.",
    "proof": "Proof.intros X n m o eq1 eq2. rewrite -> eq1. rewrite -> eq2.\n  reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "S_injective",
    "statement": "Theorem S_injective : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "proof": "Proof.intros n m H1.\n  assert (H2: n = pred (S n)). { reflexivity. }\n  rewrite H2. rewrite H1. simpl. reflexivity.\nQed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "S_injective'",
    "statement": "Theorem S_injective' : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "proof": "Proof.intros n m H.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "injection_ex1",
    "statement": "Theorem injection_ex1 : forall (n m o : nat),\n  [n;m] = [o;o] ->\n  n = m.",
    "proof": "Proof.intros n m o H.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "discriminate_ex1",
    "statement": "Theorem discriminate_ex1 : forall (n m : nat),\n  false = true ->\n  n = m.",
    "proof": "Proof.intros n m contra. discriminate contra. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "discriminate_ex2",
    "statement": "Theorem discriminate_ex2 : forall (n : nat),\n  S n = O ->\n  2 + 2 = 5.",
    "proof": "Proof.intros n contra. discriminate contra. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "eqb_0_l",
    "statement": "Theorem eqb_0_l : forall n,\n   0 =? n = true -> n = 0.",
    "proof": "Proof.intros n.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "f_equal",
    "statement": "Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),\n  x = y -> f x = f y.",
    "proof": "Proof.intros A B f x y eq. rewrite eq.  reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "eq_implies_succ_equal",
    "statement": "Theorem eq_implies_succ_equal : forall (n m : nat),\n  n = m -> S n = S m.",
    "proof": "Proof.intros n m H. apply f_equal. apply H. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "eq_implies_succ_equal'",
    "statement": "Theorem eq_implies_succ_equal' : forall (n m : nat),\n  n = m -> S n = S m.",
    "proof": "Proof.intros n m H. f_equal. apply H. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "S_inj",
    "statement": "Theorem S_inj : forall (n m : nat) (b : bool),\n  ((S n) =? (S m)) = b  ->\n  (n =? m) = b.",
    "proof": "Proof.intros n m b H. simpl in H. apply H.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "silly4",
    "statement": "Theorem silly4 : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p.",
    "proof": "Proof.intros n m p q EQ H.\n  symmetry in H. apply EQ in H. symmetry in H.\n  apply H.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "specialize_example",
    "statement": "Theorem specialize_example: forall n,\n     (forall m, m*n = 0)\n  -> n = 0.",
    "proof": "Proof.intros n H.\n  specialize H with (m := 1).\n  simpl in H.\n  rewrite add_comm in H.\n  simpl in H.\n  apply H. Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "double_injective_FAILED",
    "statement": "Theorem double_injective_FAILED : forall n m,\n  double n = double m ->\n  n = m.",
    "proof": "Proof.intros n m. induction n as [| n' IHn'].\n  -  simpl. intros eq. destruct m as [| m'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros eq. destruct m as [| m'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "double_injective",
    "statement": "Theorem double_injective : forall n m,\n  double n = double m ->\n  n = m.",
    "proof": "Proof.intros n. induction n as [| n' IHn'].\n  -  simpl. intros m eq. destruct m as [| m'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "eqb_true",
    "statement": "Theorem eqb_true : forall n m,\n  n =? m = true -> n = m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "plus_n_n_injective",
    "statement": "Theorem plus_n_n_injective : forall n m,\n  n + n = m + m ->\n  n = m.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "double_injective_take2_FAILED",
    "statement": "Theorem double_injective_take2_FAILED : forall n m,\n  double n = double m ->\n  n = m.",
    "proof": "Proof.intros n m. induction m as [| m' IHm'].\n  -  simpl. intros eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "double_injective_take2",
    "statement": "Theorem double_injective_take2 : forall n m,\n  double n = double m ->\n  n = m.",
    "proof": "Proof.intros n m.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "nth_error_after_last",
    "statement": "Theorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X),\n  length l = n ->\n  nth_error l n = None.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "sillyfun_false",
    "statement": "Theorem sillyfun_false : forall (n : nat),\n  sillyfun n = false.",
    "proof": "Proof.intros n. unfold sillyfun.\n  destruct (n =? 3) eqn:E1.\n    -  reflexivity.\n    -  destruct (n =? 5) eqn:E2.\n      +  reflexivity.\n      +  reflexivity.  Qed.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "combine_split",
    "statement": "Theorem combine_split : forall X Y (l : list (X * Y)) l1 l2,\n  split l = (l1, l2) ->\n  combine l1 l2 = l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "sillyfun1_odd_FAILED",
    "statement": "Theorem sillyfun1_odd_FAILED : forall (n : nat),\n  sillyfun1 n = true ->\n  odd n = true.",
    "proof": "Proof.intros n eq. unfold sillyfun1 in eq.\n  destruct (n =? 3).",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "sillyfun1_odd",
    "statement": "Theorem sillyfun1_odd : forall (n : nat),\n  sillyfun1 n = true ->\n  odd n = true.",
    "proof": "Proof.intros n eq. unfold sillyfun1 in eq.\n  destruct (n =? 3) eqn:Heqe3.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      },
      {
        "type": "misc",
        "content": "Abort."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "bool_fn_applied_thrice",
    "statement": "Theorem bool_fn_applied_thrice :\n  forall (f : bool -> bool) (b : bool),\n  f (f (f b)) = f b.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-  apply eqb_true in Heqe3.\n      rewrite -> Heqe3. reflexivity.\n    -"
      },
      {
        "type": "misc",
        "content": "destruct (n =? 5) eqn:Heqe5.\n        +\n          apply eqb_true in Heqe5.\n          rewrite -> Heqe5. reflexivity.\n        +  discriminate eq.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "eqb_sym",
    "statement": "Theorem eqb_sym : forall (n m : nat),\n  (n =? m) = (m =? n).",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-  apply eqb_true in Heqe3.\n      rewrite -> Heqe3. reflexivity.\n    -"
      },
      {
        "type": "misc",
        "content": "destruct (n =? 5) eqn:Heqe5.\n        +\n          apply eqb_true in Heqe5.\n          rewrite -> Heqe5. reflexivity.\n        +  discriminate eq.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "eqb_trans",
    "statement": "Theorem eqb_trans : forall n m p,\n  n =? m = true ->\n  m =? p = true ->\n  n =? p = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-  apply eqb_true in Heqe3.\n      rewrite -> Heqe3. reflexivity.\n    -"
      },
      {
        "type": "misc",
        "content": "destruct (n =? 5) eqn:Heqe5.\n        +\n          apply eqb_true in Heqe5.\n          rewrite -> Heqe5. reflexivity.\n        +  discriminate eq.  Qed."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "split_combine",
    "statement": "Theorem split_combine : split_combine_statement.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-  apply eqb_true in Heqe3.\n      rewrite -> Heqe3. reflexivity.\n    -"
      },
      {
        "type": "misc",
        "content": "destruct (n =? 5) eqn:Heqe5.\n        +\n          apply eqb_true in Heqe5.\n          rewrite -> Heqe5. reflexivity.\n        +  discriminate eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition split_combine_statement : Prop"
      },
      {
        "type": "misc",
        "content": ". Admitted."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "filter_exercise",
    "statement": "Theorem filter_exercise : forall (X : Type) (test : X -> bool)\n                                 (x : X) (l lf : list X),\n  filter test l = x :: lf ->\n  test x = true.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-  apply eqb_true in Heqe3.\n      rewrite -> Heqe3. reflexivity.\n    -"
      },
      {
        "type": "misc",
        "content": "destruct (n =? 5) eqn:Heqe5.\n        +\n          apply eqb_true in Heqe5.\n          rewrite -> Heqe5. reflexivity.\n        +  discriminate eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition split_combine_statement : Prop"
      },
      {
        "type": "misc",
        "content": ". Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_split_combine : option (nat*string) := None."
      }
    ],
    "source_file": "Tactics.v"
  },
  {
    "name": "existsb_existsb'",
    "statement": "Theorem existsb_existsb' : forall (X : Type) (test : X -> bool) (l : list X),\n  existsb test l = existsb' test l.",
    "proof": "Proof.Admitted.",
    "dependencies": [
      {
        "type": "global_directive",
        "content": "Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\"."
      },
      {
        "type": "import",
        "content": "From LF Require Export Poly."
      },
      {
        "type": "misc",
        "content": "apply eq.  Qed."
      },
      {
        "type": "misc",
        "content": "Fail apply H."
      },
      {
        "type": "misc",
        "content": "symmetry. apply H.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2."
      },
      {
        "type": "misc",
        "content": "apply trans_eq with (m:=[c;d]).\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  transitivity [c;d].\n  apply eq1. apply eq2.   Qed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "injection H as Hnm. apply Hnm.\nQed."
      },
      {
        "type": "misc",
        "content": "injection H as H1 H2.\n  rewrite H1. rewrite H2. reflexivity.\nQed."
      },
      {
        "type": "example",
        "content": "Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.\nProof.\n   Admitted."
      },
      {
        "type": "example",
        "content": "Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.\nProof.\n   Admitted."
      },
      {
        "type": "misc",
        "content": "destruct n as [| n'] eqn:E.\n  -\n    intros H. reflexivity."
      },
      {
        "type": "misc",
        "content": "-\n    simpl."
      },
      {
        "type": "misc",
        "content": "intros H. discriminate H.\nQed."
      },
      {
        "type": "example",
        "content": "Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].\nProof.\n  intros a b c d e f eq1 eq2.\n  specialize trans_eq with (m:=[c;d]) as H.\n  apply H.\n  apply eq1.\n  apply eq2. Qed."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-"
      },
      {
        "type": "misc",
        "content": "intros m eq."
      },
      {
        "type": "misc",
        "content": "destruct m as [| m'] eqn:E.\n    +"
      },
      {
        "type": "misc",
        "content": "discriminate eq.\n    +\n      f_equal."
      },
      {
        "type": "misc",
        "content": "apply IHn'. simpl in eq. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_informal_proof : option (nat*string) := None."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "generalize dependent n."
      },
      {
        "type": "misc",
        "content": "induction m as [| m' IHm'].\n  -  simpl. intros n eq. destruct n as [| n'] eqn:E.\n    +  reflexivity.\n    +  discriminate eq.\n  -  intros n eq. destruct n as [| n'] eqn:E.\n    +  discriminate eq.\n    +  f_equal.\n      apply IHm'. injection eq as goal. apply goal. Qed."
      },
      {
        "type": "definition",
        "content": "Definition square n := n * n."
      },
      {
        "type": "lemma",
        "content": "Lemma square_mult : forall n m, square (n * m) = square n * square m.\nProof.\n  intros n m.\n  simpl."
      },
      {
        "type": "misc",
        "content": "unfold square."
      },
      {
        "type": "misc",
        "content": "rewrite mult_assoc.\n  assert (H : n * m * n = n * n * m).\n    { rewrite mul_comm. apply mult_assoc. }\n  rewrite H. rewrite mult_assoc. reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition foo (x: nat) := 5."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\n  reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  simpl.\nAbort."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  destruct m eqn:E.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed."
      },
      {
        "type": "misc",
        "content": "Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.\nProof.\n  intros m.\n  unfold bar."
      },
      {
        "type": "misc",
        "content": "destruct m eqn:E.\n  - reflexivity.\n  - reflexivity.\nQed."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end."
      },
      {
        "type": "definition",
        "content": "Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false."
      },
      {
        "type": "misc",
        "content": "Abort."
      },
      {
        "type": "misc",
        "content": "-  apply eqb_true in Heqe3.\n      rewrite -> Heqe3. reflexivity.\n    -"
      },
      {
        "type": "misc",
        "content": "destruct (n =? 5) eqn:Heqe5.\n        +\n          apply eqb_true in Heqe5.\n          rewrite -> Heqe5. reflexivity.\n        +  discriminate eq.  Qed."
      },
      {
        "type": "definition",
        "content": "Definition split_combine_statement : Prop"
      },
      {
        "type": "misc",
        "content": ". Admitted."
      },
      {
        "type": "definition",
        "content": "Definition manual_grade_for_split_combine : option (nat*string) := None."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_forallb_1 : forallb odd [1;3;5;7;9] = true.\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_forallb_2 : forallb negb [false;false] = true.\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_forallb_3 : forallb even [0;2;4;5] = false.\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_forallb_4 : forallb (eqb 5) [] = true.\nProof.  Admitted."
      },
      {
        "type": "fixpoint",
        "content": "Fixpoint existsb {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      },
      {
        "type": "example",
        "content": "Example test_existsb_1 : existsb (eqb 5) [0;2;3;6] = false.\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_existsb_2 : existsb (andb true) [true;true;false] = true.\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_existsb_3 : existsb odd [1;0;0;0;0;3] = true.\nProof.  Admitted."
      },
      {
        "type": "example",
        "content": "Example test_existsb_4 : existsb even [] = false.\nProof.  Admitted."
      },
      {
        "type": "definition",
        "content": "Definition existsb' {X : Type} (test : X -> bool) (l : list X) : bool\n  . Admitted."
      }
    ],
    "source_file": "Tactics.v"
  }
]