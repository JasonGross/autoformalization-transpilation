[
  {
    "Type":"Other",
    "Chunk":"(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-w\" \"-deprecated-native-compiler-option,-native-compiler-disabled\" \"-native-compiler\" \"ondemand\" \"-Q\" \".\" \"LF\" \"-top\" \"LF.Everything\") -*- *)",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n(* File reduced by coq-bug-minimizer from original input, then from 46 lines to 59 lines, then from 63 lines to 331 lines, then from 336 lines to 101 lines, then from 105 lines to 188 lines, then from 193 lines to 132 lines, then from 136 lines to 563 lines, then from 568 lines to 401 lines, then from 405 lines to 786 lines, then from 791 lines to 453 lines, then from 457 lines to 530 lines, then from 535 lines to 484 lines, then from 488 lines to 1010 lines, then from 1015 lines to 495 lines, then from 499 lines to 572 lines, then from 577 lines to 526 lines, then from 530 lines to 619 lines, then from 624 lines to 537 lines, then from 541 lines to 1052 lines, then from 1057 lines to 597 lines, then from 601 lines to 709 lines, then from 714 lines to 630 lines, then from 634 lines to 1065 lines, then from 1070 lines to 683 lines, then from 687 lines to 1215 lines, then from 1220 lines to 743 lines, then from 747 lines to 1016 lines, then from 1021 lines to 788 lines, then from 792 lines to 1318 lines, then from 1323 lines to 850 lines, then from 854 lines to 984 lines, then from 989 lines to 884 lines, then from 888 lines to 1870 lines, then from 1873 lines to 1212 lines, then from 1216 lines to 2177 lines, then from 2182 lines to 1609 lines, then from 1613 lines to 1976 lines, then from 1981 lines to 1658 lines, then from 1662 lines to 1745 lines, then from 1750 lines to 1689 lines, then from 1693 lines to 1804 lines, then from 1809 lines to 1721 lines, then from 1725 lines to 1814 lines, then from 1819 lines to 1752 lines, then from 1756 lines to 1903 lines, then from 1908 lines to 1795 lines, then from 1799 lines to 2279 lines, then from 2284 lines to 2210 lines, then from 2214 lines to 2624 lines, then from 2629 lines to 2554 lines, then from 2558 lines to 2631 lines, then from 2636 lines to 2585 lines, then from 2589 lines to 2628 lines, then from 2633 lines to 2596 lines, then from 2600 lines to 3129 lines, then from 3134 lines to 2659 lines, then from 2663 lines to 2745 lines, then from 2750 lines to 2690 lines, then from 2694 lines to 3452 lines, then from 3454 lines to 3213 lines, then from 3217 lines to 5320 lines, then from 5325 lines to 4248 lines, then from 4252 lines to 4642 lines, then from 4647 lines to 4473 lines, then from 4477 lines to 4756 lines, then from 4761 lines to 4516 lines, then from 4520 lines to 6372 lines, then from 6377 lines to 5956 lines, then from 5960 lines to 8709 lines, then from 8712 lines to 7346 lines, then from 7350 lines to 9159 lines, then from 9163 lines to 8301 lines, then from 8305 lines to 9559 lines, then from 9564 lines to 8866 lines, then from 8870 lines to 10105 lines, then from 10110 lines to 9480 lines, then from 9484 lines to 10700 lines, then from 10705 lines to 10072 lines, then from 10076 lines to 10883 lines, then from 10888 lines to 10328 lines, then from 10332 lines to 12374 lines, then from 12379 lines to 11166 lines, then from 11171 lines to 11168 lines *)",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n(* coqc version 9.1+alpha compiled with OCaml 4.14.2\n   coqtop version 9.1+alpha\n   Expected coqc runtime on this file: 2.113 sec *)",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nRequire Stdlib.Arith.Arith.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.Lists.List.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Corelib.Init.Nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Corelib.Setoids.Setoid.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.Strings.Ascii.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.micromega.Lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.setoid_ring.Ring.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.Bool.Bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.Logic.FunctionalExtensionality.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.Arith.EqNat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.extraction.Extraction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.Arith.PeanoNat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Corelib.extraction.ExtrOcamlBasic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nRequire Stdlib.extraction.ExtrOcamlString.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export LF_DOT_Basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday.",
    "Statement":"Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday",
    "Name":"day",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday.",
    "Statement":"Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday",
    "Name":"day",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end.",
    "Statement":"Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end",
    "Name":"next_working_day",
    "Dependencies":[
      "friday",
      "thursday",
      "wednesday",
      "tuesday",
      "monday",
      "day"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (next_working_day friday).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (next_working_day (next_working_day saturday)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday.",
    "Statement":"Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday",
    "Name":"test_next_working_day",
    "Dependencies":[
      "next_working_day",
      "saturday",
      "tuesday",
      "day"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bool : Type :=\n  | true\n  | false.",
    "Statement":"Inductive bool : Type :=\n  | true\n  | false",
    "Name":"bool",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end.",
    "Statement":"Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end",
    "Name":"negb",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end.",
    "Statement":"Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end",
    "Name":"andb",
    "Dependencies":[
      "false",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end.",
    "Statement":"Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end",
    "Name":"orb",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_orb1:  (orb true  false) = true.",
    "Statement":"Example test_orb1:  (orb true  false) = true",
    "Name":"test_orb1",
    "Dependencies":[
      "orb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_orb2:  (orb false false) = false.",
    "Statement":"Example test_orb2:  (orb false false) = false",
    "Name":"test_orb2",
    "Dependencies":[
      "orb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_orb3:  (orb false true)  = true.",
    "Statement":"Example test_orb3:  (orb false true)  = true",
    "Name":"test_orb3",
    "Dependencies":[
      "orb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_orb4:  (orb true  true)  = true.",
    "Statement":"Example test_orb4:  (orb true  true)  = true",
    "Name":"test_orb4",
    "Dependencies":[
      "orb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x && y\" := (andb x y).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x || y\" := (orb x y).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_orb5:  false || false || true = true.",
    "Statement":"Example test_orb5:  false || false || true = true",
    "Name":"test_orb5",
    "Dependencies":[
      "orb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition negb' (b:bool) : bool :=\n  if b then false\n  else true.",
    "Statement":"Definition negb' (b:bool) : bool :=\n  if b then false\n  else true",
    "Name":"negb'",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false.",
    "Statement":"Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false",
    "Name":"andb'",
    "Dependencies":[
      "false",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2.",
    "Statement":"Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2",
    "Name":"orb'",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bw : Type :=\n  | bw_black\n  | bw_white.",
    "Statement":"Inductive bw : Type :=\n  | bw_black\n  | bw_white",
    "Name":"bw",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black.",
    "Statement":"Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black",
    "Name":"invert",
    "Dependencies":[
      "bw_white",
      "bw_black",
      "bw"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (invert bw_black).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (invert bw_white).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition nandb (b1:bool) (b2:bool) : bool\n  .",
    "Statement":"Definition nandb (b1:bool) (b2:bool) : bool",
    "Name":"nandb",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nandb1:               (nandb true false) = true.",
    "Statement":"Example test_nandb1:               (nandb true false) = true",
    "Name":"test_nandb1",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nandb2:               (nandb false false) = true.",
    "Statement":"Example test_nandb2:               (nandb false false) = true",
    "Name":"test_nandb2",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nandb3:               (nandb false true) = true.",
    "Statement":"Example test_nandb3:               (nandb false true) = true",
    "Name":"test_nandb3",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nandb4:               (nandb true true) = false.",
    "Statement":"Example test_nandb4:               (nandb true true) = false",
    "Name":"test_nandb4",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  .",
    "Statement":"Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool",
    "Name":"andb3",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_andb31:                 (andb3 true true true) = true.",
    "Statement":"Example test_andb31:                 (andb3 true true true) = true",
    "Name":"test_andb31",
    "Dependencies":[
      "andb3",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_andb32:                 (andb3 false true true) = false.",
    "Statement":"Example test_andb32:                 (andb3 false true true) = false",
    "Name":"test_andb32",
    "Dependencies":[
      "andb3",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_andb33:                 (andb3 true false true) = false.",
    "Statement":"Example test_andb33:                 (andb3 true false true) = false",
    "Name":"test_andb33",
    "Dependencies":[
      "andb3",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_andb34:                 (andb3 true true false) = false.",
    "Statement":"Example test_andb34:                 (andb3 true true false) = false",
    "Name":"test_andb34",
    "Dependencies":[
      "andb3",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck true.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck true\n  : bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck (negb true)\n  : bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck negb\n  : bool -> bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Statement":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue",
    "Name":"rgb",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Statement":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue",
    "Name":"rgb",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb).",
    "Statement":"Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb)",
    "Name":"color",
    "Dependencies":[
      "rgb"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end.",
    "Statement":"Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end",
    "Name":"monochrome",
    "Dependencies":[
      "color",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end.",
    "Statement":"Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end",
    "Name":"isred",
    "Dependencies":[
      "color",
      "rgb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export Playground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n  Definition foo : rgb := blue.",
    "Statement":"Definition foo : rgb := blue",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n  Definition foo : rgb := blue.",
    "Statement":"Definition foo : rgb := blue",
    "Name":"foo",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n  Definition foo : rgb := blue.",
    "Statement":"Definition foo : rgb := blue",
    "Name":"foo",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n  Definition foo : rgb := blue.",
    "Statement":"Definition foo : rgb := blue",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nEnd Playground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo : bool := true.",
    "Statement":"Definition foo : bool := true",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo : bool := true.",
    "Statement":"Definition foo : bool := true",
    "Name":"foo",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo : bool := true.",
    "Statement":"Definition foo : bool := true",
    "Name":"foo",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo : bool := true.",
    "Statement":"Definition foo : bool := true",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck Playground.foo : rgb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck foo : bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck foo : bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck foo : bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck foo : bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export TuplePlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bit : Type :=\n  | B1\n  | B0.",
    "Statement":"Inductive bit : Type :=\n  | B1\n  | B0",
    "Name":"bit",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit).",
    "Statement":"Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit)",
    "Name":"nybble",
    "Dependencies":[
      "bit"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (bits B1 B0 B1 B0)\n  : nybble.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end.",
    "Statement":"Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end",
    "Name":"all_zero",
    "Dependencies":[
      "nybble",
      "bit",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (all_zero (bits B1 B0 B1 B0)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (all_zero (bits B0 B0 B0 B0)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd TuplePlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule NatPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive nat : Type :=\n  | O\n  | S (n : nat).",
    "Statement":"Inductive nat : Type :=\n  | O\n  | S (n : nat)",
    "Name":"nat",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat).",
    "Statement":"Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat)",
    "Name":"otherNat",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end.",
    "Statement":"Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end",
    "Name":"pred",
    "Dependencies":[
      "O",
      "nat"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd NatPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (S (S (S (S O)))).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end.",
    "Statement":"Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end",
    "Name":"minustwo",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (minustwo 4).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck S        : nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck pred     : nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "O",
      "nat"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck minustwo : nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end.",
    "Statement":"Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end",
    "Name":"even",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition odd (n:nat) : bool :=\n  negb (even n).",
    "Statement":"Definition odd (n:nat) : bool :=\n  negb (even n)",
    "Name":"odd",
    "Dependencies":[
      "even",
      "negb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_odd1:    odd 1 = true.",
    "Statement":"Example test_odd1:    odd 1 = true",
    "Name":"test_odd1",
    "Dependencies":[
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_odd2:    odd 4 = false.",
    "Statement":"Example test_odd2:    odd 4 = false",
    "Name":"test_odd2",
    "Dependencies":[
      "odd",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule NatPlayground2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end.",
    "Statement":"Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end",
    "Name":"plus",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end.",
    "Statement":"Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end",
    "Name":"plus",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (plus 3 2).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end.",
    "Statement":"Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end",
    "Name":"mult",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end.",
    "Statement":"Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end",
    "Name":"mult",
    "Dependencies":[
      "plus"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_mult1: (mult 3 3) = 9.",
    "Statement":"Example test_mult1: (mult 3 3) = 9",
    "Name":"test_mult1",
    "Dependencies":[
      "mult"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end.",
    "Statement":"Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end",
    "Name":"minus",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd NatPlayground2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end.",
    "Statement":"Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end",
    "Name":"exp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end.",
    "Statement":"Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end",
    "Name":"exp",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint factorial (n:nat) : nat\n  .",
    "Statement":"Fixpoint factorial (n:nat) : nat",
    "Name":"factorial",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_factorial1:          (factorial 3) = 6.",
    "Statement":"Example test_factorial1:          (factorial 3) = 6",
    "Name":"test_factorial1",
    "Dependencies":[
      "factorial"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_factorial2:          (factorial 5) = (mult 10 12).",
    "Statement":"Example test_factorial2:          (factorial 5) = (mult 10 12)",
    "Name":"test_factorial2",
    "Dependencies":[
      "factorial"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ((0 + 1) + 1) : nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end.",
    "Statement":"Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end",
    "Name":"eqb",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end.",
    "Statement":"Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end",
    "Name":"leb",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_leb1:                leb 2 2 = true.",
    "Statement":"Example test_leb1:                leb 2 2 = true",
    "Name":"test_leb1",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_leb2:                leb 2 4 = true.",
    "Statement":"Example test_leb2:                leb 2 4 = true",
    "Name":"test_leb2",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_leb3:                leb 4 2 = false.",
    "Statement":"Example test_leb3:                leb 4 2 = false",
    "Name":"test_leb3",
    "Dependencies":[
      "leb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x =? y\" := (eqb x y) (at level 70) : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x <=? y\" := (leb x y) (at level 70) : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_leb3': (4 <=? 2) = false.",
    "Statement":"Example test_leb3': (4 <=? 2) = false",
    "Name":"test_leb3'",
    "Dependencies":[
      "leb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ltb (n m : nat) : bool\n  .",
    "Statement":"Definition ltb (n m : nat) : bool",
    "Name":"ltb",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x <? y\" := (ltb x y) (at level 70) : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_ltb1:             (ltb 2 2) = false.",
    "Statement":"Example test_ltb1:             (ltb 2 2) = false",
    "Name":"test_ltb1",
    "Dependencies":[
      "ltb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_ltb2:             (ltb 2 4) = true.",
    "Statement":"Example test_ltb2:             (ltb 2 4) = true",
    "Name":"test_ltb2",
    "Dependencies":[
      "ltb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_ltb3:             (ltb 4 2) = false.",
    "Statement":"Example test_ltb3:             (ltb 4 2) = false",
    "Name":"test_ltb3",
    "Dependencies":[
      "ltb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_O_n : forall n : nat, 0 + n = n.",
    "Statement":"Theorem plus_O_n : forall n : nat, 0 + n = n",
    "Name":"plus_O_n",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_O_n' : forall n : nat, 0 + n = n.",
    "Statement":"Theorem plus_O_n' : forall n : nat, 0 + n = n",
    "Name":"plus_O_n'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_O_n'' : forall n : nat, 0 + n = n.",
    "Statement":"Theorem plus_O_n'' : forall n : nat, 0 + n = n",
    "Name":"plus_O_n''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_l : forall n:nat, 1 + n = S n.",
    "Statement":"Theorem plus_1_l : forall n:nat, 1 + n = S n",
    "Name":"plus_1_l",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_0_l : forall n:nat, 0 * n = 0.",
    "Statement":"Theorem mult_0_l : forall n:nat, 0 * n = 0",
    "Name":"mult_0_l",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m.",
    "Statement":"Theorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m",
    "Name":"plus_id_example",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  rewrite -> H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_id_exercise : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o.",
    "Statement":"Theorem plus_id_exercise : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o",
    "Name":"plus_id_exercise",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck mult_n_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck mult_n_Sm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_n_0_m_0 : forall p q : nat,\n  (p * 0) + (q * 0) = 0.",
    "Statement":"Theorem mult_n_0_m_0 : forall p q : nat,\n  (p * 0) + (q * 0) = 0",
    "Name":"mult_n_0_m_0",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros p q.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite <- mult_n_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite <- mult_n_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_n_1 : forall p : nat,\n  p * 1 = p.",
    "Statement":"Theorem mult_n_1 : forall p : nat,\n  p * 1 = p",
    "Name":"mult_n_1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct n as [| n'] eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Statement":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b",
    "Name":"negb_involutive",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Statement":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b",
    "Name":"negb_involutive",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative : forall b c, andb b c = andb c b",
    "Name":"andb_commutative",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative : forall b c, andb b c = andb c b",
    "Name":"andb_commutative",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b eqn:Eb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative' : forall b c, andb b c = andb c b",
    "Name":"andb_commutative'",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative' : forall b c, andb b c = andb c b",
    "Name":"andb_commutative'",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b eqn:Eb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n }",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n }",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Statement":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c",
    "Name":"andb3_exchange",
    "Dependencies":[
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Statement":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c",
    "Name":"andb3_exchange",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b c d.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b eqn:Eb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct d eqn:Ed.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Statement":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true",
    "Name":"andb_true_elim2",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Statement":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true",
    "Name":"andb_true_elim2",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0' : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0' : forall n : nat,\n  (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0'",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0' : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0' : forall n : nat,\n  (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0'",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros [|n].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative'' :\n  forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative'' :\n  forall b c, andb b c = andb c b",
    "Name":"andb_commutative''",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros [] [].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem zero_nbeq_plus_1 : forall n : nat,\n  0 =? (n + 1) = false.",
    "Statement":"Theorem zero_nbeq_plus_1 : forall n : nat,\n  0 =? (n + 1) = false",
    "Name":"zero_nbeq_plus_1",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end.",
    "Statement":"Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end",
    "Name":"plus'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem identity_fn_applied_twice :\n  forall (f : bool -> bool),\n  (forall (x : bool), f x = x) ->\n  forall (b : bool), f (f b) = b.",
    "Statement":"Theorem identity_fn_applied_twice :\n  forall (f : bool -> bool),\n  (forall (x : bool), f x = x) ->\n  forall (b : bool), f (f b) = b",
    "Name":"identity_fn_applied_twice",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None",
    "Name":"manual_grade_for_negation_fn_applied_twice",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Statement":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c",
    "Name":"andb_eq_orb",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Statement":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c",
    "Name":"andb_eq_orb",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export LateDays.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive letter : Type :=\n  | A | B | C | D | F.",
    "Statement":"Inductive letter : Type :=\n  | A | B | C | D | F",
    "Name":"letter",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive modifier : Type :=\n  | Plus | Natural | Minus.",
    "Statement":"Inductive modifier : Type :=\n  | Plus | Natural | Minus",
    "Name":"modifier",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive grade : Type :=\n  Grade (l:letter) (m:modifier).",
    "Statement":"Inductive grade : Type :=\n  Grade (l:letter) (m:modifier)",
    "Name":"grade",
    "Dependencies":[
      "modifier",
      "letter"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt.",
    "Statement":"Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt",
    "Name":"comparison",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end.",
    "Statement":"Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end",
    "Name":"letter_comparison",
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute letter_comparison B A.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute letter_comparison D D.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute letter_comparison B F.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem letter_comparison_Eq :\n  forall l, letter_comparison l l = Eq.",
    "Statement":"Theorem letter_comparison_Eq :\n  forall l, letter_comparison l l = Eq",
    "Name":"letter_comparison_Eq",
    "Dependencies":[
      "letter_comparison",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end.",
    "Statement":"Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end",
    "Name":"modifier_comparison",
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "modifier"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition grade_comparison (g1 g2 : grade) : comparison\n  .",
    "Statement":"Definition grade_comparison (g1 g2 : grade) : comparison",
    "Name":"grade_comparison",
    "Dependencies":[
      "comparison",
      "grade"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.",
    "Statement":"Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt",
    "Name":"test_grade_comparison1",
    "Dependencies":[
      "grade_comparison",
      "Gt",
      "comparison",
      "Grade",
      "Minus",
      "Plus",
      "B",
      "A"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.",
    "Statement":"Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt",
    "Name":"test_grade_comparison2",
    "Dependencies":[
      "grade_comparison",
      "Lt",
      "comparison",
      "Grade",
      "Minus",
      "Plus",
      "A"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.",
    "Statement":"Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq",
    "Name":"test_grade_comparison3",
    "Dependencies":[
      "grade_comparison",
      "Eq",
      "comparison",
      "Grade",
      "Plus",
      "F"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.",
    "Statement":"Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt",
    "Name":"test_grade_comparison4",
    "Dependencies":[
      "grade_comparison",
      "Gt",
      "comparison",
      "Grade",
      "Minus",
      "Plus",
      "C",
      "B"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end.",
    "Statement":"Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end",
    "Name":"lower_letter",
    "Dependencies":[
      "F",
      "D",
      "C",
      "B",
      "letter"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lower_letter_F_is_F:\n  lower_letter F = F.",
    "Statement":"Theorem lower_letter_F_is_F:\n  lower_letter F = F",
    "Name":"lower_letter_F_is_F",
    "Dependencies":[
      "lower_letter",
      "F",
      "letter"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lower_letter_lowers:\n  forall (l : letter),\n    letter_comparison F l = Lt ->\n    letter_comparison (lower_letter l) l = Lt.",
    "Statement":"Theorem lower_letter_lowers:\n  forall (l : letter),\n    letter_comparison F l = Lt ->\n    letter_comparison (lower_letter l) l = Lt",
    "Name":"lower_letter_lowers",
    "Dependencies":[
      "lower_letter",
      "letter_comparison",
      "Lt",
      "comparison",
      "F",
      "letter"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition lower_grade (g : grade) : grade\n  .",
    "Statement":"Definition lower_grade (g : grade) : grade",
    "Name":"lower_grade",
    "Dependencies":[
      "grade"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural).",
    "Statement":"Example lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural)",
    "Name":"lower_grade_A_Plus",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Natural",
      "Plus",
      "A"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus).",
    "Statement":"Example lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus)",
    "Name":"lower_grade_A_Natural",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Natural",
      "A"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus).",
    "Statement":"Example lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus)",
    "Name":"lower_grade_A_Minus",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Plus",
      "B",
      "A"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural).",
    "Statement":"Example lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural)",
    "Name":"lower_grade_B_Plus",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Natural",
      "Plus",
      "B"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus).",
    "Statement":"Example lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus)",
    "Name":"lower_grade_F_Natural",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Natural",
      "F"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).",
    "Statement":"Example lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural)",
    "Name":"lower_grade_twice",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Natural",
      "C",
      "B"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).",
    "Statement":"Example lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus)",
    "Name":"lower_grade_thrice",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "C",
      "B"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lower_grade_F_Minus : lower_grade (Grade F Minus) = (Grade F Minus).",
    "Statement":"Theorem lower_grade_F_Minus : lower_grade (Grade F Minus) = (Grade F Minus)",
    "Name":"lower_grade_F_Minus",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "F"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lower_grade_lowers :\n  forall (g : grade),\n    grade_comparison (Grade F Minus) g = Lt ->\n    grade_comparison (lower_grade g) g = Lt.",
    "Statement":"Theorem lower_grade_lowers :\n  forall (g : grade),\n    grade_comparison (Grade F Minus) g = Lt ->\n    grade_comparison (lower_grade g) g = Lt",
    "Name":"lower_grade_lowers",
    "Dependencies":[
      "lower_grade",
      "grade_comparison",
      "Lt",
      "comparison",
      "Grade",
      "grade",
      "Minus",
      "F"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition apply_late_policy (late_days : nat) (g : grade) : grade :=\n  if late_days <? 9 then g\n  else if late_days <? 17 then lower_grade g\n  else if late_days <? 21 then lower_grade (lower_grade g)\n  else lower_grade (lower_grade (lower_grade g)).",
    "Statement":"Definition apply_late_policy (late_days : nat) (g : grade) : grade :=\n  if late_days <? 9 then g\n  else if late_days <? 17 then lower_grade g\n  else if late_days <? 21 then lower_grade (lower_grade g)\n  else lower_grade (lower_grade (lower_grade g))",
    "Name":"apply_late_policy",
    "Dependencies":[
      "lower_grade",
      "grade",
      "ltb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem apply_late_policy_unfold :\n  forall (late_days : nat) (g : grade),\n    (apply_late_policy late_days g)\n    =\n    (if late_days <? 9 then g  else\n       if late_days <? 17 then lower_grade g\n       else if late_days <? 21 then lower_grade (lower_grade g)\n            else lower_grade (lower_grade (lower_grade g))).",
    "Statement":"Theorem apply_late_policy_unfold :\n  forall (late_days : nat) (g : grade),\n    (apply_late_policy late_days g)\n    =\n    (if late_days <? 9 then g  else\n       if late_days <? 17 then lower_grade g\n       else if late_days <? 21 then lower_grade (lower_grade g)\n            else lower_grade (lower_grade (lower_grade g)))",
    "Name":"apply_late_policy_unfold",
    "Dependencies":[
      "apply_late_policy",
      "lower_grade",
      "grade",
      "ltb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem no_penalty_for_mostly_on_time :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = true) ->\n    apply_late_policy late_days g = g.",
    "Statement":"Theorem no_penalty_for_mostly_on_time :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = true) ->\n    apply_late_policy late_days g = g",
    "Name":"no_penalty_for_mostly_on_time",
    "Dependencies":[
      "apply_late_policy",
      "grade",
      "ltb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem grade_lowered_once :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = false) ->\n    (late_days <? 17 = true) ->\n    (apply_late_policy late_days g) = (lower_grade g).",
    "Statement":"Theorem grade_lowered_once :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = false) ->\n    (late_days <? 17 = true) ->\n    (apply_late_policy late_days g) = (lower_grade g)",
    "Name":"grade_lowered_once",
    "Dependencies":[
      "apply_late_policy",
      "lower_grade",
      "grade",
      "ltb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LateDays.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin).",
    "Statement":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)",
    "Name":"bin",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin).",
    "Statement":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)",
    "Name":"bin",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint incr (m:bin) : bin\n  .",
    "Statement":"Fixpoint incr (m:bin) : bin",
    "Name":"incr",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint incr (m:bin) : bin\n  .",
    "Statement":"Fixpoint incr (m:bin) : bin",
    "Name":"incr",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint bin_to_nat (m:bin) : nat\n  .",
    "Statement":"Fixpoint bin_to_nat (m:bin) : nat",
    "Name":"bin_to_nat",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint bin_to_nat (m:bin) : nat\n  .",
    "Statement":"Fixpoint bin_to_nat (m:bin) : nat",
    "Name":"bin_to_nat",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z).",
    "Statement":"Example test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z)",
    "Name":"test_bin_incr1",
    "Dependencies":[
      "incr",
      "B1",
      "B0",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z).",
    "Statement":"Example test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z)",
    "Name":"test_bin_incr2",
    "Dependencies":[
      "incr",
      "B1",
      "B0",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z)).",
    "Statement":"Example test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z))",
    "Name":"test_bin_incr3",
    "Dependencies":[
      "incr",
      "B1",
      "B0",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2.",
    "Statement":"Example test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2",
    "Name":"test_bin_incr4",
    "Dependencies":[
      "bin_to_nat",
      "B1",
      "B0",
      "Z"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_bin_incr5 :\n        bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z).",
    "Statement":"Example test_bin_incr5 :\n        bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z)",
    "Name":"test_bin_incr5",
    "Dependencies":[
      "bin_to_nat",
      "incr",
      "B1",
      "Z"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_bin_incr6 :\n        bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z).",
    "Statement":"Example test_bin_incr6 :\n        bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z)",
    "Name":"test_bin_incr6",
    "Dependencies":[
      "bin_to_nat",
      "incr",
      "B1",
      "Z"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExport LF.Basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_0_r : forall n:nat, n + 0 = n.",
    "Statement":"Theorem add_0_r : forall n:nat, n + 0 = n",
    "Name":"add_0_r",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n as [| n' IHn'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem minus_n_n : forall n,\n  minus n n = 0.",
    "Statement":"Theorem minus_n_n : forall n,\n  minus n n = 0",
    "Name":"minus_n_n",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n as [| n' IHn'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mul_0_r : forall n:nat,\n  n * 0 = 0.",
    "Statement":"Theorem mul_0_r : forall n:nat,\n  n * 0 = 0",
    "Name":"mul_0_r",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_n_Sm : forall n m : nat,\n  S (n + m) = n + (S m).",
    "Statement":"Theorem plus_n_Sm : forall n m : nat,\n  S (n + m) = n + (S m)",
    "Name":"plus_n_Sm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_n_Sm : forall n m : nat,\n  S (n + m) = n + (S m).",
    "Statement":"Theorem plus_n_Sm : forall n m : nat,\n  S (n + m) = n + (S m)",
    "Name":"plus_n_Sm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_comm : forall n m : nat,\n  n + m = m + n.",
    "Statement":"Theorem add_comm : forall n m : nat,\n  n + m = m + n",
    "Name":"add_comm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end.",
    "Statement":"Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end",
    "Name":"double",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma double_plus : forall n, double n = n + n .",
    "Statement":"Lemma double_plus : forall n, double n = n + n",
    "Name":"double_plus",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_refl : forall n : nat,\n  (n =? n) = true.",
    "Statement":"Theorem eqb_refl : forall n : nat,\n  (n =? n) = true",
    "Name":"eqb_refl",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem even_S : forall n : nat,\n  even (S n) = negb (even n).",
    "Statement":"Theorem even_S : forall n : nat,\n  even (S n) = negb (even n)",
    "Name":"even_S",
    "Dependencies":[
      "even",
      "negb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_0_plus' : forall n m : nat,\n  (n + 0 + 0) * m = n * m.",
    "Statement":"Theorem mult_0_plus' : forall n m : nat,\n  (n + 0 + 0) * m = n * m",
    "Name":"mult_0_plus'",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (H: n + 0 + 0 = n).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite -> H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_rearrange : forall n m p q : nat,\n  (n + m) + (p + q) = (m + n) + (p + q).",
    "Statement":"Theorem plus_rearrange : forall n m p q : nat,\n  (n + m) + (p + q) = (m + n) + (p + q)",
    "Name":"plus_rearrange",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m p q.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (H: n + m = m + n).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n m p.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n as [| n' IHn'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc'' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc'' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc'' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc'' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m p.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n as [| n' IHn'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_add_comm_informal : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_add_comm_informal : option (nat*string) := None",
    "Name":"manual_grade_for_add_comm_informal",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_eqb_refl_informal : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None",
    "Name":"manual_grade_for_eqb_refl_informal",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_shuffle3 : forall n m p : nat,\n  n + (m + p) = m + (n + p).",
    "Statement":"Theorem add_shuffle3 : forall n m p : nat,\n  n + (m + p) = m + (n + p)",
    "Name":"add_shuffle3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mul_comm : forall m n : nat,\n  m * n = n * m.",
    "Statement":"Theorem mul_comm : forall m n : nat,\n  m * n = n * m",
    "Name":"mul_comm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck leb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_leb_compat_l : forall n m p : nat,\n  n <=? m = true -> (p + n) <=? (p + m) = true.",
    "Statement":"Theorem plus_leb_compat_l : forall n m p : nat,\n  n <=? m = true -> (p + n) <=? (p + m) = true",
    "Name":"plus_leb_compat_l",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem leb_refl : forall n:nat,\n  (n <=? n) = true.",
    "Statement":"Theorem leb_refl : forall n:nat,\n  (n <=? n) = true",
    "Name":"leb_refl",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem zero_neqb_S : forall n:nat,\n  0 =? (S n) = false.",
    "Statement":"Theorem zero_neqb_S : forall n:nat,\n  0 =? (S n) = false",
    "Name":"zero_neqb_S",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_false_r : forall b : bool,\n  andb b false = false.",
    "Statement":"Theorem andb_false_r : forall b : bool,\n  andb b false = false",
    "Name":"andb_false_r",
    "Dependencies":[
      "andb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem S_neqb_0 : forall n:nat,\n  (S n) =? 0 = false.",
    "Statement":"Theorem S_neqb_0 : forall n:nat,\n  (S n) =? 0 = false",
    "Name":"S_neqb_0",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_1_l : forall n:nat, 1 * n = n.",
    "Statement":"Theorem mult_1_l : forall n:nat, 1 * n = n",
    "Name":"mult_1_l",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem all3_spec : forall b c : bool,\n  orb\n    (andb b c)\n    (orb (negb b)\n         (negb c))\n  = true.",
    "Statement":"Theorem all3_spec : forall b c : bool,\n  orb\n    (andb b c)\n    (orb (negb b)\n         (negb c))\n  = true",
    "Name":"all3_spec",
    "Dependencies":[
      "orb",
      "andb",
      "negb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_plus_distr_r : forall n m p : nat,\n  (n + m) * p = (n * p) + (m * p).",
    "Statement":"Theorem mult_plus_distr_r : forall n m p : nat,\n  (n + m) * p = (n * p) + (m * p)",
    "Name":"mult_plus_distr_r",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_assoc : forall n m p : nat,\n  n * (m * p) = (n * m) * p.",
    "Statement":"Theorem mult_assoc : forall n m p : nat,\n  n * (m * p) = (n * m) * p",
    "Name":"mult_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_shuffle3' : forall n m p : nat,\n  n + (m + p) = m + (n + p).",
    "Statement":"Theorem add_shuffle3' : forall n m p : nat,\n  n + (m + p) = m + (n + p)",
    "Name":"add_shuffle3'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n.",
    "Statement":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)",
    "Name":"bin",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n.",
    "Statement":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)",
    "Name":"bin",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint incr (m:bin) : bin\n  .",
    "Statement":"Fixpoint incr (m:bin) : bin",
    "Name":"incr",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint incr (m:bin) : bin\n  .",
    "Statement":"Fixpoint incr (m:bin) : bin",
    "Name":"incr",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint bin_to_nat (m:bin) : nat\n  .",
    "Statement":"Fixpoint bin_to_nat (m:bin) : nat",
    "Name":"bin_to_nat",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint bin_to_nat (m:bin) : nat\n  .",
    "Statement":"Fixpoint bin_to_nat (m:bin) : nat",
    "Name":"bin_to_nat",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem bin_to_nat_pres_incr : forall b : bin,\n  bin_to_nat (incr b) = 1 + bin_to_nat b.",
    "Statement":"Theorem bin_to_nat_pres_incr : forall b : bin,\n  bin_to_nat (incr b) = 1 + bin_to_nat b",
    "Name":"bin_to_nat_pres_incr",
    "Dependencies":[
      "bin_to_nat",
      "incr",
      "bin"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nat_to_bin (n:nat) : bin\n  .",
    "Statement":"Fixpoint nat_to_bin (n:nat) : bin",
    "Name":"nat_to_bin",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.",
    "Statement":"Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n",
    "Name":"nat_bin_nat",
    "Dependencies":[
      "nat_to_bin",
      "bin_to_nat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma double_incr : forall n : nat, double (S n) = S (S (double n)).",
    "Statement":"Lemma double_incr : forall n : nat, double (S n) = S (S (double n))",
    "Name":"double_incr",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition double_bin (b:bin) : bin\n  .",
    "Statement":"Definition double_bin (b:bin) : bin",
    "Name":"double_bin",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample double_bin_zero : double_bin Z = Z.",
    "Statement":"Example double_bin_zero : double_bin Z = Z",
    "Name":"double_bin_zero",
    "Dependencies":[
      "double_bin",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma double_incr_bin : forall b,\n    double_bin (incr b) = incr (incr (double_bin b)).",
    "Statement":"Lemma double_incr_bin : forall b,\n    double_bin (incr b) = incr (incr (double_bin b))",
    "Name":"double_incr_bin",
    "Dependencies":[
      "double_bin",
      "incr",
      "bin"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint normalize (b:bin) : bin\n  .",
    "Statement":"Fixpoint normalize (b:bin) : bin",
    "Name":"normalize",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b.",
    "Statement":"Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b",
    "Name":"bin_nat_bin",
    "Dependencies":[
      "normalize",
      "nat_to_bin",
      "bin_to_nat",
      "bin"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Lists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Lists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExport LF.Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export NatList.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive natprod : Type :=\n  | pair (n1 n2 : nat).",
    "Statement":"Inductive natprod : Type :=\n  | pair (n1 n2 : nat)",
    "Name":"natprod",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (pair 3 5) : natprod.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end.",
    "Statement":"Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end",
    "Name":"fst",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end.",
    "Statement":"Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end",
    "Name":"fst",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end.",
    "Statement":"Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end",
    "Name":"snd",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end.",
    "Statement":"Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end",
    "Name":"snd",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (fst (pair 3 5)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"( x , y )\" := (pair x y).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute (fst (3,5)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end.",
    "Statement":"Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end",
    "Name":"fst'",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end.",
    "Statement":"Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end",
    "Name":"snd'",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end.",
    "Statement":"Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end",
    "Name":"swap_pair",
    "Dependencies":[
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem surjective_pairing' : forall (n m : nat),\n  (n,m) = (fst (n,m), snd (n,m)).",
    "Statement":"Theorem surjective_pairing' : forall (n m : nat),\n  (n,m) = (fst (n,m), snd (n,m))",
    "Name":"surjective_pairing'",
    "Dependencies":[
      "snd",
      "fst",
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem surjective_pairing : forall (p : natprod),\n  p = (fst p, snd p).",
    "Statement":"Theorem surjective_pairing : forall (p : natprod),\n  p = (fst p, snd p)",
    "Name":"surjective_pairing",
    "Dependencies":[
      "snd",
      "fst",
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros p.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct p as [n m].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem snd_fst_is_swap : forall (p : natprod),\n  (snd p, fst p) = swap_pair p.",
    "Statement":"Theorem snd_fst_is_swap : forall (p : natprod),\n  (snd p, fst p) = swap_pair p",
    "Name":"snd_fst_is_swap",
    "Dependencies":[
      "swap_pair",
      "snd",
      "fst",
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem fst_swap_is_snd : forall (p : natprod),\n  fst (swap_pair p) = snd p.",
    "Statement":"Theorem fst_swap_is_snd : forall (p : natprod),\n  fst (swap_pair p) = snd p",
    "Name":"fst_swap_is_snd",
    "Dependencies":[
      "swap_pair",
      "snd",
      "fst",
      "natprod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist).",
    "Statement":"Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)",
    "Name":"natlist",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist).",
    "Statement":"Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist)",
    "Name":"natlist",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition mylist := cons 1 (cons 2 (cons 3 nil)).",
    "Statement":"Definition mylist := cons 1 (cons 2 (cons 3 nil))",
    "Name":"mylist",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"[ ]\" := nil.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition mylist1 := 1 :: (2 :: (3 :: nil)).",
    "Statement":"Definition mylist1 := 1 :: (2 :: (3 :: nil))",
    "Name":"mylist1",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition mylist2 := 1 :: 2 :: 3 :: nil.",
    "Statement":"Definition mylist2 := 1 :: 2 :: 3 :: nil",
    "Name":"mylist2",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition mylist3 := [1;2;3].",
    "Statement":"Definition mylist3 := [1;2;3]",
    "Name":"mylist3",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end.",
    "Statement":"Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end",
    "Name":"repeat",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end.",
    "Statement":"Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end",
    "Name":"repeat",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end.",
    "Statement":"Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end",
    "Name":"length",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end.",
    "Statement":"Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end",
    "Name":"length",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end.",
    "Statement":"Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end",
    "Name":"app",
    "Dependencies":[
      "cons",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end.",
    "Statement":"Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end",
    "Name":"app",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].",
    "Statement":"Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5]",
    "Name":"test_app1",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_app2:             nil ++ [4;5] = [4;5].",
    "Statement":"Example test_app2:             nil ++ [4;5] = [4;5]",
    "Name":"test_app2",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_app3:             [1;2;3] ++ nil = [1;2;3].",
    "Statement":"Example test_app3:             [1;2;3] ++ nil = [1;2;3]",
    "Name":"test_app3",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end.",
    "Statement":"Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end",
    "Name":"hd",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end.",
    "Statement":"Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end",
    "Name":"tl",
    "Dependencies":[
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd1:             hd 0 [1;2;3] = 1.",
    "Statement":"Example test_hd1:             hd 0 [1;2;3] = 1",
    "Name":"test_hd1",
    "Dependencies":[
      "hd",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_hd2:             hd 0 [] = 0.",
    "Statement":"Example test_hd2:             hd 0 [] = 0",
    "Name":"test_hd2",
    "Dependencies":[
      "hd",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_tl:              tl [1;2;3] = [2;3].",
    "Statement":"Example test_tl:              tl [1;2;3] = [2;3]",
    "Name":"test_tl",
    "Dependencies":[
      "tl",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nonzeros (l:natlist) : natlist\n  .",
    "Statement":"Fixpoint nonzeros (l:natlist) : natlist",
    "Name":"nonzeros",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nonzeros (l:natlist) : natlist\n  .",
    "Statement":"Fixpoint nonzeros (l:natlist) : natlist",
    "Name":"nonzeros",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].",
    "Statement":"Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3]",
    "Name":"test_nonzeros",
    "Dependencies":[
      "nonzeros",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint oddmembers (l:natlist) : natlist\n  .",
    "Statement":"Fixpoint oddmembers (l:natlist) : natlist",
    "Name":"oddmembers",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].",
    "Statement":"Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3]",
    "Name":"test_oddmembers",
    "Dependencies":[
      "oddmembers",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition countoddmembers (l:natlist) : nat\n  .",
    "Statement":"Definition countoddmembers (l:natlist) : nat",
    "Name":"countoddmembers",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.",
    "Statement":"Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4",
    "Name":"test_countoddmembers1",
    "Dependencies":[
      "countoddmembers",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.",
    "Statement":"Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0",
    "Name":"test_countoddmembers2",
    "Dependencies":[
      "countoddmembers",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_countoddmembers3:\n  countoddmembers nil = 0.",
    "Statement":"Example test_countoddmembers3:\n  countoddmembers nil = 0",
    "Name":"test_countoddmembers3",
    "Dependencies":[
      "countoddmembers",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint alternate (l1 l2 : natlist) : natlist\n  .",
    "Statement":"Fixpoint alternate (l1 l2 : natlist) : natlist",
    "Name":"alternate",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].",
    "Statement":"Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6]",
    "Name":"test_alternate1",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].",
    "Statement":"Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6]",
    "Name":"test_alternate2",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].",
    "Statement":"Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3]",
    "Name":"test_alternate3",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_alternate4:\n  alternate [] [20;30] = [20;30].",
    "Statement":"Example test_alternate4:\n  alternate [] [20;30] = [20;30]",
    "Name":"test_alternate4",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition bag := natlist.",
    "Statement":"Definition bag := natlist",
    "Name":"bag",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint count (v : nat) (s : bag) : nat\n  .",
    "Statement":"Fixpoint count (v : nat) (s : bag) : nat",
    "Name":"count",
    "Dependencies":[
      "list",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint count (v : nat) (s : bag) : nat\n  .",
    "Statement":"Fixpoint count (v : nat) (s : bag) : nat",
    "Name":"count",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_count1:              count 1 [1;2;3;1;4;1] = 3.",
    "Statement":"Example test_count1:              count 1 [1;2;3;1;4;1] = 3",
    "Name":"test_count1",
    "Dependencies":[
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_count2:              count 6 [1;2;3;1;4;1] = 0.",
    "Statement":"Example test_count2:              count 6 [1;2;3;1;4;1] = 0",
    "Name":"test_count2",
    "Dependencies":[
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition sum : bag -> bag -> bag\n  .",
    "Statement":"Definition sum : bag -> bag -> bag",
    "Name":"sum",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.",
    "Statement":"Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3",
    "Name":"test_sum1",
    "Dependencies":[
      "sum",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition add (v : nat) (s : bag) : bag\n  .",
    "Statement":"Definition add (v : nat) (s : bag) : bag",
    "Name":"add",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_add1:                count 1 (add 1 [1;4;1]) = 3.",
    "Statement":"Example test_add1:                count 1 (add 1 [1;4;1]) = 3",
    "Name":"test_add1",
    "Dependencies":[
      "add",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_add2:                count 5 (add 1 [1;4;1]) = 0.",
    "Statement":"Example test_add2:                count 5 (add 1 [1;4;1]) = 0",
    "Name":"test_add2",
    "Dependencies":[
      "add",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint member (v : nat) (s : bag) : bool\n  .",
    "Statement":"Fixpoint member (v : nat) (s : bag) : bool",
    "Name":"member",
    "Dependencies":[
      "bag",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_member1:             member 1 [1;4;1] = true.",
    "Statement":"Example test_member1:             member 1 [1;4;1] = true",
    "Name":"test_member1",
    "Dependencies":[
      "member",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_member2:             member 2 [1;4;1] = false.",
    "Statement":"Example test_member2:             member 2 [1;4;1] = false",
    "Name":"test_member2",
    "Dependencies":[
      "member",
      "cons",
      "nil",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint remove_one (v : nat) (s : bag) : bag\n  .",
    "Statement":"Fixpoint remove_one (v : nat) (s : bag) : bag",
    "Name":"remove_one",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.",
    "Statement":"Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0",
    "Name":"test_remove_one1",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.",
    "Statement":"Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0",
    "Name":"test_remove_one2",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.",
    "Statement":"Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2",
    "Name":"test_remove_one3",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.",
    "Statement":"Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1",
    "Name":"test_remove_one4",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint remove_all (v:nat) (s:bag) : bag\n  .",
    "Statement":"Fixpoint remove_all (v:nat) (s:bag) : bag",
    "Name":"remove_all",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.",
    "Statement":"Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0",
    "Name":"test_remove_all1",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.",
    "Statement":"Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0",
    "Name":"test_remove_all2",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.",
    "Statement":"Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2",
    "Name":"test_remove_all3",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.",
    "Statement":"Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0",
    "Name":"test_remove_all4",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint included (s1 : bag) (s2 : bag) : bool\n  .",
    "Statement":"Fixpoint included (s1 : bag) (s2 : bag) : bool",
    "Name":"included",
    "Dependencies":[
      "bag",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_included1:              included [1;2] [2;1;4;1] = true.",
    "Statement":"Example test_included1:              included [1;2] [2;1;4;1] = true",
    "Name":"test_included1",
    "Dependencies":[
      "included",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_included2:              included [1;2;2] [2;1;4;1] = false.",
    "Statement":"Example test_included2:              included [1;2;2] [2;1;4;1] = false",
    "Name":"test_included2",
    "Dependencies":[
      "included",
      "cons",
      "nil",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_add_inc_count : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_add_inc_count : option (nat*string) := None",
    "Name":"manual_grade_for_add_inc_count",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nil_app : forall l : natlist,\n  [] ++ l = l.",
    "Statement":"Theorem nil_app : forall l : natlist,\n  [] ++ l = l",
    "Name":"nil_app",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem tl_length_pred : forall l:natlist,\n  pred (length l) = length (tl l).",
    "Statement":"Theorem tl_length_pred : forall l:natlist,\n  pred (length l) = length (tl l)",
    "Name":"tl_length_pred",
    "Dependencies":[
      "tl",
      "length",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct l as [| n l'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).",
    "Statement":"Theorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)",
    "Name":"app_assoc",
    "Dependencies":[
      "app",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).",
    "Statement":"Theorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)",
    "Name":"app_assoc",
    "Dependencies":[
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l1 l2 l3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l1 as [| n l1' IHl1'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHl1'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem repeat_plus: forall c1 c2 n: nat,\n    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2).",
    "Statement":"Theorem repeat_plus: forall c1 c2 n: nat,\n    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2)",
    "Name":"repeat_plus",
    "Dependencies":[
      "app",
      "repeat",
      "cons",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c1 c2 n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction c1 as [| c1' IHc1'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite <- IHc1'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end.",
    "Statement":"Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end",
    "Name":"rev",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end.",
    "Statement":"Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end",
    "Name":"rev",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_rev1:            rev [1;2;3] = [3;2;1].",
    "Statement":"Example test_rev1:            rev [1;2;3] = [3;2;1]",
    "Name":"test_rev1",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_rev1:            rev [1;2;3] = [3;2;1].",
    "Statement":"Example test_rev1:            rev [1;2;3] = [3;2;1]",
    "Name":"test_rev1",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_rev2:            rev nil = nil.",
    "Statement":"Example test_rev2:            rev nil = nil",
    "Name":"test_rev2",
    "Dependencies":[
      "rev",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_rev2:            rev nil = nil.",
    "Statement":"Example test_rev2:            rev nil = nil",
    "Name":"test_rev2",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length_S: forall l n,\n  length (l ++ [n]) = S (length l).",
    "Statement":"Theorem app_length_S: forall l n,\n  length (l ++ [n]) = S (length l)",
    "Name":"app_length_S",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l as [| m l' IHl'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite IHl'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2).",
    "Statement":"Theorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2)",
    "Name":"app_length",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2).",
    "Statement":"Theorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2)",
    "Name":"app_length",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2).",
    "Statement":"Theorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2)",
    "Name":"app_length",
    "Dependencies":[
      "length",
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros l1 l2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l1 as [| n l1' IHl1'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHl1'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_length : forall l : natlist,\n  length (rev l) = length l.",
    "Statement":"Theorem rev_length : forall l : natlist,\n  length (rev l) = length l",
    "Name":"rev_length",
    "Dependencies":[
      "app_length",
      "rev",
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist",
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l as [| n l' IHl'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> app_length.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHl'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSearch rev.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSearch (_ + _ = _ + _).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSearch (_ + _ = _ + _) inside Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSearch (?x + ?y = ?y + ?x).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall l : natlist,\n  l ++ [] = l.",
    "Statement":"Theorem app_nil_r : forall l : natlist,\n  l ++ [] = l",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall l : natlist,\n  l ++ [] = l.",
    "Statement":"Theorem app_nil_r : forall l : natlist,\n  l ++ [] = l",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall l : natlist,\n  l ++ [] = l.",
    "Statement":"Theorem app_nil_r : forall l : natlist,\n  l ++ [] = l",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_app_distr: forall l1 l2 : natlist,\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Statement":"Theorem rev_app_distr: forall l1 l2 : natlist,\n  rev (l1 ++ l2) = rev l2 ++ rev l1",
    "Name":"rev_app_distr",
    "Dependencies":[
      "rev",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_app_distr: forall l1 l2 : natlist,\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Statement":"Theorem rev_app_distr: forall l1 l2 : natlist,\n  rev (l1 ++ l2) = rev l2 ++ rev l1",
    "Name":"rev_app_distr",
    "Dependencies":[
      "rev",
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_involutive : forall l : natlist,\n  rev (rev l) = l.",
    "Statement":"Theorem rev_involutive : forall l : natlist,\n  rev (rev l) = l",
    "Name":"rev_involutive",
    "Dependencies":[
      "rev",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_involutive : forall l : natlist,\n  rev (rev l) = l.",
    "Statement":"Theorem rev_involutive : forall l : natlist,\n  rev (rev l) = l",
    "Name":"rev_involutive",
    "Dependencies":[
      "rev",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_assoc4 : forall l1 l2 l3 l4 : natlist,\n  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.",
    "Statement":"Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,\n  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4",
    "Name":"app_assoc4",
    "Dependencies":[
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).",
    "Statement":"Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2)",
    "Name":"nonzeros_app",
    "Dependencies":[
      "app",
      "list",
      "nonzeros"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).",
    "Statement":"Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2)",
    "Name":"nonzeros_app",
    "Dependencies":[
      "nonzeros",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint eqblist (l1 l2 : natlist) : bool\n  .",
    "Statement":"Fixpoint eqblist (l1 l2 : natlist) : bool",
    "Name":"eqblist",
    "Dependencies":[
      "natlist",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_eqblist1 :\n  (eqblist nil nil = true).",
    "Statement":"Example test_eqblist1 :\n  (eqblist nil nil = true)",
    "Name":"test_eqblist1",
    "Dependencies":[
      "eqblist",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.",
    "Statement":"Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true",
    "Name":"test_eqblist2",
    "Dependencies":[
      "eqblist",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.",
    "Statement":"Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false",
    "Name":"test_eqblist3",
    "Dependencies":[
      "eqblist",
      "cons",
      "nil",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqblist_refl : forall l:natlist,\n  true = eqblist l l.",
    "Statement":"Theorem eqblist_refl : forall l:natlist,\n  true = eqblist l l",
    "Name":"eqblist_refl",
    "Dependencies":[
      "eqblist",
      "natlist",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem count_member_nonzero : forall (s : bag),\n  1 <=? (count 1 (1 :: s)) = true.",
    "Statement":"Theorem count_member_nonzero : forall (s : bag),\n  1 <=? (count 1 (1 :: s)) = true",
    "Name":"count_member_nonzero",
    "Dependencies":[
      "count",
      "bag",
      "cons",
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem leb_n_Sn : forall n,\n  n <=? (S n) = true.",
    "Statement":"Theorem leb_n_Sn : forall n,\n  n <=? (S n) = true",
    "Name":"leb_n_Sn",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n as [| n' IHn'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem remove_does_not_increase_count: forall (s : bag),\n  (count 0 (remove_one 0 s)) <=? (count 0 s) = true.",
    "Statement":"Theorem remove_does_not_increase_count: forall (s : bag),\n  (count 0 (remove_one 0 s)) <=? (count 0 s) = true",
    "Name":"remove_does_not_increase_count",
    "Dependencies":[
      "remove_one",
      "count",
      "bag",
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem involution_injective : forall (f : nat -> nat),\n    (forall n : nat, n = f (f n)) -> (forall n1 n2 : nat, f n1 = f n2 -> n1 = n2).",
    "Statement":"Theorem involution_injective : forall (f : nat -> nat),\n    (forall n : nat, n = f (f n)) -> (forall n1 n2 : nat, f n1 = f n2 -> n1 = n2)",
    "Name":"involution_injective",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_injective : forall (l1 l2 : natlist),\n  rev l1 = rev l2 -> l1 = l2.",
    "Statement":"Theorem rev_injective : forall (l1 l2 : natlist),\n  rev l1 = rev l2 -> l1 = l2",
    "Name":"rev_injective",
    "Dependencies":[
      "rev",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nth_bad (l:natlist) (n:nat) : nat :=\n  match l with\n  | nil => 42\n  | a :: l' => match n with\n               | 0 => a\n               | S n' => nth_bad l' n'\n               end\n  end.",
    "Statement":"Fixpoint nth_bad (l:natlist) (n:nat) : nat :=\n  match l with\n  | nil => 42\n  | a :: l' => match n with\n               | 0 => a\n               | S n' => nth_bad l' n'\n               end\n  end",
    "Name":"nth_bad",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive natoption : Type :=\n  | Some (n : nat)\n  | None.",
    "Statement":"Inductive natoption : Type :=\n  | Some (n : nat)\n  | None",
    "Name":"natoption",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Statement":"Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end",
    "Name":"nth_error",
    "Dependencies":[
      "None",
      "Some",
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Statement":"Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end",
    "Name":"nth_error",
    "Dependencies":[
      "None",
      "Some",
      "option",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Statement":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4",
    "Name":"test_nth_error1",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Statement":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4",
    "Name":"test_nth_error1",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.",
    "Statement":"Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7",
    "Name":"test_nth_error2",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.",
    "Statement":"Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7",
    "Name":"test_nth_error2",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error3 : nth_error [4;5;6;7] 9 = None.",
    "Statement":"Example test_nth_error3 : nth_error [4;5;6;7] 9 = None",
    "Name":"test_nth_error3",
    "Dependencies":[
      "nth_error",
      "None",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error3 : nth_error [4;5;6;7] 9 = None.",
    "Statement":"Example test_nth_error3 : nth_error [4;5;6;7] 9 = None",
    "Name":"test_nth_error3",
    "Dependencies":[
      "nth_error",
      "None",
      "option",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition option_elim (d : nat) (o : natoption) : nat :=\n  match o with\n  | Some n' => n'\n  | None => d\n  end.",
    "Statement":"Definition option_elim (d : nat) (o : natoption) : nat :=\n  match o with\n  | Some n' => n'\n  | None => d\n  end",
    "Name":"option_elim",
    "Dependencies":[
      "natoption"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition hd_error (l : natlist) : natoption\n  .",
    "Statement":"Definition hd_error (l : natlist) : natoption",
    "Name":"hd_error",
    "Dependencies":[
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition hd_error (l : natlist) : natoption\n  .",
    "Statement":"Definition hd_error (l : natlist) : natoption",
    "Name":"hd_error",
    "Dependencies":[
      "option",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd_error1 : hd_error [] = None.",
    "Statement":"Example test_hd_error1 : hd_error [] = None",
    "Name":"test_hd_error1",
    "Dependencies":[
      "hd_error",
      "None",
      "natoption",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd_error1 : hd_error [] = None.",
    "Statement":"Example test_hd_error1 : hd_error [] = None",
    "Name":"test_hd_error1",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd_error2 : hd_error [1] = Some 1.",
    "Statement":"Example test_hd_error2 : hd_error [1] = Some 1",
    "Name":"test_hd_error2",
    "Dependencies":[
      "hd_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd_error2 : hd_error [1] = Some 1.",
    "Statement":"Example test_hd_error2 : hd_error [1] = Some 1",
    "Name":"test_hd_error2",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd_error3 : hd_error [5;6] = Some 5.",
    "Statement":"Example test_hd_error3 : hd_error [5;6] = Some 5",
    "Name":"test_hd_error3",
    "Dependencies":[
      "hd_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem option_elim_hd : forall (l:natlist) (default:nat),\n  hd default l = option_elim default (hd_error l).",
    "Statement":"Theorem option_elim_hd : forall (l:natlist) (default:nat),\n  hd default l = option_elim default (hd_error l)",
    "Name":"option_elim_hd",
    "Dependencies":[
      "hd_error",
      "option_elim",
      "hd",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd NatList.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive id : Type :=\n  | Id (n : nat).",
    "Statement":"Inductive id : Type :=\n  | Id (n : nat)",
    "Name":"id",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition eqb_id (x1 x2 : id) :=\n  match x1, x2 with\n  | Id n1, Id n2 => n1 =? n2\n  end.",
    "Statement":"Definition eqb_id (x1 x2 : id) :=\n  match x1, x2 with\n  | Id n1, Id n2 => n1 =? n2\n  end",
    "Name":"eqb_id",
    "Dependencies":[
      "id",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_id_refl : forall x, eqb_id x x = true.",
    "Statement":"Theorem eqb_id_refl : forall x, eqb_id x x = true",
    "Name":"eqb_id_refl",
    "Dependencies":[
      "eqb_id",
      "id",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export PartialMap.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport NatList.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map).",
    "Statement":"Inductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map)",
    "Name":"partial_map",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map).",
    "Statement":"Inductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map)",
    "Name":"partial_map",
    "Dependencies":[
      "id"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d.",
    "Statement":"Definition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d",
    "Name":"update",
    "Dependencies":[
      "partial_map",
      "t_update"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d.",
    "Statement":"Definition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d",
    "Name":"update",
    "Dependencies":[
      "record",
      "partial_map",
      "id"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint find (x : id) (d : partial_map) : natoption :=\n  match d with\n  | empty         => None\n  | record y v d' => if eqb_id x y\n                     then Some v\n                     else find x d'\n  end.",
    "Statement":"Fixpoint find (x : id) (d : partial_map) : natoption :=\n  match d with\n  | empty         => None\n  | record y v d' => if eqb_id x y\n                     then Some v\n                     else find x d'\n  end",
    "Name":"find",
    "Dependencies":[
      "partial_map",
      "None",
      "Some",
      "natoption",
      "eqb_id",
      "id",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_eq :\n  forall (d : partial_map) (x : id) (v: nat),\n    find x (update d x v) = Some v.",
    "Statement":"Theorem update_eq :\n  forall (d : partial_map) (x : id) (v: nat),\n    find x (update d x v) = Some v",
    "Name":"update_eq",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_eq",
      "t_update"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_eq :\n  forall (d : partial_map) (x : id) (v: nat),\n    find x (update d x v) = Some v.",
    "Statement":"Theorem update_eq :\n  forall (d : partial_map) (x : id) (v: nat),\n    find x (update d x v) = Some v",
    "Name":"update_eq",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "Some",
      "natoption",
      "id"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_neq :\n  forall (d : partial_map) (x y : id) (o: nat),\n    eqb_id x y = false -> find x (update d y o) = find x d.",
    "Statement":"Theorem update_neq :\n  forall (d : partial_map) (x y : id) (o: nat),\n    eqb_id x y = false -> find x (update d y o) = find x d",
    "Name":"update_neq",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_neq",
      "t_update"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_neq :\n  forall (d : partial_map) (x y : id) (o: nat),\n    eqb_id x y = false -> find x (update d y o) = find x d.",
    "Statement":"Theorem update_neq :\n  forall (d : partial_map) (x y : id) (o: nat),\n    eqb_id x y = false -> find x (update d y o) = find x d",
    "Name":"update_neq",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "natoption",
      "eqb_id",
      "id",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd PartialMap.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Lists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Lists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Poly.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Poly.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport LF.Lists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist).",
    "Statement":"Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist)",
    "Name":"boollist",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X).",
    "Statement":"Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X)",
    "Name":"list",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck list : Type -> Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (nil nat) : list nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (cons nat 3 (nil nat)) : list nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck nil : forall X : Type, list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck nil : forall X : Type, list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck cons : forall X : Type, X -> list X -> list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck cons : forall X : Type, X -> list X -> list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end.",
    "Statement":"Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end",
    "Name":"repeat",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end.",
    "Statement":"Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end",
    "Name":"repeat",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).",
    "Statement":"Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat))",
    "Name":"test_repeat1",
    "Dependencies":[
      "repeat",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).",
    "Statement":"Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool)",
    "Name":"test_repeat2",
    "Dependencies":[
      "repeat",
      "cons",
      "nil",
      "list",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule MumbleGrumble.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c.",
    "Statement":"Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c",
    "Name":"mumble",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X).",
    "Statement":"Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X)",
    "Name":"grumble",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd MumbleGrumble.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end.",
    "Statement":"Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end",
    "Name":"repeat'",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck repeat'\n  : forall X : Type, X -> nat -> list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck repeat\n  : forall X : Type, X -> nat -> list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck repeat\n  : forall X : Type, X -> nat -> list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end.",
    "Statement":"Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end",
    "Name":"repeat''",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).",
    "Statement":"Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat)))",
    "Name":"list123",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _))).",
    "Statement":"Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _)))",
    "Name":"list123'",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments nil {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments nil {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments cons {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments cons {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments repeat {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments repeat {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition list123'' := cons 1 (cons 2 (cons 3 nil)).",
    "Statement":"Definition list123'' := cons 1 (cons 2 (cons 3 nil))",
    "Name":"list123''",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end.",
    "Statement":"Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end",
    "Name":"repeat'''",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list').",
    "Statement":"Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list')",
    "Name":"list'",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end.",
    "Statement":"Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end",
    "Name":"app",
    "Dependencies":[
      "cons",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end.",
    "Statement":"Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end",
    "Name":"app",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end.",
    "Statement":"Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end",
    "Name":"rev",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end.",
    "Statement":"Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end",
    "Name":"rev",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end.",
    "Statement":"Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end",
    "Name":"length",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end.",
    "Statement":"Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end",
    "Name":"length",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).",
    "Statement":"Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil))",
    "Name":"test_rev1",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).",
    "Statement":"Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil))",
    "Name":"test_rev1",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_rev2:\n  rev (cons true nil) = cons true nil.",
    "Statement":"Example test_rev2:\n  rev (cons true nil) = cons true nil",
    "Name":"test_rev2",
    "Dependencies":[
      "rev",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_rev2:\n  rev (cons true nil) = cons true nil.",
    "Statement":"Example test_rev2:\n  rev (cons true nil) = cons true nil",
    "Name":"test_rev2",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.",
    "Statement":"Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3",
    "Name":"test_length1",
    "Dependencies":[
      "length",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Definition mynil := nil.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition mynil : list nat := nil.",
    "Statement":"Definition mynil : list nat := nil",
    "Name":"mynil",
    "Dependencies":[
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck @nil : forall X : Type, list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition mynil' := @nil nat.",
    "Statement":"Definition mynil' := @nil nat",
    "Name":"mynil'",
    "Dependencies":[
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"[ ]\" := nil.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition list123''' := [1; 2; 3].",
    "Statement":"Definition list123''' := [1; 2; 3]",
    "Name":"list123'''",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l.",
    "Statement":"Theorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l.",
    "Statement":"Theorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l.",
    "Statement":"Theorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n.",
    "Statement":"Theorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n",
    "Name":"app_assoc",
    "Dependencies":[
      "app",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n.",
    "Statement":"Theorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n",
    "Name":"app_assoc",
    "Dependencies":[
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.",
    "Statement":"Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2",
    "Name":"app_length",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.",
    "Statement":"Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2",
    "Name":"app_length",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.",
    "Statement":"Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2",
    "Name":"app_length",
    "Dependencies":[
      "length",
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_app_distr: forall X (l1 l2 : list X),\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Statement":"Theorem rev_app_distr: forall X (l1 l2 : list X),\n  rev (l1 ++ l2) = rev l2 ++ rev l1",
    "Name":"rev_app_distr",
    "Dependencies":[
      "rev",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_app_distr: forall X (l1 l2 : list X),\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Statement":"Theorem rev_app_distr: forall X (l1 l2 : list X),\n  rev (l1 ++ l2) = rev l2 ++ rev l1",
    "Name":"rev_app_distr",
    "Dependencies":[
      "rev",
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_involutive : forall X : Type, forall l : list X,\n  rev (rev l) = l.",
    "Statement":"Theorem rev_involutive : forall X : Type, forall l : list X,\n  rev (rev l) = l",
    "Name":"rev_involutive",
    "Dependencies":[
      "rev",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_involutive : forall X : Type, forall l : list X,\n  rev (rev l) = l.",
    "Statement":"Theorem rev_involutive : forall X : Type, forall l : list X,\n  rev (rev l) = l",
    "Name":"rev_involutive",
    "Dependencies":[
      "rev",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y).",
    "Statement":"Inductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y)",
    "Name":"prod",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments pair {X} {Y}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments pair {X} {Y}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"( x , y )\" := (pair x y).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"X * Y\" := (prod X Y) : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end.",
    "Statement":"Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end",
    "Name":"fst",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end.",
    "Statement":"Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end",
    "Name":"fst",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end.",
    "Statement":"Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end",
    "Name":"snd",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end.",
    "Statement":"Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end",
    "Name":"snd",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n           : list (X*Y) :=\n  match lx, ly with\n  | [], _ => []\n  | _, [] => []\n  | x :: tx, y :: ty => (x, y) :: (combine tx ty)\n  end.",
    "Statement":"Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n           : list (X*Y) :=\n  match lx, ly with\n  | [], _ => []\n  | _, [] => []\n  | x :: tx, y :: ty => (x, y) :: (combine tx ty)\n  end",
    "Name":"combine",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  .",
    "Statement":"Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)",
    "Name":"split",
    "Dependencies":[
      "prod",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  .",
    "Statement":"Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)",
    "Name":"split",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_split:\n  split [(1,false);(2,false)] = ([1;2],[false;false]).",
    "Statement":"Example test_split:\n  split [(1,false);(2,false)] = ([1;2],[false;false])",
    "Name":"test_split",
    "Dependencies":[
      "split",
      "pair",
      "prod",
      "cons",
      "nil",
      "list",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive option (X:Type) : Type :=\n  | Some (x : X)\n  | None.",
    "Statement":"Inductive option (X:Type) : Type :=\n  | Some (x : X)\n  | None",
    "Name":"option",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments Some {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments Some {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments None {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments None {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Statement":"Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end",
    "Name":"nth_error",
    "Dependencies":[
      "None",
      "Some",
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Statement":"Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end",
    "Name":"nth_error",
    "Dependencies":[
      "None",
      "Some",
      "option",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Statement":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4",
    "Name":"test_nth_error1",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Statement":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4",
    "Name":"test_nth_error1",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].",
    "Statement":"Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2]",
    "Name":"test_nth_error2",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].",
    "Statement":"Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2]",
    "Name":"test_nth_error2",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error3 : nth_error [true] 2 = None.",
    "Statement":"Example test_nth_error3 : nth_error [true] 2 = None",
    "Name":"test_nth_error3",
    "Dependencies":[
      "nth_error",
      "None",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_nth_error3 : nth_error [true] 2 = None.",
    "Statement":"Example test_nth_error3 : nth_error [true] 2 = None",
    "Name":"test_nth_error3",
    "Dependencies":[
      "nth_error",
      "None",
      "option",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition hd_error {X : Type} (l : list X) : option X\n  .",
    "Statement":"Definition hd_error {X : Type} (l : list X) : option X",
    "Name":"hd_error",
    "Dependencies":[
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition hd_error {X : Type} (l : list X) : option X\n  .",
    "Statement":"Definition hd_error {X : Type} (l : list X) : option X",
    "Name":"hd_error",
    "Dependencies":[
      "option",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck @hd_error : forall X : Type, list X -> option X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd_error1 : hd_error [1;2] = Some 1.",
    "Statement":"Example test_hd_error1 : hd_error [1;2] = Some 1",
    "Name":"test_hd_error1",
    "Dependencies":[
      "hd_error",
      "None",
      "natoption",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_hd_error1 : hd_error [1;2] = Some 1.",
    "Statement":"Example test_hd_error1 : hd_error [1;2] = Some 1",
    "Name":"test_hd_error1",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_hd_error2 : hd_error  [[1];[2]]  = Some [1].",
    "Statement":"Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1]",
    "Name":"test_hd_error2",
    "Dependencies":[
      "hd_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_hd_error2 : hd_error  [[1];[2]]  = Some [1].",
    "Statement":"Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1]",
    "Name":"test_hd_error2",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition doit3times {X : Type} (f : X->X) (n : X) : X :=\n  f (f (f n)).",
    "Statement":"Definition doit3times {X : Type} (f : X->X) (n : X) : X :=\n  f (f (f n))",
    "Name":"doit3times",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck @doit3times : forall X : Type, (X -> X) -> X -> X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_doit3times: doit3times minustwo 9 = 3.",
    "Statement":"Example test_doit3times: doit3times minustwo 9 = 3",
    "Name":"test_doit3times",
    "Dependencies":[
      "doit3times",
      "minustwo"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_doit3times': doit3times negb true = false.",
    "Statement":"Example test_doit3times': doit3times negb true = false",
    "Name":"test_doit3times'",
    "Dependencies":[
      "doit3times",
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end.",
    "Statement":"Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end",
    "Name":"filter",
    "Dependencies":[
      "cons",
      "nil",
      "list",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_filter1: filter even [1;2;3;4] = [2;4].",
    "Statement":"Example test_filter1: filter even [1;2;3;4] = [2;4]",
    "Name":"test_filter1",
    "Dependencies":[
      "filter",
      "cons",
      "nil",
      "list",
      "even"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition length_is_1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1.",
    "Statement":"Definition length_is_1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1",
    "Name":"length_is_1",
    "Dependencies":[
      "length",
      "list",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_filter2:\n    filter length_is_1\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].",
    "Statement":"Example test_filter2:\n    filter length_is_1\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ]",
    "Name":"test_filter2",
    "Dependencies":[
      "length_is_1",
      "filter",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition countoddmembers' (l:list nat) : nat :=\n  length (filter odd l).",
    "Statement":"Definition countoddmembers' (l:list nat) : nat :=\n  length (filter odd l)",
    "Name":"countoddmembers'",
    "Dependencies":[
      "filter",
      "length",
      "list",
      "odd"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.",
    "Statement":"Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4",
    "Name":"test_countoddmembers'1",
    "Dependencies":[
      "countoddmembers'",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.",
    "Statement":"Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0",
    "Name":"test_countoddmembers'2",
    "Dependencies":[
      "countoddmembers'",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_countoddmembers'3:   countoddmembers' nil = 0.",
    "Statement":"Example test_countoddmembers'3:   countoddmembers' nil = 0",
    "Name":"test_countoddmembers'3",
    "Dependencies":[
      "countoddmembers'",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_anon_fun':\n  doit3times (fun n => n * n) 2 = 256.",
    "Statement":"Example test_anon_fun':\n  doit3times (fun n => n * n) 2 = 256",
    "Name":"test_anon_fun'",
    "Dependencies":[
      "doit3times"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].",
    "Statement":"Example test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ]",
    "Name":"test_filter2'",
    "Dependencies":[
      "filter",
      "length",
      "cons",
      "nil",
      "list",
      "eqb"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition filter_even_gt7 (l : list nat) : list nat\n  .",
    "Statement":"Definition filter_even_gt7 (l : list nat) : list nat",
    "Name":"filter_even_gt7",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_filter_even_gt7_1 :\n  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].",
    "Statement":"Example test_filter_even_gt7_1 :\n  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8]",
    "Name":"test_filter_even_gt7_1",
    "Dependencies":[
      "filter_even_gt7",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_filter_even_gt7_2 :\n  filter_even_gt7 [5;2;6;19;129] = [].",
    "Statement":"Example test_filter_even_gt7_2 :\n  filter_even_gt7 [5;2;6;19;129] = []",
    "Name":"test_filter_even_gt7_2",
    "Dependencies":[
      "filter_even_gt7",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition partition {X : Type}\n                     (test : X -> bool)\n                     (l : list X)\n                   : list X * list X\n  .",
    "Statement":"Definition partition {X : Type}\n                     (test : X -> bool)\n                     (l : list X)\n                   : list X * list X",
    "Name":"partition",
    "Dependencies":[
      "prod",
      "list",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).",
    "Statement":"Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4])",
    "Name":"test_partition1",
    "Dependencies":[
      "partition",
      "pair",
      "prod",
      "cons",
      "nil",
      "list",
      "odd"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).",
    "Statement":"Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0])",
    "Name":"test_partition2",
    "Dependencies":[
      "partition",
      "pair",
      "prod",
      "cons",
      "nil",
      "list",
      "false"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end.",
    "Statement":"Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end",
    "Name":"map",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].",
    "Statement":"Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5]",
    "Name":"test_map1",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_map2:\n  map odd [2;1;2;5] = [false;true;false;true].",
    "Statement":"Example test_map2:\n  map odd [2;1;2;5] = [false;true;false;true]",
    "Name":"test_map2",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list",
      "odd",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_map3:\n    map (fun n => [even n;odd n]) [2;1;2;5]\n  = [[true;false];[false;true];[true;false];[false;true]].",
    "Statement":"Example test_map3:\n    map (fun n => [even n;odd n]) [2;1;2;5]\n  = [[true;false];[false;true];[true;false];[false;true]]",
    "Name":"test_map3",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list",
      "odd",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),\n  map f (rev l) = rev (map f l).",
    "Statement":"Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),\n  map f (rev l) = rev (map f l)",
    "Name":"map_rev",
    "Dependencies":[
      "map",
      "rev",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)\n                   : list Y\n  .",
    "Statement":"Fixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)\n                   : list Y",
    "Name":"flat_map",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_flat_map1:\n  flat_map (fun n => [n;n;n]) [1;5;4]\n  = [1; 1; 1; 5; 5; 5; 4; 4; 4].",
    "Statement":"Example test_flat_map1:\n  flat_map (fun n => [n;n;n]) [1;5;4]\n  = [1; 1; 1; 5; 5; 5; 4; 4; 4]",
    "Name":"test_flat_map1",
    "Dependencies":[
      "flat_map",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end.",
    "Statement":"Definition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end",
    "Name":"option_map",
    "Dependencies":[
      "None",
      "Some",
      "option"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end.",
    "Statement":"Fixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end",
    "Name":"fold",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (fold andb) : list bool -> bool -> bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample fold_example1 :\n  fold andb [true;true;false;true] true = false.",
    "Statement":"Example fold_example1 :\n  fold andb [true;true;false;true] true = false",
    "Name":"fold_example1",
    "Dependencies":[
      "fold",
      "cons",
      "nil",
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample fold_example2 :\n  fold mult [1;2;3;4] 1 = 24.",
    "Statement":"Example fold_example2 :\n  fold mult [1;2;3;4] 1 = 24",
    "Name":"fold_example2",
    "Dependencies":[
      "fold",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample fold_example3 :\n  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].",
    "Statement":"Example fold_example3 :\n  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4]",
    "Name":"fold_example3",
    "Dependencies":[
      "fold",
      "app",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x.",
    "Statement":"Definition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x",
    "Name":"constfun",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ftrue := constfun true.",
    "Statement":"Definition ftrue := constfun true",
    "Name":"ftrue",
    "Dependencies":[
      "constfun",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample constfun_example1 : ftrue 0 = true.",
    "Statement":"Example constfun_example1 : ftrue 0 = true",
    "Name":"constfun_example1",
    "Dependencies":[
      "ftrue",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample constfun_example2 : (constfun 5) 99 = 5.",
    "Statement":"Example constfun_example2 : (constfun 5) 99 = 5",
    "Name":"constfun_example2",
    "Dependencies":[
      "constfun"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck plus : nat -> nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck plus : nat -> nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition plus3 := plus 3.",
    "Statement":"Definition plus3 := plus 3",
    "Name":"plus3",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck plus3 : nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_plus3 :    plus3 4 = 7.",
    "Statement":"Example test_plus3 :    plus3 4 = 7",
    "Name":"test_plus3",
    "Dependencies":[
      "plus3"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_plus3' :   doit3times plus3 0 = 9.",
    "Statement":"Example test_plus3' :   doit3times plus3 0 = 9",
    "Name":"test_plus3'",
    "Dependencies":[
      "plus3",
      "doit3times"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample test_plus3'' :  doit3times (plus 3) 0 = 9.",
    "Statement":"Example test_plus3'' :  doit3times (plus 3) 0 = 9",
    "Name":"test_plus3''",
    "Dependencies":[
      "doit3times"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Exercises.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fold_length {X : Type} (l : list X) : nat :=\n  fold (fun _ n => S n) l 0.",
    "Statement":"Definition fold_length {X : Type} (l : list X) : nat :=\n  fold (fun _ n => S n) l 0",
    "Name":"fold_length",
    "Dependencies":[
      "fold",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_fold_length1 : fold_length [4;7;0] = 3.",
    "Statement":"Example test_fold_length1 : fold_length [4;7;0] = 3",
    "Name":"test_fold_length1",
    "Dependencies":[
      "cons",
      "nil",
      "fold_length"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem fold_length_correct : forall X (l : list X),\n  fold_length l = length l.",
    "Statement":"Theorem fold_length_correct : forall X (l : list X),\n  fold_length l = length l",
    "Name":"fold_length_correct",
    "Dependencies":[
      "length",
      "list",
      "fold_length"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y\n  .",
    "Statement":"Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y",
    "Name":"fold_map",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_fold_map : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_fold_map : option (nat*string) := None",
    "Name":"manual_grade_for_fold_map",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition prod_curry {X Y Z : Type}\n  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).",
    "Statement":"Definition prod_curry {X Y Z : Type}\n  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y)",
    "Name":"prod_curry",
    "Dependencies":[
      "pair",
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition prod_uncurry {X Y Z : Type}\n  (f : X -> Y -> Z) (p : X * Y) : Z\n  .",
    "Statement":"Definition prod_uncurry {X Y Z : Type}\n  (f : X -> Y -> Z) (p : X * Y) : Z",
    "Name":"prod_uncurry",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_map1': map (plus 3) [2;0;2] = [5;3;5].",
    "Statement":"Example test_map1': map (plus 3) [2;0;2] = [5;3;5]",
    "Name":"test_map1'",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck @prod_curry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck @prod_uncurry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem uncurry_curry : forall (X Y Z : Type)\n                        (f : X -> Y -> Z)\n                        x y,\n  prod_curry (prod_uncurry f) x y = f x y.",
    "Statement":"Theorem uncurry_curry : forall (X Y Z : Type)\n                        (f : X -> Y -> Z)\n                        x y,\n  prod_curry (prod_uncurry f) x y = f x y",
    "Name":"uncurry_curry",
    "Dependencies":[
      "prod_uncurry",
      "prod_curry"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem curry_uncurry : forall (X Y Z : Type)\n                        (f : (X * Y) -> Z) (p : X * Y),\n  prod_uncurry (prod_curry f) p = f p.",
    "Statement":"Theorem curry_uncurry : forall (X Y Z : Type)\n                        (f : (X * Y) -> Z) (p : X * Y),\n  prod_uncurry (prod_curry f) p = f p",
    "Name":"curry_uncurry",
    "Dependencies":[
      "prod",
      "prod_uncurry",
      "prod_curry"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_informal_proof : option (nat*string) := None",
    "Name":"manual_grade_for_informal_proof",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_informal_proof : option (nat*string) := None",
    "Name":"manual_grade_for_informal_proof",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export Church.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition cnat := forall X : Type, (X -> X) -> X -> X.",
    "Statement":"Definition cnat := forall X : Type, (X -> X) -> X -> X",
    "Name":"cnat",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition one : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => f x.",
    "Statement":"Definition one : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => f x",
    "Name":"one",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition two : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => f (f x).",
    "Statement":"Definition two : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => f (f x)",
    "Name":"two",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition zero : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => x.",
    "Statement":"Definition zero : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => x",
    "Name":"zero",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition three : cnat := @doit3times.",
    "Statement":"Definition three : cnat := @doit3times",
    "Name":"three",
    "Dependencies":[
      "doit3times",
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition zero' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => zero.",
    "Statement":"Definition zero' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => zero",
    "Name":"zero'",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition one' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => succ zero.",
    "Statement":"Definition one' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => succ zero",
    "Name":"one'",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition two' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => succ (succ zero).",
    "Statement":"Definition two' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => succ (succ zero)",
    "Name":"two'",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample zero_church_peano : zero nat S O = 0.",
    "Statement":"Example zero_church_peano : zero nat S O = 0",
    "Name":"zero_church_peano",
    "Dependencies":[
      "zero"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample one_church_peano : one nat S O = 1.",
    "Statement":"Example one_church_peano : one nat S O = 1",
    "Name":"one_church_peano",
    "Dependencies":[
      "one"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample two_church_peano : two nat S O = 2.",
    "Statement":"Example two_church_peano : two nat S O = 2",
    "Name":"two_church_peano",
    "Dependencies":[
      "two"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition scc (n : cnat) : cnat\n  .",
    "Statement":"Definition scc (n : cnat) : cnat",
    "Name":"scc",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample scc_1 : scc zero = one.",
    "Statement":"Example scc_1 : scc zero = one",
    "Name":"scc_1",
    "Dependencies":[
      "scc",
      "zero",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample scc_2 : scc one = two.",
    "Statement":"Example scc_2 : scc one = two",
    "Name":"scc_2",
    "Dependencies":[
      "scc",
      "two",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample scc_3 : scc two = three.",
    "Statement":"Example scc_3 : scc two = three",
    "Name":"scc_3",
    "Dependencies":[
      "scc",
      "three",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition plus (n m : cnat) : cnat\n  .",
    "Statement":"Definition plus (n m : cnat) : cnat",
    "Name":"plus",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition plus (n m : cnat) : cnat\n  .",
    "Statement":"Definition plus (n m : cnat) : cnat",
    "Name":"plus",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample plus_1 : plus zero one = one.",
    "Statement":"Example plus_1 : plus zero one = one",
    "Name":"plus_1",
    "Dependencies":[
      "plus",
      "zero",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample plus_2 : plus two three = plus three two.",
    "Statement":"Example plus_2 : plus two three = plus three two",
    "Name":"plus_2",
    "Dependencies":[
      "plus",
      "three",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample plus_3 :\n  plus (plus two two) three = plus one (plus three three).",
    "Statement":"Example plus_3 :\n  plus (plus two two) three = plus one (plus three three)",
    "Name":"plus_3",
    "Dependencies":[
      "plus",
      "three",
      "two",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition mult (n m : cnat) : cnat\n  .",
    "Statement":"Definition mult (n m : cnat) : cnat",
    "Name":"mult",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition mult (n m : cnat) : cnat\n  .",
    "Statement":"Definition mult (n m : cnat) : cnat",
    "Name":"mult",
    "Dependencies":[
      "plus"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample mult_1 : mult one one = one.",
    "Statement":"Example mult_1 : mult one one = one",
    "Name":"mult_1",
    "Dependencies":[
      "mult",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample mult_2 : mult zero (plus three three) = zero.",
    "Statement":"Example mult_2 : mult zero (plus three three) = zero",
    "Name":"mult_2",
    "Dependencies":[
      "mult",
      "plus",
      "three",
      "zero",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample mult_3 : mult two three = plus three three.",
    "Statement":"Example mult_3 : mult two three = plus three three",
    "Name":"mult_3",
    "Dependencies":[
      "mult",
      "plus",
      "three",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition exp (n m : cnat) : cnat\n  .",
    "Statement":"Definition exp (n m : cnat) : cnat",
    "Name":"exp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition exp (n m : cnat) : cnat\n  .",
    "Statement":"Definition exp (n m : cnat) : cnat",
    "Name":"exp",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample exp_1 : exp two two = plus two two.",
    "Statement":"Example exp_1 : exp two two = plus two two",
    "Name":"exp_1",
    "Dependencies":[
      "exp",
      "plus",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample exp_2 : exp three zero = one.",
    "Statement":"Example exp_2 : exp three zero = one",
    "Name":"exp_2",
    "Dependencies":[
      "exp",
      "three",
      "zero",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample exp_3 : exp three two = plus (mult two (mult two two)) one.",
    "Statement":"Example exp_3 : exp three two = plus (mult two (mult two two)) one",
    "Name":"exp_3",
    "Dependencies":[
      "exp",
      "mult",
      "plus",
      "three",
      "two",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Church.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nEnd Exercises.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Poly.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Poly.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport LF.Poly.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.",
    "Statement":"Theorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.",
    "Statement":"Theorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.",
    "Statement":"Theorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].",
    "Statement":"Theorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p]",
    "Name":"silly2",
    "Dependencies":[
      "aeval",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].",
    "Statement":"Theorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p]",
    "Name":"silly2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].",
    "Statement":"Theorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p]",
    "Name":"silly2",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o p eq1 eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply eq1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2a : forall (n m : nat),\n  (n,n) = (m,m)  ->\n  (forall (q r : nat), (q,q) = (r,r) -> [q] = [r]) ->\n  [n] = [m].",
    "Statement":"Theorem silly2a : forall (n m : nat),\n  (n,n) = (m,m)  ->\n  (forall (q r : nat), (q,q) = (r,r) -> [q] = [r]) ->\n  [n] = [m]",
    "Name":"silly2a",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m eq1 eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply eq1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly_ex : forall p,\n  (forall n, even n = true -> even (S n) = false) ->\n  (forall n, even n = false -> odd n = true) ->\n  even p = true ->\n  odd (S p) = true.",
    "Statement":"Theorem silly_ex : forall p,\n  (forall n, even n = true -> even (S n) = false) ->\n  (forall n, even n = false -> odd n = true) ->\n  even p = true ->\n  odd (S p) = true",
    "Name":"silly_ex",
    "Dependencies":[
      "odd",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly3 : forall (n m : nat),\n  n = m ->\n  m = n.",
    "Statement":"Theorem silly3 : forall (n m : nat),\n  n = m ->\n  m = n",
    "Name":"silly3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  Fail apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  symmetry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rev_exercise1 : forall (l l' : list nat),\n  l = rev l' ->\n  l' = rev l.",
    "Statement":"Theorem rev_exercise1 : forall (l l' : list nat),\n  l = rev l' ->\n  l' = rev l",
    "Name":"rev_exercise1",
    "Dependencies":[
      "rev",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Statement":"Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f]",
    "Name":"trans_eq_example",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a b c d e f eq1 eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite -> eq1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem trans_eq : forall (X:Type) (n m o : X),\n  n = m -> m = o -> n = o.",
    "Statement":"Theorem trans_eq : forall (X:Type) (n m o : X),\n  n = m -> m = o -> n = o",
    "Name":"trans_eq",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros X n m o eq1 eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> eq1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Statement":"Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f]",
    "Name":"trans_eq_example'",
    "Dependencies":[
      "trans_eq",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a b c d e f eq1 eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply trans_eq with (m:=[c;d]).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eq1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Statement":"Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f]",
    "Name":"trans_eq_example''",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a b c d e f eq1 eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  transitivity [c;d].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eq1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).",
    "Statement":"Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o)",
    "Name":"trans_eq_exercise",
    "Dependencies":[
      "minustwo"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem S_injective : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "Statement":"Theorem S_injective : forall (n m : nat),\n  S n = S m ->\n  n = m",
    "Name":"S_injective",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (H2: n = pred (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n{",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem S_injective' : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "Statement":"Theorem S_injective' : forall (n m : nat),\n  S n = S m ->\n  n = m",
    "Name":"S_injective'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  injection H as Hnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply Hnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem injection_ex1 : forall (n m o : nat),\n  [n;m] = [o;o] ->\n  n = m.",
    "Statement":"Theorem injection_ex1 : forall (n m o : nat),\n  [n;m] = [o;o] ->\n  n = m",
    "Name":"injection_ex1",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  injection H as H1 H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.",
    "Statement":"Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y",
    "Name":"injection_ex3",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem discriminate_ex1 : forall (n m : nat),\n  false = true ->\n  n = m.",
    "Statement":"Theorem discriminate_ex1 : forall (n m : nat),\n  false = true ->\n  n = m",
    "Name":"discriminate_ex1",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem discriminate_ex2 : forall (n : nat),\n  S n = O ->\n  2 + 2 = 5.",
    "Statement":"Theorem discriminate_ex2 : forall (n : nat),\n  S n = O ->\n  2 + 2 = 5",
    "Name":"discriminate_ex2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.",
    "Statement":"Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z",
    "Name":"discriminate_ex3",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_0_l : forall n,\n   0 =? n = true -> n = 0.",
    "Statement":"Theorem eqb_0_l : forall n,\n   0 =? n = true -> n = 0",
    "Name":"eqb_0_l",
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  destruct n as [| n'] eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),\n  x = y -> f x = f y.",
    "Statement":"Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),\n  x = y -> f x = f y",
    "Name":"f_equal",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros A B f x y eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eq_implies_succ_equal : forall (n m : nat),\n  n = m -> S n = S m.",
    "Statement":"Theorem eq_implies_succ_equal : forall (n m : nat),\n  n = m -> S n = S m",
    "Name":"eq_implies_succ_equal",
    "Dependencies":[
      "f_equal"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n m H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply f_equal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eq_implies_succ_equal' : forall (n m : nat),\n  n = m -> S n = S m.",
    "Statement":"Theorem eq_implies_succ_equal' : forall (n m : nat),\n  n = m -> S n = S m",
    "Name":"eq_implies_succ_equal'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n m H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nf_equal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem S_inj : forall (n m : nat) (b : bool),\n  ((S n) =? (S m)) = b  ->\n  (n =? m) = b.",
    "Statement":"Theorem S_inj : forall (n m : nat) (b : bool),\n  ((S n) =? (S m)) = b  ->\n  (n =? m) = b",
    "Name":"S_inj",
    "Dependencies":[
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m b H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly4 : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p.",
    "Statement":"Theorem silly4 : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p",
    "Name":"silly4",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m p q EQ H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  symmetry in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply EQ in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsymmetry in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem specialize_example: forall n,\n     (forall m, m*n = 0)\n  -> n = 0.",
    "Statement":"Theorem specialize_example: forall n,\n     (forall m, m*n = 0)\n  -> n = 0",
    "Name":"specialize_example",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  specialize H with (m := 1).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite add_comm in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Statement":"Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f]",
    "Name":"trans_eq_example'''",
    "Dependencies":[
      "trans_eq",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a b c d e f eq1 eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  specialize trans_eq with (m:=[c;d]) as H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eq1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eq2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem double_injective : forall n m,\n  double n = double m ->\n  n = m.",
    "Statement":"Theorem double_injective : forall n m,\n  double n = double m ->\n  n = m",
    "Name":"double_injective",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n as [| n' IHn'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros m eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct m as [| m'] eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros m eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct m as [| m'] eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    discriminate eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      f_equal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninjection eq as goal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply goal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_true : forall n m,\n  n =? m = true -> n = m.",
    "Statement":"Theorem eqb_true : forall n m,\n  n =? m = true -> n = m",
    "Name":"eqb_true",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_informal_proof : option (nat*string) := None",
    "Name":"manual_grade_for_informal_proof",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_informal_proof : option (nat*string) := None",
    "Name":"manual_grade_for_informal_proof",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_n_n_injective : forall n m,\n  n + n = m + m ->\n  n = m.",
    "Statement":"Theorem plus_n_n_injective : forall n m,\n  n + n = m + m ->\n  n = m",
    "Name":"plus_n_n_injective",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem double_injective_take2 : forall n m,\n  double n = double m ->\n  n = m.",
    "Statement":"Theorem double_injective_take2 : forall n m,\n  double n = double m ->\n  n = m",
    "Name":"double_injective_take2",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  generalize dependent n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  induction m as [| m' IHm'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct n as [| n'] eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct n as [| n'] eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  f_equal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      apply IHm'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninjection eq as goal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply goal.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X),\n  length l = n ->\n  nth_error l n = None.",
    "Statement":"Theorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X),\n  length l = n ->\n  nth_error l n = None",
    "Name":"nth_error_after_last",
    "Dependencies":[
      "nth_error",
      "None",
      "option",
      "length",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition square n := n * n.",
    "Statement":"Definition square n := n * n",
    "Name":"square",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma square_mult : forall n m, square (n * m) = square n * square m.",
    "Statement":"Lemma square_mult : forall n m, square (n * m) = square n * square m",
    "Name":"square_mult",
    "Dependencies":[
      "square",
      "mult_assoc",
      "mul_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  unfold square.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  rewrite mult_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (H : n * m * n = n * n * m).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite mul_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply mult_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite mult_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo (x: nat) := 5.",
    "Statement":"Definition foo (x: nat) := 5",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo (x: nat) := 5.",
    "Statement":"Definition foo (x: nat) := 5",
    "Name":"foo",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo (x: nat) := 5.",
    "Statement":"Definition foo (x: nat) := 5",
    "Name":"foo",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition foo (x: nat) := 5.",
    "Statement":"Definition foo (x: nat) := 5",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nFact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.",
    "Statement":"Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1",
    "Name":"silly_fact_1",
    "Dependencies":[
      "foo"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end.",
    "Statement":"Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end",
    "Name":"bar",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nFact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.",
    "Statement":"Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1",
    "Name":"silly_fact_2",
    "Dependencies":[
      "bar"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct m eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nFact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.",
    "Statement":"Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1",
    "Name":"silly_fact_2'",
    "Dependencies":[
      "bar"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold bar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  destruct m eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false.",
    "Statement":"Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false",
    "Name":"sillyfun",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem sillyfun_false : forall (n : nat),\n  sillyfun n = false.",
    "Statement":"Theorem sillyfun_false : forall (n : nat),\n  sillyfun n = false",
    "Name":"sillyfun_false",
    "Dependencies":[
      "sillyfun",
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold sillyfun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct (n =? 3) eqn:E1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct (n =? 5) eqn:E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end.",
    "Statement":"Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end",
    "Name":"split",
    "Dependencies":[
      "prod",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end.",
    "Statement":"Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end",
    "Name":"split",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem combine_split : forall X Y (l : list (X * Y)) l1 l2,\n  split l = (l1, l2) ->\n  combine l1 l2 = l.",
    "Statement":"Theorem combine_split : forall X Y (l : list (X * Y)) l1 l2,\n  split l = (l1, l2) ->\n  combine l1 l2 = l",
    "Name":"combine_split",
    "Dependencies":[
      "split",
      "combine",
      "pair",
      "prod",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false.",
    "Statement":"Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false",
    "Name":"sillyfun1",
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem sillyfun1_odd : forall (n : nat),\n  sillyfun1 n = true ->\n  odd n = true.",
    "Statement":"Theorem sillyfun1_odd : forall (n : nat),\n  sillyfun1 n = true ->\n  odd n = true",
    "Name":"sillyfun1_odd",
    "Dependencies":[
      "sillyfun1",
      "eqb_true",
      "eqb",
      "odd",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold sillyfun1 in eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct (n =? 3) eqn:Heqe3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eqb_true in Heqe3.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n      rewrite -> Heqe3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      destruct (n =? 5) eqn:Heqe5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n          apply eqb_true in Heqe5.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n          rewrite -> Heqe5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem bool_fn_applied_thrice :\n  forall (f : bool -> bool) (b : bool),\n  f (f (f b)) = f b.",
    "Statement":"Theorem bool_fn_applied_thrice :\n  forall (f : bool -> bool) (b : bool),\n  f (f (f b)) = f b",
    "Name":"bool_fn_applied_thrice",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_sym : forall (n m : nat),\n  (n =? m) = (m =? n).",
    "Statement":"Theorem eqb_sym : forall (n m : nat),\n  (n =? m) = (m =? n)",
    "Name":"eqb_sym",
    "Dependencies":[
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_trans : forall n m p,\n  n =? m = true ->\n  m =? p = true ->\n  n =? p = true.",
    "Statement":"Theorem eqb_trans : forall n m p,\n  n =? m = true ->\n  m =? p = true ->\n  n =? p = true",
    "Name":"eqb_trans",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition split_combine_statement : Prop\n\n  .",
    "Statement":"Definition split_combine_statement : Prop",
    "Name":"split_combine_statement",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem split_combine : split_combine_statement.",
    "Statement":"Theorem split_combine : split_combine_statement",
    "Name":"split_combine",
    "Dependencies":[
      "split_combine_statement"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_split_combine : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_split_combine : option (nat*string) := None",
    "Name":"manual_grade_for_split_combine",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem filter_exercise : forall (X : Type) (test : X -> bool)\n                                 (x : X) (l lf : list X),\n  filter test l = x :: lf ->\n  test x = true.",
    "Statement":"Theorem filter_exercise : forall (X : Type) (test : X -> bool)\n                                 (x : X) (l lf : list X),\n  filter test l = x :: lf ->\n  test x = true",
    "Name":"filter_exercise",
    "Dependencies":[
      "filter",
      "cons",
      "list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Statement":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool",
    "Name":"forallb",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Statement":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool",
    "Name":"forallb",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_forallb_1 : forallb odd [1;3;5;7;9] = true.",
    "Statement":"Example test_forallb_1 : forallb odd [1;3;5;7;9] = true",
    "Name":"test_forallb_1",
    "Dependencies":[
      "forallb",
      "cons",
      "nil",
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_forallb_2 : forallb negb [false;false] = true.",
    "Statement":"Example test_forallb_2 : forallb negb [false;false] = true",
    "Name":"test_forallb_2",
    "Dependencies":[
      "forallb",
      "cons",
      "nil",
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_forallb_3 : forallb even [0;2;4;5] = false.",
    "Statement":"Example test_forallb_3 : forallb even [0;2;4;5] = false",
    "Name":"test_forallb_3",
    "Dependencies":[
      "forallb",
      "cons",
      "nil",
      "even",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_forallb_4 : forallb (eqb 5) [] = true.",
    "Statement":"Example test_forallb_4 : forallb (eqb 5) [] = true",
    "Name":"test_forallb_4",
    "Dependencies":[
      "forallb",
      "nil",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint existsb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Statement":"Fixpoint existsb {X : Type} (test : X -> bool) (l : list X) : bool",
    "Name":"existsb",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_existsb_1 : existsb (eqb 5) [0;2;3;6] = false.",
    "Statement":"Example test_existsb_1 : existsb (eqb 5) [0;2;3;6] = false",
    "Name":"test_existsb_1",
    "Dependencies":[
      "existsb",
      "cons",
      "nil",
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_existsb_2 : existsb (andb true) [true;true;false] = true.",
    "Statement":"Example test_existsb_2 : existsb (andb true) [true;true;false] = true",
    "Name":"test_existsb_2",
    "Dependencies":[
      "existsb",
      "cons",
      "nil",
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_existsb_3 : existsb odd [1;0;0;0;0;3] = true.",
    "Statement":"Example test_existsb_3 : existsb odd [1;0;0;0;0;3] = true",
    "Name":"test_existsb_3",
    "Dependencies":[
      "existsb",
      "cons",
      "nil",
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_existsb_4 : existsb even [] = false.",
    "Statement":"Example test_existsb_4 : existsb even [] = false",
    "Name":"test_existsb_4",
    "Dependencies":[
      "existsb",
      "nil",
      "even",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition existsb' {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Statement":"Definition existsb' {X : Type} (test : X -> bool) (l : list X) : bool",
    "Name":"existsb'",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem existsb_existsb' : forall (X : Type) (test : X -> bool) (l : list X),\n  existsb test l = existsb' test l.",
    "Statement":"Theorem existsb_existsb' : forall (X : Type) (test : X -> bool) (l : list X),\n  existsb test l = existsb' test l",
    "Name":"existsb_existsb'",
    "Dependencies":[
      "existsb'",
      "existsb",
      "list",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport LF.Tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (forall n m : nat, n + m = m + n) : Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck 2 = 2 : Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck 3 = 2 : Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck forall n : nat, n = 2 : Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_2_2_is_4 :\n  2 + 2 = 4.",
    "Statement":"Theorem plus_2_2_is_4 :\n  2 + 2 = 4",
    "Name":"plus_2_2_is_4",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition plus_claim : Prop := 2 + 2 = 4.",
    "Statement":"Definition plus_claim : Prop := 2 + 2 = 4",
    "Name":"plus_claim",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck plus_claim : Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_claim_is_true :\n  plus_claim.",
    "Statement":"Theorem plus_claim_is_true :\n  plus_claim",
    "Name":"plus_claim_is_true",
    "Dependencies":[
      "plus_claim"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition is_three (n : nat) : Prop :=\n  n = 3.",
    "Statement":"Definition is_three (n : nat) : Prop :=\n  n = 3",
    "Name":"is_three",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck is_three : nat -> Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y.",
    "Statement":"Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y",
    "Name":"injective",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma succ_inj : injective S.",
    "Statement":"Lemma succ_inj : injective S",
    "Name":"succ_inj",
    "Dependencies":[
      "injective"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros x y H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninjection H as H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck @eq : forall A : Type, A -> A -> Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample and_example : 3 + 4 = 7 \/\\ 2 * 2 = 4.",
    "Statement":"Example and_example : 3 + 4 = 7 \/\\ 2 * 2 = 4",
    "Name":"and_example",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck @conj : forall A B : Prop, A -> B -> A \/\\ B.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample and_example' : 3 + 4 = 7 \/\\ 2 * 2 = 4.",
    "Statement":"Example and_example' : 3 + 4 = 7 \/\\ 2 * 2 = 4",
    "Name":"and_example'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply conj.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 \/\\ m = 0.",
    "Statement":"Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 \/\\ m = 0",
    "Name":"plus_is_O",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma and_example2 :\n  forall n m : nat, n = 0 \/\\ m = 0 -> n + m = 0.",
    "Statement":"Lemma and_example2 :\n  forall n m : nat, n = 0 \/\\ m = 0 -> n + m = 0",
    "Name":"and_example2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n m H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct H as [Hn Hm].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite Hn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma and_example2' :\n  forall n m : nat, n = 0 \/\\ m = 0 -> n + m = 0.",
    "Statement":"Lemma and_example2' :\n  forall n m : nat, n = 0 \/\\ m = 0 -> n + m = 0",
    "Name":"and_example2'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m [Hn Hm].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite Hn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.",
    "Statement":"Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0",
    "Name":"and_example2''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m Hn Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite Hn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.",
    "Statement":"Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0",
    "Name":"and_example3",
    "Dependencies":[
      "plus_is_O"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n m H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply plus_is_O in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct H as [Hn Hm].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite Hn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma proj1 : forall P Q : Prop,\n  P \/\\ Q -> P.",
    "Statement":"Lemma proj1 : forall P Q : Prop,\n  P \/\\ Q -> P",
    "Name":"proj1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HPQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct HPQ as [HP _].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma proj2 : forall P Q : Prop,\n  P \/\\ Q -> Q.",
    "Statement":"Lemma proj2 : forall P Q : Prop,\n  P \/\\ Q -> Q",
    "Name":"proj2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem and_commut : forall P Q : Prop,\n  P \/\\ Q -> Q \/\\ P.",
    "Statement":"Theorem and_commut : forall P Q : Prop,\n  P \/\\ Q -> Q \/\\ P",
    "Name":"and_commut",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q [HP HQ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem and_assoc : forall P Q R : Prop,\n  P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R.",
    "Statement":"Theorem and_assoc : forall P Q R : Prop,\n  P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R",
    "Name":"and_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem and_assoc : forall P Q R : Prop,\n  P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R.",
    "Statement":"Theorem and_assoc : forall P Q R : Prop,\n  P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R",
    "Name":"and_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q R [HP [HQ HR]].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck and : Prop -> Prop -> Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma factor_is_O:\n  forall n m : nat, n = 0 \\\/ m = 0 -> n * m = 0.",
    "Statement":"Lemma factor_is_O:\n  forall n m : nat, n = 0 \\\/ m = 0 -> n * m = 0",
    "Name":"factor_is_O",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n m [Hn | Hm].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite Hn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- mult_n_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma or_intro_l : forall A B : Prop, A -> A \\\/ B.",
    "Statement":"Lemma or_intro_l : forall A B : Prop, A -> A \\\/ B",
    "Name":"or_intro_l",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A B HA.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply HA.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma zero_or_succ :\n  forall n : nat, n = 0 \\\/ n = S (pred n).",
    "Statement":"Lemma zero_or_succ :\n  forall n : nat, n = 0 \\\/ n = S (pred n)",
    "Name":"zero_or_succ",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros [|n'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\\/ m = 0.",
    "Statement":"Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\\/ m = 0",
    "Name":"mult_is_O",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem or_commut : forall P Q : Prop,\n  P \\\/ Q  -> Q \\\/ P.",
    "Statement":"Theorem or_commut : forall P Q : Prop,\n  P \\\/ Q  -> Q \\\/ P",
    "Name":"or_commut",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule NotPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition not (P:Prop) := P -> False.",
    "Statement":"Definition not (P:Prop) := P -> False",
    "Name":"not",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck not : Prop -> Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"~ x\" := (not x) : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd NotPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ex_falso_quodlibet : forall (P:Prop),\n  False -> P.",
    "Statement":"Theorem ex_falso_quodlibet : forall (P:Prop),\n  False -> P",
    "Name":"ex_falso_quodlibet",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros P contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem not_implies_our_not : forall (P:Prop),\n  ~ P -> (forall (Q:Prop), P -> Q).",
    "Statement":"Theorem not_implies_our_not : forall (P:Prop),\n  ~ P -> (forall (Q:Prop), P -> Q)",
    "Name":"not_implies_our_not",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x <> y\" := (~(x = y)) : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem zero_not_one : 0 <> 1.",
    "Statement":"Theorem zero_not_one : 0 <> 1",
    "Name":"zero_not_one",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  unfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  discriminate contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem not_False :\n  ~ False.",
    "Statement":"Theorem not_False :\n  ~ False",
    "Name":"not_False",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem contradiction_implies_anything : forall P Q : Prop,\n  (P \/\\ ~P) -> Q.",
    "Statement":"Theorem contradiction_implies_anything : forall P Q : Prop,\n  (P \/\\ ~P) -> Q",
    "Name":"contradiction_implies_anything",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem contradiction_implies_anything : forall P Q : Prop,\n  (P \/\\ ~P) -> Q.",
    "Statement":"Theorem contradiction_implies_anything : forall P Q : Prop,\n  (P \/\\ ~P) -> Q",
    "Name":"contradiction_implies_anything",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros P Q [HP HNP].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold not in HNP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply HNP in HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem double_neg : forall P : Prop,\n  P -> ~~P.",
    "Statement":"Theorem double_neg : forall P : Prop,\n  P -> ~~P",
    "Name":"double_neg",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem double_neg : forall P : Prop,\n  P -> ~~P.",
    "Statement":"Theorem double_neg : forall P : Prop,\n  P -> ~~P",
    "Name":"double_neg",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros P H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros G.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply G.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_double_neg_informal : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_double_neg_informal : option (nat*string) := None",
    "Name":"manual_grade_for_double_neg_informal",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem contrapositive : forall (P Q : Prop),\n  (P -> Q) -> (~Q -> ~P).",
    "Statement":"Theorem contrapositive : forall (P Q : Prop),\n  (P -> Q) -> (~Q -> ~P)",
    "Name":"contrapositive",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem not_both_true_and_false : forall P : Prop,\n  ~ (P \/\\ ~P).",
    "Statement":"Theorem not_both_true_and_false : forall P : Prop,\n  ~ (P \/\\ ~P)",
    "Name":"not_both_true_and_false",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_not_PNP_informal : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_not_PNP_informal : option (nat*string) := None",
    "Name":"manual_grade_for_not_PNP_informal",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem de_morgan_not_or : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q.",
    "Statement":"Theorem de_morgan_not_or : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q",
    "Name":"de_morgan_not_or",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem de_morgan_not_or : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q.",
    "Statement":"Theorem de_morgan_not_or : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q",
    "Name":"de_morgan_not_or",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).",
    "Statement":"Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n)",
    "Name":"not_S_pred_n",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem not_true_is_false : forall b : bool,\n  b <> true -> b = false.",
    "Statement":"Theorem not_true_is_false : forall b : bool,\n  b <> true -> b = false",
    "Name":"not_true_is_false",
    "Dependencies":[
      "ex_falso_quodlibet",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b eqn:HE.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    unfold not in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply ex_falso_quodlibet.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem not_true_is_false' : forall b : bool,\n  b <> true -> b = false.",
    "Statement":"Theorem not_true_is_false' : forall b : bool,\n  b <> true -> b = false",
    "Name":"not_true_is_false'",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros [] H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    unfold not in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    exfalso.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma True_is_true : True.",
    "Statement":"Lemma True_is_true : True",
    "Name":"True_is_true",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply I.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end.",
    "Statement":"Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end",
    "Name":"disc_fn",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem disc_example : forall n, ~ (O = S n).",
    "Statement":"Theorem disc_example : forall n, ~ (O = S n)",
    "Name":"disc_example",
    "Dependencies":[
      "disc_fn"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (H : disc_fn O).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n{",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply I.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite contra in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nil_is_not_cons : forall X (x : X) (xs : list X), ~ (nil = x :: xs).",
    "Statement":"Theorem nil_is_not_cons : forall X (x : X) (xs : list X), ~ (nil = x :: xs)",
    "Name":"nil_is_not_cons",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule IffPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition iff (P Q : Prop) := (P -> Q) \/\\ (Q -> P).",
    "Statement":"Definition iff (P Q : Prop) := (P -> Q) \/\\ (Q -> P)",
    "Name":"iff",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd IffPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem iff_sym : forall P Q : Prop,\n  (P <-> Q) -> (Q <-> P).",
    "Statement":"Theorem iff_sym : forall P Q : Prop,\n  (P <-> Q) -> (Q <-> P)",
    "Name":"iff_sym",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros P Q [HAB HBA].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply HBA.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply HAB.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma not_true_iff_false : forall b,\n  b <> true <-> b = false.",
    "Statement":"Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false",
    "Name":"not_true_iff_false",
    "Dependencies":[
      "not_true_is_false",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros b.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply not_true_is_false.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate H'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).",
    "Statement":"Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R)",
    "Name":"apply_iff_example1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q R Hiff H HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply Hiff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).",
    "Statement":"Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R)",
    "Name":"apply_iff_example2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q R Hiff H HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply Hiff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem iff_refl : forall P : Prop,\n  P <-> P.",
    "Statement":"Theorem iff_refl : forall P : Prop,\n  P <-> P",
    "Name":"iff_refl",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem iff_trans : forall P Q R : Prop,\n  (P <-> Q) -> (Q <-> R) -> (P <-> R).",
    "Statement":"Theorem iff_trans : forall P Q R : Prop,\n  (P <-> Q) -> (Q <-> R) -> (P <-> R)",
    "Name":"iff_trans",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem or_distributes_over_and : forall P Q R : Prop,\n  P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R).",
    "Statement":"Theorem or_distributes_over_and : forall P Q R : Prop,\n  P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)",
    "Name":"or_distributes_over_and",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem or_distributes_over_and : forall P Q R : Prop,\n  P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R).",
    "Statement":"Theorem or_distributes_over_and : forall P Q R : Prop,\n  P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)",
    "Name":"or_distributes_over_and",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Corelib.Setoids.Setoid.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\\/ m = 0.",
    "Statement":"Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\\/ m = 0",
    "Name":"mul_eq_0",
    "Dependencies":[
      "mult_is_O",
      "factor_is_O"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply mult_is_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply factor_is_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem or_assoc :\n  forall P Q R : Prop, P \\\/ (Q \\\/ R) <-> (P \\\/ Q) \\\/ R.",
    "Statement":"Theorem or_assoc :\n  forall P Q R : Prop, P \\\/ (Q \\\/ R) <-> (P \\\/ Q) \\\/ R",
    "Name":"or_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q R.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros [H | [H | H]].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nleft.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nright.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros [[H | H] | H].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nleft.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nright.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\\/ m = 0 \\\/ p = 0.",
    "Statement":"Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\\/ m = 0 \\\/ p = 0",
    "Name":"mul_eq_0_ternary",
    "Dependencies":[
      "or_assoc",
      "mul_eq_0"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m p.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite mul_eq_0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite mul_eq_0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite or_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition Even x := exists n : nat, x = double n.",
    "Statement":"Definition Even x := exists n : nat, x = double n",
    "Name":"Even",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck Even : nat -> Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma four_is_Even : Even 4.",
    "Statement":"Lemma four_is_Even : Even 4",
    "Name":"four_is_Even",
    "Dependencies":[
      "Even",
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold Even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nexists 2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem exists_example_2 : forall n,\n  (exists m, n = 4 + m) ->\n  (exists o, n = 2 + o).",
    "Statement":"Theorem exists_example_2 : forall n,\n  (exists m, n = 4 + m) ->\n  (exists o, n = 2 + o)",
    "Name":"exists_example_2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n [m Hm].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  exists (2 + m).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem dist_not_exists : forall (X:Type) (P : X -> Prop),\n  (forall x, P x) -> ~ (exists x, ~ P x).",
    "Statement":"Theorem dist_not_exists : forall (X:Type) (P : X -> Prop),\n  (forall x, P x) -> ~ (exists x, ~ P x)",
    "Name":"dist_not_exists",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),\n  (exists x, P x \\\/ Q x) <-> (exists x, P x) \\\/ (exists x, Q x).",
    "Statement":"Theorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),\n  (exists x, P x \\\/ Q x) <-> (exists x, P x) \\\/ (exists x, Q x)",
    "Name":"dist_exists_or",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem leb_plus_exists : forall n m, n <=? m = true -> exists x, m = n+x.",
    "Statement":"Theorem leb_plus_exists : forall n m, n <=? m = true -> exists x, m = n+x",
    "Name":"leb_plus_exists",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_exists_leb : forall n m, (exists x, m = n+x) -> n <=? m = true.",
    "Statement":"Theorem plus_exists_leb : forall n m, (exists x, m = n+x) -> n <=? m = true",
    "Name":"plus_exists_leb",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\\/ In x l'\n  end.",
    "Statement":"Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\\/ In x l'\n  end",
    "Name":"In",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\\/ In x l'\n  end.",
    "Statement":"Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\\/ In x l'\n  end",
    "Name":"In",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample In_example_1 : In 4 [1; 2; 3; 4; 5].",
    "Statement":"Example In_example_1 : In 4 [1; 2; 3; 4; 5]",
    "Name":"In_example_1",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nright.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nright.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nright.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nleft.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.",
    "Statement":"Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'",
    "Name":"In_example_2",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n [H | [H | []]].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n exists 1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n exists 2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In_map :\n  forall (A B : Type) (f : A -> B) (l : list A) (x : A),\n         In x l ->\n         In (f x) (map f l).",
    "Statement":"Theorem In_map :\n  forall (A B : Type) (f : A -> B) (l : list A) (x : A),\n         In x l ->\n         In (f x) (map f l)",
    "Name":"In_map",
    "Dependencies":[
      "map",
      "list_ind",
      "cons",
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A B f l x.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction l as [|x' l' IHl'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros [].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros [H | H].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nleft.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHl'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In_map_iff :\n  forall (A B : Type) (f : A -> B) (l : list A) (y : B),\n         In y (map f l) <->\n         exists x, f x = y \/\\ In x l.",
    "Statement":"Theorem In_map_iff :\n  forall (A B : Type) (f : A -> B) (l : list A) (y : B),\n         In y (map f l) <->\n         exists x, f x = y \/\\ In x l",
    "Name":"In_map_iff",
    "Dependencies":[
      "map",
      "list",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A B f l y.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n induction l as [|x l' IHl'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In_app_iff : forall A l l' (a:A),\n  In a (l++l') <-> In a l \\\/ In a l'.",
    "Statement":"Theorem In_app_iff : forall A l l' (a:A),\n  In a (l++l') <-> In a l \\\/ In a l'",
    "Name":"In_app_iff",
    "Dependencies":[
      "app",
      "list",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l as [|a' l' IH].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  .",
    "Statement":"Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop",
    "Name":"All",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem All_In :\n  forall T (P : T -> Prop) (l : list T),\n    (forall x, In x l -> P x) <->\n    All P l.",
    "Statement":"Theorem All_In :\n  forall T (P : T -> Prop) (l : list T),\n    (forall x, In x l -> P x) <->\n    All P l",
    "Name":"All_In",
    "Dependencies":[
      "list",
      "All",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  .",
    "Statement":"Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop",
    "Name":"combine_odd_even",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem combine_odd_even_intro :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    (odd n = true -> Podd n) ->\n    (odd n = false -> Peven n) ->\n    combine_odd_even Podd Peven n.",
    "Statement":"Theorem combine_odd_even_intro :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    (odd n = true -> Podd n) ->\n    (odd n = false -> Peven n) ->\n    combine_odd_even Podd Peven n",
    "Name":"combine_odd_even_intro",
    "Dependencies":[
      "combine_odd_even",
      "odd",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem combine_odd_even_elim_odd :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = true ->\n    Podd n.",
    "Statement":"Theorem combine_odd_even_elim_odd :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = true ->\n    Podd n",
    "Name":"combine_odd_even_elim_odd",
    "Dependencies":[
      "combine_odd_even",
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem combine_odd_even_elim_even :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = false ->\n    Peven n.",
    "Statement":"Theorem combine_odd_even_elim_even :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = false ->\n    Peven n",
    "Name":"combine_odd_even_elim_even",
    "Dependencies":[
      "combine_odd_even",
      "odd",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck plus : nat -> nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck plus : nat -> nat -> nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck @rev : forall X, list X -> list X.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck add_comm        : forall n m : nat, n + m = m + n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck plus_id_example : forall n m : nat, n = m -> n + n = m + m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.",
    "Statement":"Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x",
    "Name":"add_comm3_take2",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros x y z.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (H : y + z = z + y).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.",
    "Statement":"Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x",
    "Name":"add_comm3_take3",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros x y z.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite (add_comm y z).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.",
    "Statement":"Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x",
    "Name":"add_comm3_take4",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros x y z.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite (add_comm x (y + z)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite (add_comm y z).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem in_not_nil :\n  forall A (x : A) (l : list A), In x l -> l <> [].",
    "Statement":"Theorem in_not_nil :\n  forall A (x : A) (l : list A), In x l -> l <> []",
    "Name":"in_not_nil",
    "Dependencies":[
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A x l H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintro Hl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite Hl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Statement":"Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> []",
    "Name":"in_not_nil_42_take2",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply in_not_nil with (x := 42).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Statement":"Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> []",
    "Name":"in_not_nil_42_take3",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply in_not_nil in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Statement":"Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> []",
    "Name":"in_not_nil_42_take4",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (in_not_nil nat 42).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Statement":"Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> []",
    "Name":"in_not_nil_42_take5",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros l H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (in_not_nil _ _ _ H).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.",
    "Statement":"Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0",
    "Name":"lemma_application_ex",
    "Dependencies":[
      "map",
      "list",
      "In_map_iff",
      "In",
      "proj1",
      "mul_0_r"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n ns H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite mul_0_r in Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample even_42_bool : even 42 = true.",
    "Statement":"Example even_42_bool : even 42 = true",
    "Name":"even_42_bool",
    "Dependencies":[
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample even_42_prop : Even 42.",
    "Statement":"Example even_42_prop : Even 42",
    "Name":"even_42_prop",
    "Dependencies":[
      "Even",
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold Even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nexists 21.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma even_double : forall k, even (double k) = true.",
    "Statement":"Lemma even_double : forall k, even (double k) = true",
    "Name":"even_double",
    "Dependencies":[
      "double",
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros k.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction k as [|k' IHk'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHk'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).",
    "Statement":"Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k)",
    "Name":"even_double_conv",
    "Dependencies":[
      "double",
      "even",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem even_bool_prop : forall n,\n  even n = true <-> Even n.",
    "Statement":"Theorem even_bool_prop : forall n,\n  even n = true <-> Even n",
    "Name":"even_bool_prop",
    "Dependencies":[
      "even_double_conv",
      "even_double",
      "Even",
      "double",
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct (even_double_conv n) as [k Hk].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite Hk.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nexists k.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros [k Hk].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hk.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply even_double.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_eq : forall n1 n2 : nat,\n  n1 =? n2 = true <-> n1 = n2.",
    "Statement":"Theorem eqb_eq : forall n1 n2 : nat,\n  n1 =? n2 = true <-> n1 = n2",
    "Name":"eqb_eq",
    "Dependencies":[
      "eqb_true",
      "eqb_refl",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n1 n2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply eqb_true.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite eqb_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail\nDefinition is_even_prime n :=\n  if n = 2 then true\n  else false.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition is_even_prime n :=\n  if n =? 2 then true\n  else false.",
    "Statement":"Definition is_even_prime n :=\n  if n =? 2 then true\n  else false",
    "Name":"is_even_prime",
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample even_1000 : Even 1000.",
    "Statement":"Example even_1000 : Even 1000",
    "Name":"even_1000",
    "Dependencies":[
      "Even",
      "double"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold Even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nexists 500.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample even_1000' : even 1000 = true.",
    "Statement":"Example even_1000' : even 1000 = true",
    "Name":"even_1000'",
    "Dependencies":[
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample even_1000'' : Even 1000.",
    "Statement":"Example even_1000'' : Even 1000",
    "Name":"even_1000''",
    "Dependencies":[
      "even_bool_prop",
      "Even",
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply even_bool_prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample not_even_1001 : even 1001 = false.",
    "Statement":"Example not_even_1001 : even 1001 = false",
    "Name":"not_even_1001",
    "Dependencies":[
      "even",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample not_even_1001' : ~(Even 1001).",
    "Statement":"Example not_even_1001' : ~(Even 1001)",
    "Name":"not_even_1001'",
    "Dependencies":[
      "even_bool_prop",
      "Even",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  rewrite <- even_bool_prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intro H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.",
    "Statement":"Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true",
    "Name":"plus_eqb_example",
    "Dependencies":[
      "eqb_eq",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n m p H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite eqb_eq in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "eqb_true",
      "eqb_refl",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite eqb_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_true_iff : forall b1 b2:bool,\n  b1 && b2 = true <-> b1 = true \/\\ b2 = true.",
    "Statement":"Theorem andb_true_iff : forall b1 b2:bool,\n  b1 && b2 = true <-> b1 = true \/\\ b2 = true",
    "Name":"andb_true_iff",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem orb_true_iff : forall b1 b2,\n  b1 || b2 = true <-> b1 = true \\\/ b2 = true.",
    "Statement":"Theorem orb_true_iff : forall b1 b2,\n  b1 || b2 = true <-> b1 = true \\\/ b2 = true",
    "Name":"orb_true_iff",
    "Dependencies":[
      "orb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_neq : forall x y : nat,\n  x =? y = false <-> x <> y.",
    "Statement":"Theorem eqb_neq : forall x y : nat,\n  x =? y = false <-> x <> y",
    "Name":"eqb_neq",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  .",
    "Statement":"Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool",
    "Name":"eqb_list",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqb_list_true_iff :\n  forall A (eqb : A -> A -> bool),\n    (forall a1 a2, eqb a1 a2 = true <-> a1 = a2) ->\n    forall l1 l2, eqb_list eqb l1 l2 = true <-> l1 = l2.",
    "Statement":"Theorem eqb_list_true_iff :\n  forall A (eqb : A -> A -> bool),\n    (forall a1 a2, eqb a1 a2 = true <-> a1 = a2) ->\n    forall l1 l2, eqb_list eqb l1 l2 = true <-> l1 = l2",
    "Name":"eqb_list_true_iff",
    "Dependencies":[
      "list",
      "eqb_list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Statement":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool",
    "Name":"forallb",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Statement":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool",
    "Name":"forallb",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem forallb_true_iff : forall X test (l : list X),\n  forallb test l = true <-> All (fun x => test x = true) l.",
    "Statement":"Theorem forallb_true_iff : forall X test (l : list X),\n  forallb test l = true <-> All (fun x => test x = true) l",
    "Name":"forallb_true_iff",
    "Dependencies":[
      "list",
      "forallb",
      "All",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x).",
    "Statement":"Example function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x)",
    "Name":"function_equality_ex1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nAxiom functional_extensionality : forall {X Y: Type}\n                                    {f g : X -> Y},\n  (forall (x:X), f x = g x) -> f = g.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).",
    "Statement":"Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x)",
    "Name":"function_equality_ex2",
    "Dependencies":[
      "functional_extensionality",
      "add_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply functional_extensionality.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros x.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end.",
    "Statement":"Fixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end",
    "Name":"rev_append",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition tr_rev {X} (l : list X) : list X :=\n  rev_append l [].",
    "Statement":"Definition tr_rev {X} (l : list X) : list X :=\n  rev_append l []",
    "Name":"tr_rev",
    "Dependencies":[
      "nil",
      "list",
      "rev_append"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem tr_rev_correct : forall X, @tr_rev X = @rev X.",
    "Statement":"Theorem tr_rev_correct : forall X, @tr_rev X = @rev X",
    "Name":"tr_rev_correct",
    "Dependencies":[
      "rev",
      "list",
      "tr_rev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition excluded_middle := forall P : Prop,\n  P \\\/ ~ P.",
    "Statement":"Definition excluded_middle := forall P : Prop,\n  P \\\/ ~ P",
    "Name":"excluded_middle",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem restricted_excluded_middle : forall P b,\n  (P <-> b = true) -> P \\\/ ~ P.",
    "Statement":"Theorem restricted_excluded_middle : forall P b,\n  (P <-> b = true) -> P \\\/ ~ P",
    "Name":"restricted_excluded_middle",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P [] H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem restricted_excluded_middle_eq : forall (n m : nat),\n  n = m \\\/ n <> m.",
    "Statement":"Theorem restricted_excluded_middle_eq : forall (n m : nat),\n  n = m \\\/ n <> m",
    "Name":"restricted_excluded_middle_eq",
    "Dependencies":[
      "restricted_excluded_middle",
      "eqb_eq",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (restricted_excluded_middle (n = m) (n =? m)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  symmetry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eqb_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem excluded_middle_irrefutable: forall (P : Prop),\n  ~ ~ (P \\\/ ~ P).",
    "Statement":"Theorem excluded_middle_irrefutable: forall (P : Prop),\n  ~ ~ (P \\\/ ~ P)",
    "Name":"excluded_middle_irrefutable",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem not_exists_dist :\n  excluded_middle ->\n  forall (X:Type) (P : X -> Prop),\n    ~ (exists x, ~ P x) -> (forall x, P x).",
    "Statement":"Theorem not_exists_dist :\n  excluded_middle ->\n  forall (X:Type) (P : X -> Prop),\n    ~ (exists x, ~ P x) -> (forall x, P x)",
    "Name":"not_exists_dist",
    "Dependencies":[
      "excluded_middle"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition peirce := forall P Q: Prop,\n  ((P -> Q) -> P) -> P.",
    "Statement":"Definition peirce := forall P Q: Prop,\n  ((P -> Q) -> P) -> P",
    "Name":"peirce",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition double_negation_elimination := forall P:Prop,\n  ~~P -> P.",
    "Statement":"Definition double_negation_elimination := forall P:Prop,\n  ~~P -> P",
    "Name":"double_negation_elimination",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition de_morgan_not_and_not := forall P Q:Prop,\n  ~(~P \/\\ ~Q) -> P \\\/ Q.",
    "Statement":"Definition de_morgan_not_and_not := forall P Q:Prop,\n  ~(~P \/\\ ~Q) -> P \\\/ Q",
    "Name":"de_morgan_not_and_not",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition implies_to_or := forall P Q:Prop,\n  (P -> Q) -> (~P \\\/ Q).",
    "Statement":"Definition implies_to_or := forall P Q:Prop,\n  (P -> Q) -> (~P \\\/ Q)",
    "Name":"implies_to_or",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition consequentia_mirabilis := forall P:Prop,\n  (~P -> P) -> P.",
    "Statement":"Definition consequentia_mirabilis := forall P:Prop,\n  (~P -> P) -> P",
    "Name":"consequentia_mirabilis",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport LF.Logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end.",
    "Statement":"Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end",
    "Name":"div2",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1.",
    "Statement":"Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1",
    "Name":"csf",
    "Dependencies":[
      "div2",
      "even",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n.",
    "Statement":"Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n",
    "Name":"Collatz_holds_for",
    "Dependencies":[
      "div2",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample Collatz_holds_for_12 : Collatz_holds_for 12.",
    "Statement":"Example Collatz_holds_for_12 : Collatz_holds_for 12",
    "Name":"Collatz_holds_for_12",
    "Dependencies":[
      "Chf_odd",
      "Chf_even",
      "Chf_one",
      "Collatz_holds_for",
      "div2",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_odd.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_odd.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Chf_one.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nConjecture collatz : forall n, n <> 0 -> Collatz_holds_for n.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "Collatz_holds_for"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule LePlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m).",
    "Statement":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)",
    "Name":"le",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m).",
    "Statement":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m)",
    "Name":"le",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"n <= m\" := (le n m) (at level 70).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample le_3_5 : 3 <= 5.",
    "Statement":"Example le_3_5 : 3 <= 5",
    "Name":"le_3_5",
    "Dependencies":[
      "le_S",
      "le_n",
      "le"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LePlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z.",
    "Statement":"Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z",
    "Name":"clos_trans",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive Person : Type := Sage | Cleo | Ridley | Moss.",
    "Statement":"Inductive Person : Type := Sage | Cleo | Ridley | Moss",
    "Name":"Person",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss.",
    "Statement":"Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss",
    "Name":"parent_of",
    "Dependencies":[
      "Moss",
      "Ridley",
      "Cleo",
      "Sage"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of.",
    "Statement":"Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of",
    "Name":"ancestor_of",
    "Dependencies":[
      "parent_of",
      "Person",
      "clos_trans"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample ancestor_of_ex : ancestor_of Sage Moss.",
    "Statement":"Example ancestor_of_ex : ancestor_of Sage Moss",
    "Name":"ancestor_of_ex",
    "Dependencies":[
      "ancestor_of",
      "po_CM",
      "po_SC",
      "parent_of",
      "Moss",
      "Cleo",
      "Sage",
      "Person",
      "t_trans",
      "t_step"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold ancestor_of.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply t_trans with Cleo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply t_step.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply po_SC.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply t_step.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply po_CM.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z.",
    "Statement":"Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z",
    "Name":"clos_refl_trans",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z.",
    "Statement":"Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z",
    "Name":"clos_refl_trans",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition cs (n m : nat) : Prop := csf n = m.",
    "Statement":"Definition cs (n m : nat) : Prop := csf n = m",
    "Name":"cs",
    "Dependencies":[
      "csf"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition cms n m := clos_refl_trans cs n m.",
    "Statement":"Definition cms n m := clos_refl_trans cs n m",
    "Name":"cms",
    "Dependencies":[
      "cs",
      "clos_refl_trans"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nConjecture collatz' : forall n, n <> 0 -> cms n 1.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cms"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Statement":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3",
    "Name":"Perm3",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Statement":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3",
    "Name":"Perm3",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_0 : ev 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_0 : ev 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_0 : ev 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export EvPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd EvPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4 : ev 4.",
    "Statement":"Theorem ev_4 : ev 4",
    "Name":"ev_4",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4 : ev 4.",
    "Statement":"Theorem ev_4 : ev 4",
    "Name":"ev_4",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4' : ev 4.",
    "Statement":"Theorem ev_4' : ev 4",
    "Name":"ev_4'",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4' : ev 4.",
    "Statement":"Theorem ev_4' : ev 4",
    "Name":"ev_4'",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply (ev_SS 2 (ev_SS 0 ev_0)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Statement":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n)",
    "Name":"ev_plus4",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Statement":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n)",
    "Name":"ev_plus4",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros Hn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply Hn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_double : forall n,\n  ev (double n).",
    "Statement":"Theorem ev_double : forall n,\n  ev (double n)",
    "Name":"ev_double",
    "Dependencies":[
      "double",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma Perm3_rev : Perm3 [1;2;3] [3;2;1].",
    "Statement":"Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1]",
    "Name":"Perm3_rev",
    "Dependencies":[
      "cons",
      "nil",
      "perm3_trans",
      "perm3_swap23",
      "perm3_swap12",
      "Perm3"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply perm3_trans with (l2:=[2;3;1]).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply perm3_trans with (l2:=[2;3;1]).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply perm3_trans with (l2:=[2;1;3]).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n apply perm3_trans with (l2:=[2;1;3]).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply perm3_swap12.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply perm3_swap23.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply perm3_swap12.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].",
    "Statement":"Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1]",
    "Name":"Perm3_rev'",
    "Dependencies":[
      "cons",
      "nil",
      "perm3_trans",
      "perm3_swap23",
      "perm3_swap12",
      "Perm3"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].",
    "Statement":"Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1]",
    "Name":"Perm3_ex1",
    "Dependencies":[
      "cons",
      "nil",
      "Perm3"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].",
    "Statement":"Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c]",
    "Name":"Perm3_refl",
    "Dependencies":[
      "cons",
      "nil",
      "Perm3"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_inversion : forall (n : nat),\n    ev n ->\n    (n = 0) \\\/ (exists n', n = S (S n') \/\\ ev n').",
    "Statement":"Theorem ev_inversion : forall (n : nat),\n    ev n ->\n    (n = 0) \\\/ (exists n', n = S (S n') \/\\ ev n')",
    "Name":"ev_inversion",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct E as [ | n' E'] eqn:EE.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nexists n'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply E'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_inversion : forall (n m : nat),\n  le n m ->\n  (n = m) \\\/ (exists m', m = S m' \/\\ le n m').",
    "Statement":"Theorem le_inversion : forall (n m : nat),\n  le n m ->\n  (n = m) \\\/ (exists m', m = S m' \/\\ le n m')",
    "Name":"le_inversion",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem evSS_ev : forall n, ev (S (S n)) -> ev n.",
    "Statement":"Theorem evSS_ev : forall n, ev (S (S n)) -> ev n",
    "Name":"evSS_ev",
    "Dependencies":[
      "ev_inversion",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_inversion in E.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct E as [H0|H1].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n discriminate H0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct H1 as [n' [Hnn' E']].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninjection Hnn' as Hnn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite Hnn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply E'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem evSS_ev' : forall n,\n  ev (S (S n)) -> ev n.",
    "Statement":"Theorem evSS_ev' : forall n,\n  ev (S (S n)) -> ev n",
    "Name":"evSS_ev'",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion E as [| n' E' Hnn'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply E'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem one_not_even : ~ ev 1.",
    "Statement":"Theorem one_not_even : ~ ev 1",
    "Name":"one_not_even",
    "Dependencies":[
      "ev_inversion",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_inversion in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct H as [ | [m [Hm _]]].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n discriminate H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n discriminate Hm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem one_not_even' : ~ ev 1.",
    "Statement":"Theorem one_not_even' : ~ ev 1",
    "Name":"one_not_even'",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem SSSSev__even : forall n,\n  ev (S (S (S (S n)))) -> ev n.",
    "Statement":"Theorem SSSSev__even : forall n,\n  ev (S (S (S (S n)))) -> ev n",
    "Name":"SSSSev__even",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev5_nonsense :\n  ev 5 -> 2 + 2 = 9.",
    "Statement":"Theorem ev5_nonsense :\n  ev 5 -> 2 + 2 = 9",
    "Name":"ev5_nonsense",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem inversion_ex1 : forall (n m o : nat),\n  [n; m] = [o; o] -> [n] = [m].",
    "Statement":"Theorem inversion_ex1 : forall (n m o : nat),\n  [n; m] = [o; o] -> [n] = [m]",
    "Name":"inversion_ex1",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem inversion_ex2 : forall (n : nat),\n  S n = O -> 2 + 2 = 5.",
    "Statement":"Theorem inversion_ex2 : forall (n : nat),\n  S n = O -> 2 + 2 = 5",
    "Name":"inversion_ex2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma ev_Even : forall n,\n  ev n -> Even n.",
    "Statement":"Lemma ev_Even : forall n,\n  ev n -> Even n",
    "Name":"ev_Even",
    "Dependencies":[
      "Even",
      "double",
      "ev_ind",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold Even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction E as [|n' E' IH].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    exists 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct IH as [k Hk].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hk.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    exists (S k).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_Even_iff : forall n,\n  ev n <-> Even n.",
    "Statement":"Theorem ev_Even_iff : forall n,\n  ev n <-> Even n",
    "Name":"ev_Even_iff",
    "Dependencies":[
      "Even",
      "double",
      "ev_Even",
      "ev_double",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_Even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold Even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros [k Hk].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hk.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_double.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_sum : forall n m, ev n -> ev m -> ev (n + m).",
    "Statement":"Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m)",
    "Name":"ev_sum",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_ev__ev : forall n m,\n  ev (n+m) -> ev n -> ev m.",
    "Statement":"Theorem ev_ev__ev : forall n m,\n  ev (n+m) -> ev n -> ev m",
    "Name":"ev_ev__ev",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_plus_plus : forall n m p,\n  ev (n+m) -> ev (n+p) -> ev (m+p).",
    "Statement":"Theorem ev_plus_plus : forall n m p,\n  ev (n+m) -> ev (n+p) -> ev (m+p)",
    "Name":"ev_plus_plus",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Statement":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)",
    "Name":"ev'",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Statement":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)",
    "Name":"ev'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev'_ev : forall n, ev' n <-> ev n.",
    "Statement":"Theorem ev'_ev : forall n, ev' n <-> ev n",
    "Name":"ev'_ev",
    "Dependencies":[
      "ev'",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export Perm3Reminder.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Statement":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3",
    "Name":"Perm3",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Statement":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3",
    "Name":"Perm3",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Perm3Reminder.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.",
    "Statement":"Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1",
    "Name":"Perm3_symm",
    "Dependencies":[
      "list",
      "Perm3_ind",
      "perm3_trans",
      "perm3_swap23",
      "perm3_swap12",
      "Perm3"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros X l1 l2 E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply perm3_swap12.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply perm3_swap23.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply (perm3_trans _ l2 _).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH23.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH12.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.",
    "Statement":"Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2",
    "Name":"Perm3_In",
    "Dependencies":[
      "list",
      "Perm3",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.",
    "Statement":"Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2",
    "Name":"Perm3_NotIn",
    "Dependencies":[
      "list",
      "Perm3",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].",
    "Statement":"Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4]",
    "Name":"Perm3_example2",
    "Dependencies":[
      "cons",
      "nil",
      "Perm3"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Playground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m).",
    "Statement":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)",
    "Name":"le",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m).",
    "Statement":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m)",
    "Name":"le",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"n <= m\" := (le n m).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem test_le1 :\n  3 <= 3.",
    "Statement":"Theorem test_le1 :\n  3 <= 3",
    "Name":"test_le1",
    "Dependencies":[
      "le_n",
      "le"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem test_le2 :\n  3 <= 6.",
    "Statement":"Theorem test_le2 :\n  3 <= 6",
    "Name":"test_le2",
    "Dependencies":[
      "le_S",
      "le_n",
      "le"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem test_le3 :\n  (2 <= 1) -> 2 + 2 = 5.",
    "Statement":"Theorem test_le3 :\n  (2 <= 1) -> 2 + 2 = 5",
    "Name":"test_le3",
    "Dependencies":[
      "le"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition lt (n m : nat) := le (S n) m.",
    "Statement":"Definition lt (n m : nat) := le (S n) m",
    "Name":"lt",
    "Dependencies":[
      "le"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"n < m\" := (lt n m).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ge (m n : nat) : Prop := le n m.",
    "Statement":"Definition ge (m n : nat) : Prop := le n m",
    "Name":"ge",
    "Dependencies":[
      "le"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"m >= n\" := (ge m n).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Playground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.",
    "Statement":"Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o",
    "Name":"le_trans",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.",
    "Statement":"Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o",
    "Name":"le_trans",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem O_le_n : forall n,\n  0 <= n.",
    "Statement":"Theorem O_le_n : forall n,\n  0 <= n",
    "Name":"O_le_n",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem n_le_m__Sn_le_Sm : forall n m,\n  n <= m -> S n <= S m.",
    "Statement":"Theorem n_le_m__Sn_le_Sm : forall n m,\n  n <= m -> S n <= S m",
    "Name":"n_le_m__Sn_le_Sm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem Sn_le_Sm__n_le_m : forall n m,\n  S n <= S m -> n <= m.",
    "Statement":"Theorem Sn_le_Sm__n_le_m : forall n m,\n  S n <= S m -> n <= m",
    "Name":"Sn_le_Sm__n_le_m",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_plus_l : forall a b,\n  a <= a + b.",
    "Statement":"Theorem le_plus_l : forall a b,\n  a <= a + b",
    "Name":"le_plus_l",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_le : forall n1 n2 m,\n  n1 + n2 <= m ->\n  n1 <= m \/\\ n2 <= m.",
    "Statement":"Theorem plus_le : forall n1 n2 m,\n  n1 + n2 <= m ->\n  n1 <= m \/\\ n2 <= m",
    "Name":"plus_le",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_le_cases : forall n m p q,\n  n + m <= p + q -> n <= p \\\/ m <= q.",
    "Statement":"Theorem plus_le_cases : forall n m p q,\n  n + m <= p + q -> n <= p \\\/ m <= q",
    "Name":"plus_le_cases",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_le_compat_l : forall n m p,\n  n <= m ->\n  p + n <= p + m.",
    "Statement":"Theorem plus_le_compat_l : forall n m p,\n  n <= m ->\n  p + n <= p + m",
    "Name":"plus_le_compat_l",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_le_compat_r : forall n m p,\n  n <= m ->\n  n + p <= m + p.",
    "Statement":"Theorem plus_le_compat_r : forall n m p,\n  n <= m ->\n  n + p <= m + p",
    "Name":"plus_le_compat_r",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_plus_trans : forall n m p,\n  n <= m ->\n  n <= m + p.",
    "Statement":"Theorem le_plus_trans : forall n m p,\n  n <= m ->\n  n <= m + p",
    "Name":"le_plus_trans",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lt_ge_cases : forall n m,\n  n < m \\\/ n >= m.",
    "Statement":"Theorem lt_ge_cases : forall n m,\n  n < m \\\/ n >= m",
    "Name":"lt_ge_cases",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem n_lt_m__n_le_m : forall n m,\n  n < m ->\n  n <= m.",
    "Statement":"Theorem n_lt_m__n_le_m : forall n m,\n  n < m ->\n  n <= m",
    "Name":"n_lt_m__n_le_m",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_lt : forall n1 n2 m,\n  n1 + n2 < m ->\n  n1 < m \/\\ n2 < m.",
    "Statement":"Theorem plus_lt : forall n1 n2 m,\n  n1 + n2 < m ->\n  n1 < m \/\\ n2 < m",
    "Name":"plus_lt",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem leb_complete : forall n m,\n  n <=? m = true -> n <= m.",
    "Statement":"Theorem leb_complete : forall n m,\n  n <=? m = true -> n <= m",
    "Name":"leb_complete",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem leb_correct : forall n m,\n  n <= m ->\n  n <=? m = true.",
    "Statement":"Theorem leb_correct : forall n m,\n  n <= m ->\n  n <=? m = true",
    "Name":"leb_correct",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem leb_iff : forall n m,\n  n <=? m = true <-> n <= m.",
    "Statement":"Theorem leb_iff : forall n m,\n  n <=? m = true <-> n <= m",
    "Name":"leb_iff",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem leb_true_trans : forall n m o,\n  n <=? m = true -> m <=? o = true -> n <=? o = true.",
    "Statement":"Theorem leb_true_trans : forall n m o,\n  n <=? m = true -> m <=? o = true -> n <=? o = true",
    "Name":"leb_true_trans",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n.",
    "Statement":"Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o",
    "Name":"R",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_R_provability : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_R_provability : option (nat*string) := None",
    "Name":"manual_grade_for_R_provability",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fR : nat -> nat -> nat\n  .",
    "Statement":"Definition fR : nat -> nat -> nat",
    "Name":"fR",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem R_equiv_fR : forall m n o, R m n o <-> fR m n = o.",
    "Statement":"Theorem R_equiv_fR : forall m n o, R m n o <-> fR m n = o",
    "Name":"R_equiv_fR",
    "Dependencies":[
      "fR",
      "R"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive subseq : list nat -> list nat -> Prop :=\n\n.",
    "Statement":"Inductive subseq : list nat -> list nat -> Prop :=",
    "Name":"subseq",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem subseq_refl : forall (l : list nat), subseq l l.",
    "Statement":"Theorem subseq_refl : forall (l : list nat), subseq l l",
    "Name":"subseq_refl",
    "Dependencies":[
      "list",
      "subseq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem subseq_app : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l1 (l2 ++ l3).",
    "Statement":"Theorem subseq_app : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l1 (l2 ++ l3)",
    "Name":"subseq_app",
    "Dependencies":[
      "app",
      "list",
      "subseq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem subseq_trans : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l2 l3 ->\n  subseq l1 l3.",
    "Statement":"Theorem subseq_trans : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l2 l3 ->\n  subseq l1 l3",
    "Name":"subseq_trans",
    "Dependencies":[
      "list",
      "subseq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T).",
    "Statement":"Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T)",
    "Name":"reg_exp",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments EmptySet {T}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments EmptyStr {T}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments Char {T} _.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments App {T} _ _.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments Union {T} _ _.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments Star {T} _.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation \"s =~ re\" (at level 80).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)\n\n  where \"s =~ re\" := (exp_match s re).",
    "Statement":"Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)\n\n  where \"s =~ re\" := (exp_match s re)",
    "Name":"exp_match",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample reg_exp_ex1 : [1] =~ Char 1.",
    "Statement":"Example reg_exp_ex1 : [1] =~ Char 1",
    "Name":"reg_exp_ex1",
    "Dependencies":[
      "cons",
      "nil",
      "MChar",
      "exp_match",
      "Char"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).",
    "Statement":"Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2)",
    "Name":"reg_exp_ex2",
    "Dependencies":[
      "cons",
      "nil",
      "MApp",
      "MChar",
      "exp_match",
      "App",
      "Char"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (MApp [1]).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample reg_exp_ex3 : ~ ([1; 2] =~ Char 1).",
    "Statement":"Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1)",
    "Name":"reg_exp_ex3",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end.",
    "Statement":"Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end",
    "Name":"reg_exp_of_list",
    "Dependencies":[
      "list",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].",
    "Statement":"Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3]",
    "Name":"reg_exp_ex4",
    "Dependencies":[
      "cons",
      "nil",
      "reg_exp_of_list",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "App",
      "Char",
      "EmptyStr"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply (MApp [1]).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (MApp [2]).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (MApp [3]).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.",
    "Statement":"Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re",
    "Name":"MStar1",
    "Dependencies":[
      "app_nil_r",
      "app",
      "nil",
      "list",
      "MStarApp",
      "MStar0",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T s re H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite <- (app_nil_r _ s).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MStarApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).",
    "Statement":"Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet)",
    "Name":"EmptySet_is_empty",
    "Dependencies":[
      "list",
      "exp_match",
      "EmptySet"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\\/ s =~ re2 ->\n  s =~ Union re1 re2.",
    "Statement":"Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\\/ s =~ re2 ->\n  s =~ Union re1 re2",
    "Name":"MUnion'",
    "Dependencies":[
      "list",
      "exp_match",
      "Union",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.",
    "Statement":"Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re",
    "Name":"MStar'",
    "Dependencies":[
      "fold",
      "app",
      "nil",
      "list",
      "In",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition EmptyStr' {T:Type} := @Star T (EmptySet).",
    "Statement":"Definition EmptyStr' {T:Type} := @Star T (EmptySet)",
    "Name":"EmptyStr'",
    "Dependencies":[
      "Star",
      "EmptySet",
      "reg_exp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end.",
    "Statement":"Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end",
    "Name":"re_chars",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem in_re_match : forall T (s : list T) (re : reg_exp T) (x : T),\n  s =~ re ->\n  In x s ->\n  In x (re_chars re).",
    "Statement":"Theorem in_re_match : forall T (s : list T) (re : reg_exp T) (x : T),\n  s =~ re ->\n  In x s ->\n  In x (re_chars re)",
    "Name":"in_re_match",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "In_app_iff",
      "In",
      "re_chars",
      "exp_match_ind",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T s re x Hmatch Hin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction Hmatch\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl in Hin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct Hin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in Hin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply Hin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite In_app_iff in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "app",
      "list",
      "In"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct Hin as [Hin | Hin].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply (IH1 Hin).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply (IH2 Hin).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite In_app_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply (IH Hin).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite In_app_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply (IH Hin).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct Hin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite In_app_iff in Hin.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "app",
      "list",
      "In"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct Hin as [Hin | Hin].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply (IH1 Hin).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply (IH2 Hin).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  .",
    "Statement":"Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool",
    "Name":"re_not_empty",
    "Dependencies":[
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.",
    "Statement":"Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true",
    "Name":"re_not_empty_correct",
    "Dependencies":[
      "list",
      "re_not_empty",
      "exp_match",
      "reg_exp",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.",
    "Statement":"Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re",
    "Name":"star_app",
    "Dependencies":[
      "app_assoc",
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T s1 s2 re H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  remember (Star re) as re' eqn:Eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   discriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    discriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     discriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- app_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply MStarApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply Hmatch1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply Eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    \/\\ forall s', In s' ss -> s' =~ re.",
    "Statement":"Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    \/\\ forall s', In s' ss -> s' =~ re",
    "Name":"MStar''",
    "Dependencies":[
      "fold",
      "app",
      "nil",
      "list",
      "In",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export Pumping.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end.",
    "Statement":"Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end",
    "Name":"pumping_constant",
    "Dependencies":[
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.",
    "Statement":"Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1",
    "Name":"pumping_constant_ge_1",
    "Dependencies":[
      "pumping_constant",
      "reg_exp_ind",
      "Star",
      "Union",
      "App",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "le_plus_l",
      "le_trans"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction re.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply le_trans with (n:=pumping_constant re1).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply le_trans with (n:=pumping_constant re1).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply IHre1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_plus_l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply le_trans with (n:=pumping_constant re1).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply le_trans with (n:=pumping_constant re1).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply IHre1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_plus_l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHre.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.",
    "Statement":"Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False",
    "Name":"pumping_constant_0_false",
    "Dependencies":[
      "pumping_constant_ge_1",
      "pumping_constant",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (Hp1 : pumping_constant re >= 1).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply pumping_constant_ge_1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite H in Hp1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion Hp1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end.",
    "Statement":"Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end",
    "Name":"napp",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.",
    "Statement":"Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l",
    "Name":"napp_plus",
    "Dependencies":[
      "napp",
      "app_assoc",
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T n m l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction n as [|n IHn].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHn, app_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.",
    "Statement":"Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re",
    "Name":"napp_star",
    "Dependencies":[
      "napp",
      "app_assoc",
      "app",
      "list",
      "MStarApp",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T m s1 s2 re Hs1 Hs2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply Hs2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- app_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply MStarApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply Hs1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IHm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"weak_pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"weak_pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re s Hmatch.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    length s1 + length s2 <= pumping_constant re \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    length s1 + length s2 <= pumping_constant re \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    length s1 + length s2 <= pumping_constant re \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    length s1 + length s2 <= pumping_constant re \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re s Hmatch.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Pumping.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem filter_not_empty_In : forall n l,\n  filter (fun x => n =? x) l <> [] -> In n l.",
    "Statement":"Theorem filter_not_empty_In : forall n l,\n  filter (fun x => n =? x) l <> [] -> In n l",
    "Name":"filter_not_empty_In",
    "Dependencies":[
      "filter",
      "list_ind",
      "cons",
      "nil",
      "list",
      "eqb_eq",
      "In",
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l as [|m l' IHl'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct (n =? m) eqn:H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      intros _.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite eqb_eq in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "eqb_true",
      "eqb_refl",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      intros H'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nright.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHl'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false.",
    "Statement":"Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false",
    "Name":"reflect",
    "Dependencies":[
      "pair",
      "prod",
      "t_branch",
      "t_leaf",
      "t_tree"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false.",
    "Statement":"Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false",
    "Name":"reflect",
    "Dependencies":[
      "false",
      "true"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem iff_reflect : forall P b, (P <-> b = true) -> reflect P b.",
    "Statement":"Theorem iff_reflect : forall P b, (P <-> b = true) -> reflect P b",
    "Name":"iff_reflect",
    "Dependencies":[
      "ReflectF",
      "ReflectT",
      "reflect",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros P b H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b eqn:Eb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply ReflectT.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply ReflectF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem reflect_iff : forall P b, reflect P b -> (P <-> b = true).",
    "Statement":"Theorem reflect_iff : forall P b, reflect P b -> (P <-> b = true)",
    "Name":"reflect_iff",
    "Dependencies":[
      "reflect",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma eqbP : forall n m, reflect (n = m) (n =? m).",
    "Statement":"Lemma eqbP : forall n m, reflect (n = m) (n =? m)",
    "Name":"eqbP",
    "Dependencies":[
      "eqb_eq",
      "iff_reflect",
      "reflect",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply iff_reflect.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite eqb_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem filter_not_empty_In' : forall n l,\n  filter (fun x => n =? x) l <> [] ->\n  In n l.",
    "Statement":"Theorem filter_not_empty_In' : forall n l,\n  filter (fun x => n =? x) l <> [] ->\n  In n l",
    "Name":"filter_not_empty_In'",
    "Dependencies":[
      "filter",
      "list_ind",
      "cons",
      "nil",
      "list",
      "In",
      "eqbP",
      "reflect",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l as [|m l' IHl'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct (eqbP n m) as [EQnm | NEQnm].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      intros _.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite EQnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nleft.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      intros H'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nright.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHl'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end.",
    "Statement":"Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end",
    "Name":"count",
    "Dependencies":[
      "list",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end.",
    "Statement":"Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end",
    "Name":"count",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eqbP_practice : forall n l,\n  count n l = 0 -> ~(In n l).",
    "Statement":"Theorem eqbP_practice : forall n l,\n  count n l = 0 -> ~(In n l)",
    "Name":"eqbP_practice",
    "Dependencies":[
      "list",
      "In",
      "count"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n l Hcount.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l as [| m l' IHl'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive nostutter {X:Type} : list X -> Prop :=\n\n.",
    "Statement":"Inductive nostutter {X:Type} : list X -> Prop :=",
    "Name":"nostutter",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nostutter_1: nostutter [3;1;4;1;5;6].",
    "Statement":"Example test_nostutter_1: nostutter [3;1;4;1;5;6]",
    "Name":"test_nostutter_1",
    "Dependencies":[
      "cons",
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nostutter_2:  nostutter (@nil nat).",
    "Statement":"Example test_nostutter_2:  nostutter (@nil nat)",
    "Name":"test_nostutter_2",
    "Dependencies":[
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nostutter_3:  nostutter [5].",
    "Statement":"Example test_nostutter_3:  nostutter [5]",
    "Name":"test_nostutter_3",
    "Dependencies":[
      "cons",
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_nostutter_4:      not (nostutter [3;1;1;4]).",
    "Statement":"Example test_nostutter_4:      not (nostutter [3;1;1;4])",
    "Name":"test_nostutter_4",
    "Dependencies":[
      "cons",
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_nostutter : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_nostutter : option (nat*string) := None",
    "Name":"manual_grade_for_nostutter",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive merge {X:Type} : list X -> list X -> list X -> Prop :=\n\n.",
    "Statement":"Inductive merge {X:Type} : list X -> list X -> list X -> Prop :=",
    "Name":"merge",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem merge_filter : forall (X : Set) (test: X->bool) (l l1 l2 : list X),\n  merge l1 l2 l ->\n  All (fun n => test n = true) l1 ->\n  All (fun n => test n = false) l2 ->\n  filter test l = l1.",
    "Statement":"Theorem merge_filter : forall (X : Set) (test: X->bool) (l l1 l2 : list X),\n  merge l1 l2 l ->\n  All (fun n => test n = true) l1 ->\n  All (fun n => test n = false) l2 ->\n  filter test l = l1",
    "Name":"merge_filter",
    "Dependencies":[
      "filter",
      "list",
      "All",
      "merge",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive pal {X:Type} : list X -> Prop :=\n\n.",
    "Statement":"Inductive pal {X:Type} : list X -> Prop :=",
    "Name":"pal",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem pal_app_rev : forall (X:Type) (l : list X),\n  pal (l ++ (rev l)).",
    "Statement":"Theorem pal_app_rev : forall (X:Type) (l : list X),\n  pal (l ++ (rev l))",
    "Name":"pal_app_rev",
    "Dependencies":[
      "rev",
      "app",
      "list",
      "pal"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem pal_rev : forall (X:Type) (l: list X) , pal l -> l = rev l.",
    "Statement":"Theorem pal_rev : forall (X:Type) (l: list X) , pal l -> l = rev l",
    "Name":"pal_rev",
    "Dependencies":[
      "rev",
      "list",
      "pal"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem palindrome_converse: forall {X: Type} (l: list X),\n    l = rev l -> pal l.",
    "Statement":"Theorem palindrome_converse: forall {X: Type} (l: list X),\n    l = rev l -> pal l",
    "Name":"palindrome_converse",
    "Dependencies":[
      "rev",
      "list",
      "pal"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule RecallIn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n   Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\\/ In A x l'\n     end.",
    "Statement":"Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\\/ In A x l'\n     end",
    "Name":"In",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n   Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\\/ In A x l'\n     end.",
    "Statement":"Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\\/ In A x l'\n     end",
    "Name":"In",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nEnd RecallIn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_NoDup_disjoint_etc : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_NoDup_disjoint_etc : option (nat*string) := None",
    "Name":"manual_grade_for_NoDup_disjoint_etc",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma in_split : forall (X:Type) (x:X) (l:list X),\n  In x l ->\n  exists l1 l2, l = l1 ++ x :: l2.",
    "Statement":"Lemma in_split : forall (X:Type) (x:X) (l:list X),\n  In x l ->\n  exists l1 l2, l = l1 ++ x :: l2",
    "Name":"in_split",
    "Dependencies":[
      "app",
      "cons",
      "list",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive repeats {X:Type} : list X -> Prop :=\n\n.",
    "Statement":"Inductive repeats {X:Type} : list X -> Prop :=",
    "Name":"repeats",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_check_repeats : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_check_repeats : option (nat*string) := None",
    "Name":"manual_grade_for_check_repeats",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem pigeonhole_principle: excluded_middle ->\n  forall (X:Type) (l1  l2:list X),\n  (forall x, In x l1 -> In x l2) ->\n  length l2 < length l1 ->\n  repeats l1.",
    "Statement":"Theorem pigeonhole_principle: excluded_middle ->\n  forall (X:Type) (l1  l2:list X),\n  (forall x, In x l1 -> In x l2) ->\n  length l2 < length l1 ->\n  repeats l1",
    "Name":"pigeonhole_principle",
    "Dependencies":[
      "length",
      "list",
      "excluded_middle",
      "In",
      "repeats"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros EM X l1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction l1 as [|x l1' IHl1'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Coq.Strings.Ascii.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition string := list ascii.",
    "Statement":"Definition string := list ascii",
    "Name":"string",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma provable_equiv_true : forall (P : Prop), P -> (P <-> True).",
    "Statement":"Lemma provable_equiv_true : forall (P : Prop), P -> (P <-> True)",
    "Name":"provable_equiv_true",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nconstructor.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros _.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma not_equiv_false : forall (P : Prop), ~P -> (P <-> False).",
    "Statement":"Lemma not_equiv_false : forall (P : Prop), ~P -> (P <-> False)",
    "Name":"not_equiv_false",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma null_matches_none : forall (s : string), (s =~ EmptySet) <-> False.",
    "Statement":"Lemma null_matches_none : forall (s : string), (s =~ EmptySet) <-> False",
    "Name":"null_matches_none",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "not_equiv_false",
      "string",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply not_equiv_false.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma empty_matches_eps : forall (s : string), s =~ EmptyStr <-> s = [ ].",
    "Statement":"Lemma empty_matches_eps : forall (s : string), s =~ EmptyStr <-> s = [ ]",
    "Name":"empty_matches_eps",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "string",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma empty_nomatch_ne : forall (a : ascii) s, (a :: s =~ EmptyStr) <-> False.",
    "Statement":"Lemma empty_nomatch_ne : forall (a : ascii) s, (a :: s =~ EmptyStr) <-> False",
    "Name":"empty_nomatch_ne",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "not_equiv_false",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply not_equiv_false.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma char_nomatch_char :\n  forall (a b : ascii) s, b <> a -> (b :: s =~ Char a <-> False).",
    "Statement":"Lemma char_nomatch_char :\n  forall (a b : ascii) s, b <> a -> (b :: s =~ Char a <-> False)",
    "Name":"char_nomatch_char",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "not_equiv_false",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply not_equiv_false.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  inversion H0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma char_eps_suffix : forall (a : ascii) s, a :: s =~ Char a <-> s = [ ].",
    "Statement":"Lemma char_eps_suffix : forall (a : ascii) s, a :: s =~ Char a <-> s = [ ]",
    "Name":"char_eps_suffix",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "MChar",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma app_exists : forall (s : string) re0 re1,\n  s =~ App re0 re1 <->\n  exists s0 s1, s = s0 ++ s1 \/\\ s0 =~ re0 \/\\ s1 =~ re1.",
    "Statement":"Lemma app_exists : forall (s : string) re0 re1,\n  s =~ App re0 re1 <->\n  exists s0 s1, s = s0 ++ s1 \/\\ s0 =~ re0 \/\\ s1 =~ re1",
    "Name":"app_exists",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "string",
      "MApp",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nexists s1, s2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros [ s0 [ s1 [ Happ [ Hmat0 Hmat1 ] ] ] ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite Happ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply (MApp s0 _ s1 _ Hmat0 Hmat1).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma app_ne : forall (a : ascii) s re0 re1,\n  a :: s =~ (App re0 re1) <->\n  ([ ] =~ re0 \/\\ a :: s =~ re1) \\\/\n  exists s0 s1, s = s0 ++ s1 \/\\ a :: s0 =~ re0 \/\\ s1 =~ re1.",
    "Statement":"Lemma app_ne : forall (a : ascii) s re0 re1,\n  a :: s =~ (App re0 re1) <->\n  ([ ] =~ re0 \/\\ a :: s =~ re1) \\\/\n  exists s0 s1, s = s0 ++ s1 \/\\ a :: s0 =~ re0 \/\\ s1 =~ re1",
    "Name":"app_ne",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match",
      "App",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma union_disj : forall (s : string) re0 re1,\n  s =~ Union re0 re1 <-> s =~ re0 \\\/ s =~ re1.",
    "Statement":"Lemma union_disj : forall (s : string) re0 re1,\n  s =~ Union re0 re1 <-> s =~ re0 \\\/ s =~ re1",
    "Name":"union_disj",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "string",
      "MUnionR",
      "MUnionL",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n left.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n right.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros [ H | H ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma star_ne : forall (a : ascii) s re,\n  a :: s =~ Star re <->\n  exists s0 s1, s = s0 ++ s1 \/\\ a :: s0 =~ re \/\\ s1 =~ Star re.",
    "Statement":"Lemma star_ne : forall (a : ascii) s re,\n  a :: s =~ Star re <->\n  exists s0 s1, s = s0 ++ s1 \/\\ a :: s0 =~ re \/\\ s1 =~ Star re",
    "Name":"star_ne",
    "Dependencies":[
      "app",
      "cons",
      "list",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition refl_matches_eps m :=\n  forall re : reg_exp ascii, reflect ([ ] =~ re) (m re).",
    "Statement":"Definition refl_matches_eps m :=\n  forall re : reg_exp ascii, reflect ([ ] =~ re) (m re)",
    "Name":"refl_matches_eps",
    "Dependencies":[
      "nil",
      "reflect",
      "exp_match",
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint match_eps (re: reg_exp ascii) : bool\n  .",
    "Statement":"Fixpoint match_eps (re: reg_exp ascii) : bool",
    "Name":"match_eps",
    "Dependencies":[
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma match_eps_refl : refl_matches_eps match_eps.",
    "Statement":"Lemma match_eps_refl : refl_matches_eps match_eps",
    "Name":"match_eps_refl",
    "Dependencies":[
      "match_eps",
      "refl_matches_eps"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition is_der re (a : ascii) re' :=\n  forall s, a :: s =~ re <-> s =~ re'.",
    "Statement":"Definition is_der re (a : ascii) re' :=\n  forall s, a :: s =~ re <-> s =~ re'",
    "Name":"is_der",
    "Dependencies":[
      "cons",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition derives d := forall a re, is_der re a (d a re).",
    "Statement":"Definition derives d := forall a re, is_der re a (d a re)",
    "Name":"derives",
    "Dependencies":[
      "is_der",
      "reg_exp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint derive (a : ascii) (re : reg_exp ascii) : reg_exp ascii\n  .",
    "Statement":"Fixpoint derive (a : ascii) (re : reg_exp ascii) : reg_exp ascii",
    "Name":"derive",
    "Dependencies":[
      "reg_exp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample c := ascii_of_nat 99.",
    "Statement":"Example c := ascii_of_nat 99",
    "Name":"c",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample c := ascii_of_nat 99.",
    "Statement":"Example c := ascii_of_nat 99",
    "Name":"c",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample d := ascii_of_nat 100.",
    "Statement":"Example d := ascii_of_nat 100",
    "Name":"d",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nExample d := ascii_of_nat 100.",
    "Statement":"Example d := ascii_of_nat 100",
    "Name":"d",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der0 : match_eps (derive c (EmptySet)) = false.",
    "Statement":"Example test_der0 : match_eps (derive c (EmptySet)) = false",
    "Name":"test_der0",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "EmptySet",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der1 : match_eps (derive c (Char c)) = true.",
    "Statement":"Example test_der1 : match_eps (derive c (Char c)) = true",
    "Name":"test_der1",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "Char",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der2 : match_eps (derive c (Char d)) = false.",
    "Statement":"Example test_der2 : match_eps (derive c (Char d)) = false",
    "Name":"test_der2",
    "Dependencies":[
      "d",
      "c",
      "derive",
      "match_eps",
      "Char",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der3 : match_eps (derive c (App (Char c) EmptyStr)) = true.",
    "Statement":"Example test_der3 : match_eps (derive c (App (Char c) EmptyStr)) = true",
    "Name":"test_der3",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "EmptyStr",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der4 : match_eps (derive c (App EmptyStr (Char c))) = true.",
    "Statement":"Example test_der4 : match_eps (derive c (App EmptyStr (Char c))) = true",
    "Name":"test_der4",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "EmptyStr",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der5 : match_eps (derive c (Star (Char c))) = true.",
    "Statement":"Example test_der5 : match_eps (derive c (Star (Char c))) = true",
    "Name":"test_der5",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "Star",
      "Char",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der6 :\n  match_eps (derive d (derive c (App (Char c) (Char d)))) = true.",
    "Statement":"Example test_der6 :\n  match_eps (derive d (derive c (App (Char c) (Char d)))) = true",
    "Name":"test_der6",
    "Dependencies":[
      "d",
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_der7 :\n  match_eps (derive d (derive c (App (Char d) (Char c)))) = false.",
    "Statement":"Example test_der7 :\n  match_eps (derive d (derive c (App (Char d) (Char c)))) = false",
    "Name":"test_der7",
    "Dependencies":[
      "d",
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma derive_corr : derives derive.",
    "Statement":"Lemma derive_corr : derives derive",
    "Name":"derive_corr",
    "Dependencies":[
      "derive",
      "derives"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition matches_regex m : Prop :=\n  forall (s : string) re, reflect (s =~ re) (m s re).",
    "Statement":"Definition matches_regex m : Prop :=\n  forall (s : string) re, reflect (s =~ re) (m s re)",
    "Name":"matches_regex",
    "Dependencies":[
      "string",
      "reflect",
      "exp_match",
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint regex_match (s : string) (re : reg_exp ascii) : bool\n  .",
    "Statement":"Fixpoint regex_match (s : string) (re : reg_exp ascii) : bool",
    "Name":"regex_match",
    "Dependencies":[
      "string",
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem regex_match_correct : matches_regex regex_match.",
    "Statement":"Theorem regex_match_correct : matches_regex regex_match",
    "Name":"regex_match_correct",
    "Dependencies":[
      "regex_match",
      "matches_regex"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_AltAuto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export AltAuto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.Arith Stdlib.Lists.List.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end.",
    "Statement":"Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end",
    "Name":"re_opt_e",
    "Dependencies":[
      "Star",
      "Union",
      "App",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.",
    "Statement":"Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re",
    "Name":"re_opt_e_match",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt_e"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re s M.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct re1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion Hmatch1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MStarApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall n, 1 + n = S n.",
    "Statement":"Theorem silly1 : forall n, 1 + n = S n",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall n, 1 + n = S n.",
    "Statement":"Theorem silly1 : forall n, 1 + n = S n",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall n, 1 + n = S n.",
    "Statement":"Theorem silly1 : forall n, 1 + n = S n",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ntry reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall (P : Prop), P -> P.",
    "Statement":"Theorem silly2 : forall (P : Prop), P -> P",
    "Name":"silly2",
    "Dependencies":[
      "aeval",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall (P : Prop), P -> P.",
    "Statement":"Theorem silly2 : forall (P : Prop), P -> P",
    "Name":"silly2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall (P : Prop), P -> P.",
    "Statement":"Theorem silly2 : forall (P : Prop), P -> P",
    "Name":"silly2",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Fail reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  try reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma simple_semi : forall n, (n + 1 =? 0) = false.",
    "Statement":"Lemma simple_semi : forall n, (n + 1 =? 0) = false",
    "Name":"simple_semi",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct n eqn:E.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma simple_semi' : forall n, (n + 1 =? 0) = false.",
    "Statement":"Lemma simple_semi' : forall n, (n + 1 =? 0) = false",
    "Name":"simple_semi'",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  destruct n;\n\n  simpl;\n\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma simple_semi'' : forall n, (n + 1 =? 0) = false.",
    "Statement":"Lemma simple_semi'' : forall n, (n + 1 =? 0) = false",
    "Name":"simple_semi''",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct n; reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Statement":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c",
    "Name":"andb_eq_orb",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Statement":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c",
    "Name":"andb_eq_orb",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end.",
    "Statement":"Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end",
    "Name":"nonzeros",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end.",
    "Statement":"Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end",
    "Name":"nonzeros",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).",
    "Statement":"Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2)",
    "Name":"nonzeros_app",
    "Dependencies":[
      "app",
      "list",
      "nonzeros"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).",
    "Statement":"Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2)",
    "Name":"nonzeros_app",
    "Dependencies":[
      "nonzeros",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.",
    "Statement":"Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re",
    "Name":"re_opt_e_match'",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt_e"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re s M.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct re1;\n\n    try (apply MApp; try apply IH1; apply IH2).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    inversion Hmatch1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   apply MStarApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Statement":"Theorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2)",
    "Name":"app_length",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Statement":"Theorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2)",
    "Name":"app_length",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Statement":"Theorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2)",
    "Name":"app_length",
    "Dependencies":[
      "length",
      "app",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros; induction lst1;\n    [reflexivity | simpl; rewrite IHlst1; reflexivity].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_length' : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Statement":"Theorem app_length' : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2)",
    "Name":"app_length'",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros; induction lst1;\n    [idtac | simpl; rewrite IHlst1];\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.",
    "Statement":"Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re",
    "Name":"re_opt_e_match''",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt_e"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re s M.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    inversion Hmatch1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   apply MStarApp; [apply IH1 | apply IH2].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  repeat (try (left; reflexivity); right).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10'",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  repeat (left; reflexivity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  repeat (right; try (left; reflexivity)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev100: ev 100.",
    "Statement":"Theorem ev100: ev 100",
    "Name":"ev100",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end.",
    "Statement":"Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end",
    "Name":"re_opt",
    "Dependencies":[
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.",
    "Statement":"Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re",
    "Name":"re_opt_match",
    "Dependencies":[
      "app_nil_r",
      "app",
      "cons",
      "nil",
      "list",
      "star_app",
      "MStar1",
      "exp_match_ind",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re s M.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MChar.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct re1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite app_nil_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite app_nil_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite app_nil_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite app_nil_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MApp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"-",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct re1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionL.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct re1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct re2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MUnionR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct re.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      destruct re.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   destruct re.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n inversion IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply MEmpty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply star_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply star_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply star_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply star_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply MStar1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.",
    "Statement":"Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re",
    "Name":"re_opt_match'",
    "Dependencies":[
      "list",
      "exp_match",
      "reg_exp",
      "re_opt"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_re_opt : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_re_opt : option (nat*string) := None",
    "Name":"manual_grade_for_re_opt",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem hyp_name : forall (P : Prop), P -> P.",
    "Statement":"Theorem hyp_name : forall (P : Prop), P -> P",
    "Name":"hyp_name",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem no_hyp_name : forall (P : Prop), P -> P.",
    "Statement":"Theorem no_hyp_name : forall (P : Prop), P -> P",
    "Name":"no_hyp_name",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem false_assumed : False -> 0 = 1.",
    "Statement":"Theorem false_assumed : False -> 0 = 1",
    "Name":"false_assumed",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem false_assumed' : False -> 0 = 1.",
    "Statement":"Theorem false_assumed' : False -> 0 = 1",
    "Name":"false_assumed'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ncontradiction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem contras : forall (P : Prop), P -> ~P -> 0 = 1.",
    "Statement":"Theorem contras : forall (P : Prop), P -> ~P -> 0 = 1",
    "Name":"contras",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P HP HNP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nexfalso.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HNP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem contras' : forall (P : Prop), P -> ~P -> 0 = 1.",
    "Statement":"Theorem contras' : forall (P : Prop), P -> ~P -> 0 = 1",
    "Name":"contras'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ncontradiction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem many_eq : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p].",
    "Statement":"Theorem many_eq : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p]",
    "Name":"many_eq",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o p Hnm Hop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Hop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem many_eq' : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p].",
    "Statement":"Theorem many_eq' : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p]",
    "Name":"many_eq'",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsubst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_0 : ev 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_0 : ev 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_0 : ev 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck ev_SS : forall n : nat, ev n -> ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck ev_SS : forall n : nat, ev n -> ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck ev_SS : forall n : nat, ev n -> ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample constructor_example: forall (n:nat),\n    ev (n + n).",
    "Statement":"Example constructor_example: forall (n:nat),\n    ev (n + n)",
    "Name":"constructor_example",
    "Dependencies":[
      "add_comm",
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction n; simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n constructor.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nconstructor.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Stdlib.micromega.Lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lia_succeed1 : forall (n : nat),\n  n > 0 -> n * 2 > n.",
    "Statement":"Theorem lia_succeed1 : forall (n : nat),\n  n > 0 -> n * 2 > n",
    "Name":"lia_succeed1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lia_succeed2 : forall (n m : nat),\n    n * m = m * n.",
    "Statement":"Theorem lia_succeed2 : forall (n m : nat),\n    n * m = m * n",
    "Name":"lia_succeed2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Stdlib.setoid_ring.Ring.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mult_comm : forall (n m : nat),\n    n * m = m * n.",
    "Statement":"Theorem mult_comm : forall (n m : nat),\n    n * m = m * n",
    "Name":"mult_comm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nring.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eq_example1 :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x).",
    "Statement":"Theorem eq_example1 :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x)",
    "Name":"eq_example1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eq_example1' :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x).",
    "Statement":"Theorem eq_example1' :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x)",
    "Name":"eq_example1'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  congruence.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eq_example2 : forall (n m o p : nat),\n    n = m ->\n    o = p ->\n    (n, o) = (m, p).",
    "Statement":"Theorem eq_example2 : forall (n m o p : nat),\n    n = m ->\n    o = p ->\n    (n, o) = (m, p)",
    "Name":"eq_example2",
    "Dependencies":[
      "pair",
      "prod"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  congruence.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eq_example3 : forall (X : Type) (h : X) (t : list X),\n    [] <> h :: t.",
    "Statement":"Theorem eq_example3 : forall (X : Type) (h : X) (t : list X),\n    [] <> h :: t",
    "Name":"eq_example3",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  congruence.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem intuition_succeed1 : forall (P : Prop),\n    P -> P.",
    "Statement":"Theorem intuition_succeed1 : forall (P : Prop),\n    P -> P",
    "Name":"intuition_succeed1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintuition.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem intuition_succeed2 : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q.",
    "Statement":"Theorem intuition_succeed2 : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q",
    "Name":"intuition_succeed2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintuition.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem intuition_simplify2 : forall (x y : nat) (P Q : nat -> Prop),\n  x = y \/\\ (P x -> Q x) \/\\ P x -> Q y.",
    "Statement":"Theorem intuition_simplify2 : forall (x y : nat) (P Q : nat -> Prop),\n  x = y \/\\ (P x -> Q x) \/\\ P x -> Q y",
    "Name":"intuition_simplify2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Fail congruence.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intuition.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  congruence.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem intuition_simplify2' : forall (x y : nat) (P Q : nat -> Prop),\n  x = y \/\\ (P x -> Q x) \/\\ P x -> Q y.",
    "Statement":"Theorem intuition_simplify2' : forall (x y : nat) (P Q : nat -> Prop),\n  x = y \/\\ (P x -> Q x) \/\\ P x -> Q y",
    "Name":"intuition_simplify2'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intuition congruence.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_id_exercise_from_basics : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o.",
    "Statement":"Theorem plus_id_exercise_from_basics : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o",
    "Name":"plus_id_exercise_from_basics",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc_from_induction : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc_from_induction : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc_from_induction",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem S_injective_from_tactics : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "Statement":"Theorem S_injective_from_tactics : forall (n m : nat),\n  S n = S m ->\n  n = m",
    "Name":"S_injective_from_tactics",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem or_distributes_over_and_from_logic : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R).",
    "Statement":"Theorem or_distributes_over_and_from_logic : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)",
    "Name":"or_distributes_over_and_from_logic",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q R H1 H2 H3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Statement":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U",
    "Name":"auto_example_2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Statement":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U",
    "Name":"auto_example_2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Statement":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U",
    "Name":"auto_example_3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Statement":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U",
    "Name":"auto_example_3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  auto 6.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Statement":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R)",
    "Name":"auto_example_4",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Statement":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R)",
    "Name":"auto_example_4",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_5 : 2 = 2.",
    "Statement":"Example auto_example_5 : 2 = 2",
    "Name":"auto_example_5",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_5 : 2 = 2.",
    "Statement":"Example auto_example_5 : 2 = 2",
    "Name":"auto_example_5",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  info_auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Statement":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m",
    "Name":"le_antisym",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Statement":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m",
    "Name":"le_antisym",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto using le_antisym.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCreate HintDb le_db.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nHint Resolve le_antisym : le_db.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6'",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6'",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto with le_db.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition is_fortytwo x := (x = 42).",
    "Statement":"Definition is_fortytwo x := (x = 42)",
    "Name":"is_fortytwo",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition is_fortytwo x := (x = 42).",
    "Statement":"Definition is_fortytwo x := (x = 42)",
    "Name":"is_fortytwo",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nHint Unfold is_fortytwo : le_db.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Statement":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x",
    "Name":"auto_example_7'",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Statement":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x",
    "Name":"auto_example_7'",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninfo_auto with le_db.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_8 : forall (n m : nat),\n    n + m = m + n.",
    "Statement":"Example auto_example_8 : forall (n m : nat),\n    n + m = m + n",
    "Name":"auto_example_8",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  info_auto with arith.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.",
    "Statement":"Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re",
    "Name":"re_opt_match''",
    "Dependencies":[
      "list",
      "exp_match",
      "reg_exp",
      "re_opt"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_re_opt_match'' : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_re_opt_match'' : option (nat*string) := None",
    "Name":"manual_grade_for_re_opt_match''",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Pumping.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"weak_pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"weak_pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_pumping_redux : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_pumping_redux : option (nat*string) := None",
    "Name":"manual_grade_for_pumping_redux",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        length s1 + length s2 <= pumping_constant re \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        length s1 + length s2 <= pumping_constant re \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        length s1 + length s2 <= pumping_constant re \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Statement":"Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        length s1 + length s2 <= pumping_constant re \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re",
    "Name":"pumping",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros T re s Hmatch.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_pumping_redux_strong : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None",
    "Name":"manual_grade_for_pumping_redux_strong",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.",
    "Statement":"Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d",
    "Name":"trans_example1",
    "Dependencies":[
      "mul_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a b c d H1 H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Nat.le_trans with (b + b * c).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl in H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite mul_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.",
    "Statement":"Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d",
    "Name":"trans_example1'",
    "Dependencies":[
      "mul_comm"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a b c d H1 H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  eapply Nat.le_trans.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl in H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite mul_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.",
    "Statement":"Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d",
    "Name":"trans_example2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a b c d H1 H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  info_eauto using Nat.le_trans.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac simpl_and_try tac := simpl; try tac.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample sat_ex1 : 1 + 1 = 2.",
    "Statement":"Example sat_ex1 : 1 + 1 = 2",
    "Name":"sat_ex1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl_and_try reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.",
    "Statement":"Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n",
    "Name":"sat_ex2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl_and_try reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Statement":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b",
    "Name":"negb_involutive",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Statement":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b",
    "Name":"negb_involutive",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative : forall b c, andb b c = andb c b",
    "Name":"andb_commutative",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative : forall b c, andb b c = andb c b",
    "Name":"andb_commutative",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n destruct c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac destructpf x :=\n  destruct x; try reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0' : forall n : nat,\n    (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0' : forall n : nat,\n    (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0'",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_1_neq_0' : forall n : nat,\n    (n + 1) =? 0 = false.",
    "Statement":"Theorem plus_1_neq_0' : forall n : nat,\n    (n + 1) =? 0 = false",
    "Name":"plus_1_neq_0'",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n; destructpf n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem negb_involutive' : forall b : bool,\n  negb (negb b) = b.",
    "Statement":"Theorem negb_involutive' : forall b : bool,\n  negb (negb b) = b",
    "Name":"negb_involutive'",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros b; destructpf b.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative' : forall b c, andb b c = andb c b",
    "Name":"andb_commutative'",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Statement":"Theorem andb_commutative' : forall b c, andb b c = andb c b",
    "Name":"andb_commutative'",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b c; destructpf b; destructpf c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Statement":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c",
    "Name":"andb3_exchange",
    "Dependencies":[
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Statement":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c",
    "Name":"andb3_exchange",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Statement":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true",
    "Name":"andb_true_elim2",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Statement":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true",
    "Name":"andb_true_elim2",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros b c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct b eqn:Eb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct c eqn:Ec.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb_true_elim2' : forall b c : bool,\n    andb b c = true -> c = true.",
    "Statement":"Theorem andb_true_elim2' : forall b c : bool,\n    andb b c = true -> c = true",
    "Name":"andb_true_elim2'",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem andb3_exchange' :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Statement":"Theorem andb3_exchange' :\n  forall b c d, andb (andb b c) d = andb (andb b d) c",
    "Name":"andb3_exchange'",
    "Dependencies":[
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Statement":"Theorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Statement":"Theorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Statement":"Theorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst",
    "Name":"app_nil_r",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros X lst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction lst as [ | h t IHt].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHt.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex1 : True.",
    "Statement":"Theorem match_ex1 : True",
    "Name":"match_ex1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ |- True ] => apply I\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex2 : True \/\\ True.",
    "Statement":"Theorem match_ex2 : True \/\\ True",
    "Name":"match_ex2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ |- True ] => apply I\n  | [ |- True \/\\ True ] => split; apply I\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex2' : True \/\\ True.",
    "Statement":"Theorem match_ex2' : True \/\\ True",
    "Name":"match_ex2'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ |- True ] => idtac \"branch 1\"; apply I\n  | [ |- True \/\\ True ] => idtac \"branch 2\"; split; apply I\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex2'' : True \/\\ True.",
    "Statement":"Theorem match_ex2'' : True \/\\ True",
    "Name":"match_ex2''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ |- _ ] => idtac \"branch 1\"; apply I\n  | [ |- True \/\\ True ] => idtac \"branch 2\"; split; apply I\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex3 : forall (P : Prop), P -> P.",
    "Statement":"Theorem match_ex3 : forall (P : Prop), P -> P",
    "Name":"match_ex3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ H : _ |- _ ] => apply H\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex3' : forall (P : Prop), P -> P.",
    "Statement":"Theorem match_ex3' : forall (P : Prop), P -> P",
    "Name":"match_ex3'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ H : _ |- _ ] => idtac H; apply H\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex4 : forall (P Q : Prop), P -> Q -> P.",
    "Statement":"Theorem match_ex4 : forall (P Q : Prop), P -> Q -> P",
    "Name":"match_ex4",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HP HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ H : _ |- _ ] => idtac H; apply H\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem match_ex5 : forall (P Q : Prop), P -> Q -> P.",
    "Statement":"Theorem match_ex5 : forall (P Q : Prop), P -> Q -> P",
    "Name":"match_ex5",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HP HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  match goal with\n  | [ H : ?X |- ?X ] => idtac H; apply H\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Statement":"Theorem app_nil_r' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst",
    "Name":"app_nil_r'",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros X lst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction lst as [ | h t IHt].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHt.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem app_nil_r'' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Statement":"Theorem app_nil_r'' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst",
    "Name":"app_nil_r''",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros X lst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimple_induction lst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc'' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc'' : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc'' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc'' : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m p.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc''' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc''' : forall n m p : nat,\n    n + (m + p) = (n + m) + p",
    "Name":"add_assoc'''",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m p.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimple_induction n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_n_Sm : forall n m : nat,\n    S (n + m) = n + (S m).",
    "Statement":"Theorem plus_n_Sm : forall n m : nat,\n    S (n + m) = n + (S m)",
    "Name":"plus_n_Sm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_n_Sm : forall n m : nat,\n    S (n + m) = n + (S m).",
    "Statement":"Theorem plus_n_Sm : forall n m : nat,\n    S (n + m) = n + (S m)",
    "Name":"plus_n_Sm",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_n_Sm' : forall n m : nat,\n    S (n + m) = n + (S m).",
    "Statement":"Theorem plus_n_Sm' : forall n m : nat,\n    S (n + m) = n + (S m)",
    "Name":"plus_n_Sm'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimple_induction n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample imp1 : forall (P : Prop), P -> P.",
    "Statement":"Example imp1 : forall (P : Prop), P -> P",
    "Name":"imp1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nimp_intuition.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.",
    "Statement":"Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q",
    "Name":"imp2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nimp_intuition.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).",
    "Statement":"Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R)",
    "Name":"imp3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nimp_intuition.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q.",
    "Statement":"Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q",
    "Name":"nor",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nor_not_or : forall (P Q : Prop),\n    nor P Q -> ~ (P \\\/ Q).",
    "Statement":"Theorem nor_not_or : forall (P Q : Prop),\n    nor P Q -> ~ (P \\\/ Q)",
    "Name":"nor_not_or",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nor_comm : forall (P Q : Prop),\n    nor P Q <-> nor Q P.",
    "Statement":"Theorem nor_comm : forall (P Q : Prop),\n    nor P Q <-> nor Q P",
    "Name":"nor_comm",
    "Dependencies":[
      "stroke",
      "nor"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply stroke; assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply stroke; assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nor_not : forall (P : Prop),\n    nor P P <-> ~P.",
    "Statement":"Theorem nor_not : forall (P : Prop),\n    nor P P <-> ~P",
    "Name":"nor_not",
    "Dependencies":[
      "stroke",
      "nor"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply stroke; assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nor_comm' : forall (P Q : Prop),\n    nor P Q <-> nor Q P.",
    "Statement":"Theorem nor_comm' : forall (P Q : Prop),\n    nor P Q <-> nor Q P",
    "Name":"nor_comm'",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nor_not' : forall (P : Prop),\n    nor P P <-> ~P.",
    "Statement":"Theorem nor_not' : forall (P : Prop),\n    nor P P <-> ~P",
    "Name":"nor_not'",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem nor_not_and' : forall (P Q : Prop),\n    nor P Q -> ~ (P \/\\ Q).",
    "Statement":"Theorem nor_not_and' : forall (P Q : Prop),\n    nor P Q -> ~ (P \/\\ Q)",
    "Name":"nor_not_and'",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_nor_intuition : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_nor_intuition : option (nat*string) := None",
    "Name":"manual_grade_for_nor_intuition",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd AltAuto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_AltAuto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_AltAutoTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.AltAuto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.AltAuto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions andb_eq_orb.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions add_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions nonzeros_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions add_assoc'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ev100.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_id_exercise_from_basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions add_assoc_from_induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions S_injective_from_tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions or_distributes_over_and_from_logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions andb3_exchange.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions andb_true_elim2'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions andb3_exchange'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_AltAutoTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Stdlib.Arith.Arith.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Bool.Bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Logic.FunctionalExtensionality.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Lists.List.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport ListNotations.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Default Goal Selector \"!\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLocate \"+\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint Init.Nat.add.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck String.eqb_refl :\n  forall x : string, (x =? x)%string = true.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition total_map (A : Type) := string -> A.",
    "Statement":"Definition total_map (A : Type) := string -> A",
    "Name":"total_map",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v).",
    "Statement":"Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v)",
    "Name":"t_empty",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'.",
    "Statement":"Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String",
    "Name":"t_update",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true.",
    "Statement":"Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true",
    "Name":"examplemap",
    "Dependencies":[
      "t_update",
      "t_empty"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample example_empty := (_ !-> false).",
    "Statement":"Example example_empty := (_ !-> false)",
    "Name":"example_empty",
    "Dependencies":[
      "t_empty",
      "total_map"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  ).",
    "Statement":"Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  )",
    "Name":"examplemap'",
    "Dependencies":[
      "t_update",
      "t_empty"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample update_example1 : examplemap' \"baz\" = false.",
    "Statement":"Example update_example1 : examplemap' \"baz\" = false",
    "Name":"update_example1",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample update_example2 : examplemap' \"foo\" = true.",
    "Statement":"Example update_example2 : examplemap' \"foo\" = true",
    "Name":"update_example2",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample update_example3 : examplemap' \"quux\" = false.",
    "Statement":"Example update_example3 : examplemap' \"quux\" = false",
    "Name":"update_example3",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample update_example4 : examplemap' \"bar\" = true.",
    "Statement":"Example update_example4 : examplemap' \"bar\" = true",
    "Name":"update_example4",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.",
    "Statement":"Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v",
    "Name":"t_apply_empty",
    "Dependencies":[
      "t_empty"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.",
    "Statement":"Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v",
    "Name":"t_update_eq",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem t_update_neq : forall (A : Type) (m : total_map A) x1 x2 v,\n  x1 <> x2 ->\n  (x1 !-> v ; m) x2 = m x2.",
    "Statement":"Theorem t_update_neq : forall (A : Type) (m : total_map A) x1 x2 v,\n  x1 <> x2 ->\n  (x1 !-> v ; m) x2 = m x2",
    "Name":"t_update_neq",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).",
    "Statement":"Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m)",
    "Name":"t_update_shadow",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem t_update_same : forall (A : Type) (m : total_map A) x,\n  (x !-> m x ; m) = m.",
    "Statement":"Theorem t_update_same : forall (A : Type) (m : total_map A) x,\n  (x !-> m x ; m) = m",
    "Name":"t_update_same",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem t_update_permute : forall (A : Type) (m : total_map A)\n                                  v1 v2 x1 x2,\n  x2 <> x1 ->\n  (x1 !-> v1 ; x2 !-> v2 ; m)\n  =\n  (x2 !-> v2 ; x1 !-> v1 ; m).",
    "Statement":"Theorem t_update_permute : forall (A : Type) (m : total_map A)\n                                  v1 v2 x1 x2,\n  x2 <> x1 ->\n  (x1 !-> v1 ; x2 !-> v2 ; m)\n  =\n  (x2 !-> v2 ; x1 !-> v1 ; m)",
    "Name":"t_update_permute",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition partial_map (A : Type) := total_map (option A).",
    "Statement":"Definition partial_map (A : Type) := total_map (option A)",
    "Name":"partial_map",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition partial_map (A : Type) := total_map (option A).",
    "Statement":"Definition partial_map (A : Type) := total_map (option A)",
    "Name":"partial_map",
    "Dependencies":[
      "id"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition empty {A : Type} : partial_map A :=\n  t_empty None.",
    "Statement":"Definition empty {A : Type} : partial_map A :=\n  t_empty None",
    "Name":"empty",
    "Dependencies":[
      "partial_map",
      "t_empty"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition empty {A : Type} : partial_map A :=\n  t_empty None.",
    "Statement":"Definition empty {A : Type} : partial_map A :=\n  t_empty None",
    "Name":"empty",
    "Dependencies":[
      "id"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m).",
    "Statement":"Definition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m)",
    "Name":"update",
    "Dependencies":[
      "partial_map",
      "t_update"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m).",
    "Statement":"Definition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m)",
    "Name":"update",
    "Dependencies":[
      "record",
      "partial_map",
      "id"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x '|->' v ';' m\" := (update m x v)\n  (at level 100, v at next level, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x '|->' v\" := (update empty x v)\n  (at level 100).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition examplepmap :=\n  (\"Church\" |-> true ; \"Turing\" |-> false).",
    "Statement":"Definition examplepmap :=\n  (\"Church\" |-> true ; \"Turing\" |-> false)",
    "Name":"examplepmap",
    "Dependencies":[
      "update",
      "empty"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma apply_empty : forall (A : Type) (x : string),\n  @empty A x = None.",
    "Statement":"Lemma apply_empty : forall (A : Type) (x : string),\n  @empty A x = None",
    "Name":"apply_empty",
    "Dependencies":[
      "empty",
      "t_apply_empty",
      "t_empty"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold empty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite t_apply_empty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v.",
    "Statement":"Lemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v",
    "Name":"update_eq",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_eq",
      "t_update"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v.",
    "Statement":"Lemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v",
    "Name":"update_eq",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "Some",
      "natoption",
      "id"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold update.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite t_update_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n#[global] Hint Resolve update_eq : core.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,\n  x2 <> x1 ->\n  (x2 |-> v ; m) x1 = m x1.",
    "Statement":"Theorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,\n  x2 <> x1 ->\n  (x2 |-> v ; m) x1 = m x1",
    "Name":"update_neq",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_neq",
      "t_update"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,\n  x2 <> x1 ->\n  (x2 |-> v ; m) x1 = m x1.",
    "Statement":"Theorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,\n  x2 <> x1 ->\n  (x2 |-> v ; m) x1 = m x1",
    "Name":"update_neq",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "natoption",
      "eqb_id",
      "id",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A m x1 x2 v H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold update.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite t_update_neq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,\n  (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m).",
    "Statement":"Lemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,\n  (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m)",
    "Name":"update_shadow",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_shadow",
      "t_update"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A m x v1 v2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold update.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite t_update_shadow.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_same : forall (A : Type) (m : partial_map A) x v,\n  m x = Some v ->\n  (x |-> v ; m) = m.",
    "Statement":"Theorem update_same : forall (A : Type) (m : partial_map A) x v,\n  m x = Some v ->\n  (x |-> v ; m) = m",
    "Name":"update_same",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_same",
      "t_update"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A m x v H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold update.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply t_update_same.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem update_permute : forall (A : Type) (m : partial_map A)\n                                x1 x2 v1 v2,\n  x2 <> x1 ->\n  (x1 |-> v1 ; x2 |-> v2 ; m) = (x2 |-> v2 ; x1 |-> v1 ; m).",
    "Statement":"Theorem update_permute : forall (A : Type) (m : partial_map A)\n                                x1 x2 v1 v2,\n  x2 <> x1 ->\n  (x1 |-> v1 ; x2 |-> v2 ; m) = (x2 |-> v2 ; x1 |-> v1 ; m)",
    "Name":"update_permute",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_permute"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A m x1 x2 v1 v2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold update.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply t_update_permute.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition includedin {A : Type} (m m' : partial_map A) :=\n  forall x v, m x = Some v -> m' x = Some v.",
    "Statement":"Definition includedin {A : Type} (m m' : partial_map A) :=\n  forall x v, m x = Some v -> m' x = Some v",
    "Name":"includedin",
    "Dependencies":[
      "partial_map"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma includedin_update : forall (A : Type) (m m' : partial_map A)\n                                 (x : string) (vx : A),\n  includedin m m' ->\n  includedin (x |-> vx ; m) (x |-> vx ; m').",
    "Statement":"Lemma includedin_update : forall (A : Type) (m m' : partial_map A)\n                                 (x : string) (vx : A),\n  includedin m m' ->\n  includedin (x |-> vx ; m) (x |-> vx ; m')",
    "Name":"includedin_update",
    "Dependencies":[
      "includedin",
      "update_neq",
      "update_eq",
      "update",
      "partial_map"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold includedin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros A m m' x vx H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros y vy.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct (eqb_spec x y) as [Hxy | Hxy].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite Hxy.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite update_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite update_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintro H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite update_neq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite update_neq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply Hxy.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply Hxy.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Bool.Bool.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Corelib.Init.Nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.Arith.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.EqNat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.micromega.Lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Lists.List.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport ListNotations.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Default Goal Selector \"!\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export AExp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Statement":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)",
    "Name":"bexp",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Statement":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)",
    "Name":"bexp",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end.",
    "Statement":"Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end",
    "Name":"aeval",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end.",
    "Statement":"Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end",
    "Name":"aeval",
    "Dependencies":[
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.",
    "Statement":"Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4",
    "Name":"test_aeval1",
    "Dependencies":[
      "aeval",
      "APlus",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end.",
    "Statement":"Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end",
    "Name":"beval",
    "Dependencies":[
      "aeval",
      "bexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end.",
    "Statement":"Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end",
    "Name":"beval",
    "Dependencies":[
      "aeval",
      "bexp",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end.",
    "Statement":"Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end",
    "Name":"optimize_0plus",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).",
    "Statement":"Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1)",
    "Name":"test_optimize_0plus",
    "Dependencies":[
      "optimize_0plus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem optimize_0plus_sound: forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "Statement":"Theorem optimize_0plus_sound: forall a,\n  aeval (optimize_0plus a) = aeval a",
    "Name":"optimize_0plus_sound",
    "Dependencies":[
      "optimize_0plus",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction a.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct a1 eqn:Ea1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct n eqn:En.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      rewrite IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      rewrite IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      rewrite IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall (P : Prop), P -> P.",
    "Statement":"Theorem silly1 : forall (P : Prop), P -> P",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall (P : Prop), P -> P.",
    "Statement":"Theorem silly1 : forall (P : Prop), P -> P",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly1 : forall (P : Prop), P -> P.",
    "Statement":"Theorem silly1 : forall (P : Prop), P -> P",
    "Name":"silly1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  try reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall ae, aeval ae = aeval ae.",
    "Statement":"Theorem silly2 : forall ae, aeval ae = aeval ae",
    "Name":"silly2",
    "Dependencies":[
      "aeval",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall ae, aeval ae = aeval ae.",
    "Statement":"Theorem silly2 : forall ae, aeval ae = aeval ae",
    "Name":"silly2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem silly2 : forall ae, aeval ae = aeval ae.",
    "Statement":"Theorem silly2 : forall ae, aeval ae = aeval ae",
    "Name":"silly2",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    try reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma foo : forall n, 0 <=? n = true.",
    "Statement":"Lemma foo : forall n, 0 <=? n = true",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma foo : forall n, 0 <=? n = true.",
    "Statement":"Lemma foo : forall n, 0 <=? n = true",
    "Name":"foo",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma foo : forall n, 0 <=? n = true.",
    "Statement":"Lemma foo : forall n, 0 <=? n = true",
    "Name":"foo",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma foo : forall n, 0 <=? n = true.",
    "Statement":"Lemma foo : forall n, 0 <=? n = true",
    "Name":"foo",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma foo' : forall n, 0 <=? n = true.",
    "Statement":"Lemma foo' : forall n, 0 <=? n = true",
    "Name":"foo'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma foo' : forall n, 0 <=? n = true.",
    "Statement":"Lemma foo' : forall n, 0 <=? n = true",
    "Name":"foo'",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  destruct n;\n\n  simpl;\n\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem optimize_0plus_sound': forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "Statement":"Theorem optimize_0plus_sound': forall a,\n  aeval (optimize_0plus a) = aeval a",
    "Name":"optimize_0plus_sound'",
    "Dependencies":[
      "optimize_0plus",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction a;\n\n    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct a1 eqn:Ea1;\n\n      try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem optimize_0plus_sound'': forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "Statement":"Theorem optimize_0plus_sound'': forall a,\n  aeval (optimize_0plus a) = aeval a",
    "Name":"optimize_0plus_sound''",
    "Dependencies":[
      "optimize_0plus",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros a.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction a;\n\n    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);\n\n    try reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct n;\n      simpl; rewrite IHa2; reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  repeat (try (left; reflexivity); right).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Statement":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10]",
    "Name":"In10'",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  repeat simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  repeat (left; reflexivity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  repeat (right; try (left; reflexivity)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem repeat_loop : forall (m n : nat),\n  m + n = n + m.",
    "Statement":"Theorem repeat_loop : forall (m n : nat),\n  m + n = n + m",
    "Name":"repeat_loop",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros m n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint optimize_0plus_b (b : bexp) : bexp\n  .",
    "Statement":"Fixpoint optimize_0plus_b (b : bexp) : bexp",
    "Name":"optimize_0plus_b",
    "Dependencies":[
      "bexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).",
    "Statement":"Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8)))",
    "Name":"optimize_0plus_b_test1",
    "Dependencies":[
      "optimize_0plus_b",
      "BNot",
      "BGt",
      "bexp",
      "APlus",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).",
    "Statement":"Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue)",
    "Name":"optimize_0plus_b_test2",
    "Dependencies":[
      "optimize_0plus_b",
      "BAnd",
      "BLe",
      "BTrue",
      "bexp",
      "APlus",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem optimize_0plus_b_sound : forall b,\n  beval (optimize_0plus_b b) = beval b.",
    "Statement":"Theorem optimize_0plus_b_sound : forall b,\n  beval (optimize_0plus_b b) = beval b",
    "Name":"optimize_0plus_b_sound",
    "Dependencies":[
      "optimize_0plus_b",
      "beval",
      "bexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac invert H :=\n  inversion H; subst; clear H.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "bw_white",
      "bw_black",
      "bw"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.",
    "Statement":"Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c",
    "Name":"invert_example1",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  invert H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample silly_presburger_example : forall m n o p,\n  m + n <= n + o \/\\ o + 3 = p + 3 ->\n  m <= p.",
    "Statement":"Example silly_presburger_example : forall m n o p,\n  m + n <= n + o \/\\ o + 3 = p + 3 ->\n  m <= p",
    "Name":"silly_presburger_example",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample add_comm__lia : forall m n,\n    m + n = n + m.",
    "Statement":"Example add_comm__lia : forall m n,\n    m + n = n + m",
    "Name":"add_comm__lia",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.",
    "Statement":"Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p",
    "Name":"add_assoc__lia",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export aevalR_first_try.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export HypothesisNames.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2)",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd HypothesisNames.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd aevalR_first_try.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation \"e '==>' n\" (at level 90, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_beval_rules : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_beval_rules : option (nat*string) := None",
    "Name":"manual_grade_for_beval_rules",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem aevalR_iff_aeval : forall a n,\n  (a ==> n) <-> aeval a = n.",
    "Statement":"Theorem aevalR_iff_aeval : forall a n,\n  (a ==> n) <-> aeval a = n",
    "Name":"aevalR_iff_aeval",
    "Dependencies":[
      "aevalR_ind",
      "E_AMult",
      "E_AMinus",
      "E_APlus",
      "E_ANum",
      "aevalR",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    induction H; simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rewrite IHaevalR1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite IHaevalR2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rewrite IHaevalR1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite IHaevalR2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rewrite IHaevalR1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n rewrite IHaevalR2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    generalize dependent n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    induction a;\n       simpl; intros; subst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply E_ANum.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply E_APlus.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply E_AMinus.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply E_AMult.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IHa1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IHa2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem aevalR_iff_aeval' : forall a n,\n  (a ==> n) <-> aeval a = n.",
    "Statement":"Theorem aevalR_iff_aeval' : forall a n,\n  (a ==> n) <-> aeval a = n",
    "Name":"aevalR_iff_aeval'",
    "Dependencies":[
      "aevalR_ind",
      "E_AMult",
      "E_AMinus",
      "E_APlus",
      "E_ANum",
      "aevalR",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros H; induction H; subst; reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    generalize dependent n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation \"e '==>b' b\" (at level 90, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nInductive bevalR: bexp -> bool -> Prop :=\n\nwhere \"e '==>b' b\" := (bevalR e b) : type_scope\n.",
    "Statement":"Inductive bevalR: bexp -> bool -> Prop :=\n\nwhere \"e '==>b' b\" := (bevalR e b) : type_scope",
    "Name":"bevalR",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.",
    "Statement":"Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv",
    "Name":"bevalR_iff_beval",
    "Dependencies":[
      "bevalR",
      "beval",
      "bexp"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd AExp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export aevalR_division.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation \"e '==>' n\"\n                  (at level 90, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd aevalR_division.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export aevalR_extended.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation \"e '==>' n\" (at level 90, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Statement":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope",
    "Name":"aevalR",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd aevalR_extended.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition state := total_map nat.",
    "Statement":"Definition state := total_map nat",
    "Name":"state",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Statement":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)",
    "Name":"aexp",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition W : string := \"W\".",
    "Statement":"Definition W : string := \"W\"",
    "Name":"W",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition X : string := \"X\".",
    "Statement":"Definition X : string := \"X\"",
    "Name":"X",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition Y : string := \"Y\".",
    "Statement":"Definition Y : string := \"Y\"",
    "Name":"Y",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition Z : string := \"Z\".",
    "Statement":"Definition Z : string := \"Z\"",
    "Name":"Z",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition Z : string := \"Z\".",
    "Statement":"Definition Z : string := \"Z\"",
    "Name":"Z",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition Z : string := \"Z\".",
    "Statement":"Definition Z : string := \"Z\"",
    "Name":"Z",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Statement":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)",
    "Name":"bexp",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Statement":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp)",
    "Name":"bexp",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCoercion AId : string >-> aexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCoercion ANum : nat >-> aexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCoercion ANum : nat >-> aexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCoercion ANum : nat >-> aexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCoercion ANum : nat >-> aexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nDeclare Custom Entry com.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nDeclare Scope com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nDeclare Custom Entry com_aux.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"<{ e }>\" := e (e custom com_aux) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"( x )\" := x (in custom com, x at level 99) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'true'\"  := true (at level 1).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'true'\"  := BTrue (in custom com at level 0).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'false'\" := false (at level 1).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'false'\" := BFalse (in custom com at level 0).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nOpen Scope com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition example_aexp : aexp := <{ 3 + (X * 2) }>.",
    "Statement":"Definition example_aexp : aexp := <{ 3 + (X * 2) }>",
    "Name":"example_aexp",
    "Dependencies":[
      "X",
      "AMult",
      "APlus",
      "AId",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\nDefinition example_bexp : bexp := <{ true && ~(X <= 4) }>.",
    "Statement":"Definition example_bexp : bexp := <{ true && ~(X <= 4) }>",
    "Name":"example_bexp",
    "Dependencies":[
      "BAnd",
      "BNot",
      "BLe",
      "BTrue",
      "bexp",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end.",
    "Statement":"Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end",
    "Name":"aeval",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end.",
    "Statement":"Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end",
    "Name":"aeval",
    "Dependencies":[
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end.",
    "Statement":"Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end",
    "Name":"beval",
    "Dependencies":[
      "aeval",
      "bexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end.",
    "Statement":"Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end",
    "Name":"beval",
    "Dependencies":[
      "aeval",
      "bexp",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition empty_st := (_ !-> 0).",
    "Statement":"Definition empty_st := (_ !-> 0)",
    "Name":"empty_st",
    "Dependencies":[
      "t_empty",
      "total_map"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.",
    "Statement":"Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13",
    "Name":"aexp1",
    "Dependencies":[
      "t_update",
      "empty_st",
      "aeval",
      "X",
      "AMult",
      "APlus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.",
    "Statement":"Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20",
    "Name":"aexp2",
    "Dependencies":[
      "t_update",
      "empty_st",
      "aeval",
      "Z",
      "Y",
      "X",
      "AMult",
      "APlus",
      "AId"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.",
    "Statement":"Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true",
    "Name":"bexp1",
    "Dependencies":[
      "t_update",
      "empty_st",
      "beval",
      "BAnd",
      "BNot",
      "BLe",
      "BTrue",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>.",
    "Statement":"Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>",
    "Name":"fact_in_coq",
    "Dependencies":[
      "CWhile",
      "CSeq",
      "CAsgn",
      "com",
      "BNeq",
      "Z",
      "Y",
      "X",
      "AMult",
      "AMinus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint fact_in_coq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nUnset Printing Notations.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint fact_in_coq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Printing Notations.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint example_bexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Printing Coercions.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint example_bexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint fact_in_coq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nUnset Printing Coercions.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLocate aexp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLocate \"&&\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLocate \";\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLocate \"while\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition plus2 : com :=\n  <{ X := X + 2 }>.",
    "Statement":"Definition plus2 : com :=\n  <{ X := X + 2 }>",
    "Name":"plus2",
    "Dependencies":[
      "CAsgn",
      "com",
      "X",
      "APlus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition XtimesYinZ : com :=\n  <{ Z := X * Y }>.",
    "Statement":"Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>",
    "Name":"XtimesYinZ",
    "Dependencies":[
      "CAsgn",
      "com",
      "Z",
      "Y",
      "X",
      "AMult",
      "AId"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>.",
    "Statement":"Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>",
    "Name":"subtract_slowly_body",
    "Dependencies":[
      "CSeq",
      "CAsgn",
      "com",
      "Z",
      "X",
      "AMinus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>.",
    "Statement":"Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>",
    "Name":"subtract_slowly",
    "Dependencies":[
      "subtract_slowly_body",
      "CWhile",
      "com",
      "BNeq",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>.",
    "Statement":"Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>",
    "Name":"subtract_3_from_5_slowly",
    "Dependencies":[
      "subtract_slowly",
      "CSeq",
      "CAsgn",
      "com",
      "Z",
      "X",
      "ANum"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition loop : com :=\n  <{ while true do\n       skip\n     end }>.",
    "Statement":"Definition loop : com :=\n  <{ while true do\n       skip\n     end }>",
    "Name":"loop",
    "Dependencies":[
      "CWhile",
      "CSkip",
      "com",
      "BTrue"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end.",
    "Statement":"Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end",
    "Name":"ceval_fun_no_while",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Statement":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st')",
    "Name":"ceval",
    "Dependencies":[
      "state",
      "SContinue",
      "CSkip"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Statement":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st')",
    "Name":"ceval",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Statement":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st')",
    "Name":"ceval",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Statement":"Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2)",
    "Name":"ceval_example1",
    "Dependencies":[
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "t_update",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Statement":"Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2)",
    "Name":"ceval_example1",
    "Dependencies":[
      "t_update",
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply E_Seq with (X !-> 2).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply E_Seq with (X !-> 2).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply E_Asgn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply E_IfFalse.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply E_Asgn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).",
    "Statement":"Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0)",
    "Name":"ceval_example2",
    "Dependencies":[
      "t_update",
      "ceval",
      "CSeq",
      "CAsgn",
      "empty_st",
      "Z",
      "Y",
      "X",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Printing Implicit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck @ceval_example2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition pup_to_n : com\n  .",
    "Statement":"Definition pup_to_n : com",
    "Name":"pup_to_n",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition pup_to_n : com\n  .",
    "Statement":"Definition pup_to_n : com",
    "Name":"pup_to_n",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem pup_to_2_ceval :\n  (X !-> 2) =[\n    pup_to_n\n  ]=> (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2).",
    "Statement":"Theorem pup_to_2_ceval :\n  (X !-> 2) =[\n    pup_to_n\n  ]=> (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2)",
    "Name":"pup_to_2_ceval",
    "Dependencies":[
      "t_update",
      "pup_to_n",
      "ceval",
      "empty_st",
      "Y",
      "X"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction E1; intros st2 E2; inversion E2; subst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H1) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply IHE1_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply IHE1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply IHE1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H3) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply IHE1_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus2_spec : forall st n st',\n  st X = n ->\n  st =[ plus2 ]=> st' ->\n  st' X = n + 2.",
    "Statement":"Theorem plus2_spec : forall st n st',\n  st X = n ->\n  st =[ plus2 ]=> st' ->\n  st' X = n + 2",
    "Name":"plus2_spec",
    "Dependencies":[
      "t_update_eq",
      "t_update",
      "ceval",
      "plus2",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "X",
      "APlus",
      "AId",
      "ANum",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros st n st' HX Heval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  inversion Heval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsubst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nclear Heval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply t_update_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None",
    "Name":"manual_grade_for_XtimesYinZ_spec",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem loop_never_stops : forall st st',\n  ~(st =[ loop ]=> st').",
    "Statement":"Theorem loop_never_stops : forall st st',\n  ~(st =[ loop ]=> st')",
    "Name":"loop_never_stops",
    "Dependencies":[
      "ceval",
      "loop",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros st st' contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold loop in contra.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "CWhile",
      "CSkip",
      "com",
      "BTrue"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  remember <{ while true do skip end }> as loopdef\n           eqn:Heqloopdef.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end.",
    "Statement":"Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end",
    "Name":"no_whiles",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive no_whilesR: com -> Prop :=\n\n.",
    "Statement":"Inductive no_whilesR: com -> Prop :=",
    "Name":"no_whilesR",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem no_whiles_eqv:\n  forall c, no_whiles c = true <-> no_whilesR c.",
    "Statement":"Theorem no_whiles_eqv:\n  forall c, no_whiles c = true <-> no_whilesR c",
    "Name":"no_whiles_eqv",
    "Dependencies":[
      "no_whilesR",
      "no_whiles",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_no_whiles_terminating : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None",
    "Name":"manual_grade_for_no_whiles_terminating",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult.",
    "Statement":"Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult",
    "Name":"sinstr",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  .",
    "Statement":"Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat",
    "Name":"s_execute",
    "Dependencies":[
      "sinstr",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck s_execute.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].",
    "Statement":"Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5]",
    "Name":"s_execute1",
    "Dependencies":[
      "s_execute",
      "SMinus",
      "SPush",
      "sinstr",
      "empty_st"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].",
    "Statement":"Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4]",
    "Name":"s_execute2",
    "Dependencies":[
      "t_update",
      "s_execute",
      "SMult",
      "SPlus",
      "SLoad",
      "SPush",
      "sinstr",
      "empty_st",
      "X"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint s_compile (e : aexp) : list sinstr\n  .",
    "Statement":"Fixpoint s_compile (e : aexp) : list sinstr",
    "Name":"s_compile",
    "Dependencies":[
      "sinstr",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].",
    "Statement":"Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus]",
    "Name":"s_compile1",
    "Dependencies":[
      "s_compile",
      "SMult",
      "SMinus",
      "SLoad",
      "SPush",
      "sinstr",
      "Y",
      "X",
      "AMult",
      "AMinus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem execute_app : forall st p1 p2 stack,\n  s_execute st stack (p1 ++ p2) = s_execute st (s_execute st stack p1) p2.",
    "Statement":"Theorem execute_app : forall st p1 p2 stack,\n  s_execute st stack (p1 ++ p2) = s_execute st (s_execute st stack p1) p2",
    "Name":"execute_app",
    "Dependencies":[
      "s_execute",
      "sinstr",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.",
    "Statement":"Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack",
    "Name":"s_compile_correct_aux",
    "Dependencies":[
      "s_compile",
      "s_execute",
      "aeval",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem s_compile_correct : forall (st : state) (e : aexp),\n  s_execute st [] (s_compile e) = [ aeval st e ].",
    "Statement":"Theorem s_compile_correct : forall (st : state) (e : aexp),\n  s_execute st [] (s_compile e) = [ aeval st e ]",
    "Name":"s_compile_correct",
    "Dependencies":[
      "s_compile",
      "s_execute",
      "aeval",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule BreakImp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"'break'\" := CBreak (in custom com at level 0).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive result : Type :=\n  | SContinue\n  | SBreak.",
    "Statement":"Inductive result : Type :=\n  | SContinue\n  | SBreak",
    "Name":"result",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation \"st '=[' c ']=>' st' '\/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st').",
    "Statement":"Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st')",
    "Name":"ceval",
    "Dependencies":[
      "state",
      "SContinue",
      "CSkip"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st').",
    "Statement":"Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st')",
    "Name":"ceval",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st').",
    "Statement":"Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st')",
    "Name":"ceval",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem break_ignore : forall c st st' s,\n     st =[ break; c ]=> st' \/ s ->\n     st = st'.",
    "Statement":"Theorem break_ignore : forall c st st' s,\n     st =[ break; c ]=> st' \/ s ->\n     st = st'",
    "Name":"break_ignore",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "CSeq",
      "CBreak",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem while_continue : forall b c st st' s,\n  st =[ while b do c end ]=> st' \/ s ->\n  s = SContinue.",
    "Statement":"Theorem while_continue : forall b c st st' s,\n  st =[ while b do c end ]=> st' \/ s ->\n  s = SContinue",
    "Name":"while_continue",
    "Dependencies":[
      "bexp",
      "state",
      "ceval",
      "SContinue",
      "result",
      "CWhile",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem while_stops_on_break : forall b c st st',\n  beval st b = true ->\n  st =[ c ]=> st' \/ SBreak ->\n  st =[ while b do c end ]=> st' \/ SContinue.",
    "Statement":"Theorem while_stops_on_break : forall b c st st',\n  beval st b = true ->\n  st =[ c ]=> st' \/ SBreak ->\n  st =[ while b do c end ]=> st' \/ SContinue",
    "Name":"while_stops_on_break",
    "Dependencies":[
      "beval",
      "bexp",
      "state",
      "ceval",
      "SBreak",
      "SContinue",
      "CWhile",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem seq_continue : forall c1 c2 st st' st'',\n  st =[ c1 ]=> st' \/ SContinue ->\n  st' =[ c2 ]=> st'' \/ SContinue ->\n  st =[ c1 ; c2 ]=> st'' \/ SContinue.",
    "Statement":"Theorem seq_continue : forall c1 c2 st st' st'',\n  st =[ c1 ]=> st' \/ SContinue ->\n  st' =[ c2 ]=> st'' \/ SContinue ->\n  st =[ c1 ; c2 ]=> st'' \/ SContinue",
    "Name":"seq_continue",
    "Dependencies":[
      "state",
      "ceval",
      "SContinue",
      "CSeq",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem seq_stops_on_break : forall c1 c2 st st',\n  st =[ c1 ]=> st' \/ SBreak ->\n  st =[ c1 ; c2 ]=> st' \/ SBreak.",
    "Statement":"Theorem seq_stops_on_break : forall c1 c2 st st',\n  st =[ c1 ]=> st' \/ SBreak ->\n  st =[ c1 ; c2 ]=> st' \/ SBreak",
    "Name":"seq_stops_on_break",
    "Dependencies":[
      "state",
      "ceval",
      "SBreak",
      "CSeq",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem while_break_true : forall b c st st',\n  st =[ while b do c end ]=> st' \/ SContinue ->\n  beval st' b = true ->\n  exists st'', st'' =[ c ]=> st' \/ SBreak.",
    "Statement":"Theorem while_break_true : forall b c st st',\n  st =[ while b do c end ]=> st' \/ SContinue ->\n  beval st' b = true ->\n  exists st'', st'' =[ c ]=> st' \/ SBreak",
    "Name":"while_break_true",
    "Dependencies":[
      "beval",
      "bexp",
      "state",
      "ceval",
      "SBreak",
      "SContinue",
      "CWhile",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Statement":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Statement":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Statement":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Statement":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd BreakImp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export Auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.micromega.Lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H1) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply IHE1_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply IHE1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply IHE1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H3) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply IHE1_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q R H1 H2 H3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Statement":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R",
    "Name":"auto_example_1'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Statement":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U",
    "Name":"auto_example_2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Statement":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U",
    "Name":"auto_example_2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Statement":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U",
    "Name":"auto_example_3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Statement":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U",
    "Name":"auto_example_3",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  debug auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  auto 6.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Statement":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R)",
    "Name":"auto_example_4",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Statement":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R)",
    "Name":"auto_example_4",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_5: 2 = 2.",
    "Statement":"Example auto_example_5: 2 = 2",
    "Name":"auto_example_5",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_5: 2 = 2.",
    "Statement":"Example auto_example_5: 2 = 2",
    "Name":"auto_example_5",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  info_auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.",
    "Statement":"Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T",
    "Name":"auto_example_5'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  info_auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Statement":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m",
    "Name":"le_antisym",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Statement":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m",
    "Name":"le_antisym",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto using le_antisym.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nHint Resolve le_antisym : core.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6'",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Statement":"Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m",
    "Name":"auto_example_6'",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition is_fortytwo x := (x = 42).",
    "Statement":"Definition is_fortytwo x := (x = 42)",
    "Name":"is_fortytwo",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition is_fortytwo x := (x = 42).",
    "Statement":"Definition is_fortytwo x := (x = 42)",
    "Name":"is_fortytwo",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nHint Unfold is_fortytwo : core.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Statement":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x",
    "Name":"auto_example_7'",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Statement":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x",
    "Name":"auto_example_7'",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step_more",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st2;\n    induction E1; intros st2 E2; inversion E2; subst;\n    auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H1) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H3) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic'_alt: forall c st st1 st2,\n  st =[ c ]=> st1 ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic'_alt: forall c st st1 st2,\n  st =[ c ]=> st1 ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'_alt",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nProof with auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1;\n           intros st2 E2; inversion E2; subst...",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1;\n           intros st2 E2; inversion E2; subst...",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H1) in *...",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite H in H4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H3) in *...",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac rwd H1 H2 := rewrite H1 in H2; discriminate.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic'': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic'': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic''",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H1) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rwd H H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rwd H H5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      rwd H H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rwd H H4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H3) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac find_rwd :=\n  match goal with\n    H1: ?E = true,\n    H2: ?E = false\n    |- _ => rwd H1 H2\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'''",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; try find_rwd; auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H1) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    rewrite (IHE1_1 st'0 H3) in *.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac find_eqn :=\n  match goal with\n    H1: forall x, ?P x -> ?L = ?R,\n    H2: ?P ?X\n    |- _ => rewrite (H1 X H2) in *\n  end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic'''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic'''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic''''",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; try find_rwd;\n    try find_eqn; auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export Repeat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp).",
    "Statement":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp)",
    "Name":"com",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"'repeat' x 'until' y 'end'\" :=\n         (CRepeat x y)\n            (in custom com at level 0,\n             x at level 99, y at level 99).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'skip'\"  :=\n         CSkip (in custom com at level 0).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nNotation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nReserved Notation \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99, st' constr at next level).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Statement":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st')",
    "Name":"ceval",
    "Dependencies":[
      "state",
      "SContinue",
      "CSkip"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Statement":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st')",
    "Name":"ceval",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Statement":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st')",
    "Name":"ceval",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st2;\n  induction E1;\n    intros st2 E2; inversion E2; subst; try find_rwd; try find_eqn; auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n       find_rwd.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n     +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n        find_rwd.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step_more",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Statement":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 E1 E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st2;\n  induction E1;\n    intros st2 E2; inversion E2; subst; try find_eqn; try find_rwd; auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Repeat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample ceval_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Statement":"Example ceval_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2)",
    "Name":"ceval_example1",
    "Dependencies":[
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "t_update",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample ceval_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Statement":"Example ceval_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2)",
    "Name":"ceval_example1",
    "Dependencies":[
      "t_update",
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply E_Seq with (X !-> 2).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply E_Seq with (X !-> 2).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply E_Asgn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply E_IfFalse.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply E_Asgn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample ceval'_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Statement":"Example ceval'_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2)",
    "Name":"ceval'_example1",
    "Dependencies":[
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "t_update",
      "empty_st",
      "aeval",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  eapply E_Seq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply E_Asgn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply E_IfFalse.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply E_Asgn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nHint Constructors ceval : core.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nHint Transparent state total_map : core.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample eauto_example : exists s',\n  (Y !-> 1 ; X !-> 2) =[\n    if (X <= Y)\n      then Z := Y - X\n      else Y := X + Z\n    end\n  ]=> s'.",
    "Statement":"Example eauto_example : exists s',\n  (Y !-> 1 ; X !-> 2) =[\n    if (X <= Y)\n      then Z := Y - X\n      else Y := X + Z\n    end\n  ]=> s'",
    "Name":"eauto_example",
    "Dependencies":[
      "E_IfFalse",
      "E_Asgn",
      "ceval",
      "CIf",
      "CAsgn",
      "t_update",
      "empty_st",
      "aeval",
      "BLe",
      "Z",
      "Y",
      "X",
      "AMinus",
      "APlus",
      "AId",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninfo_eauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma silly2_fixed :\n  forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42.",
    "Statement":"Lemma silly2_fixed :\n  forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42",
    "Name":"silly2_fixed",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HP HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct HP as [y HP'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  eapply HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HP'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma silly2_eassumption : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42.",
    "Statement":"Lemma silly2_eassumption : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42",
    "Name":"silly2_eassumption",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HP HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct HP as [y HP'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\neapply HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\neassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma silly2_eauto : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42.",
    "Statement":"Lemma silly2_eauto : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42",
    "Name":"silly2_eauto",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HP HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct HP as [y HP'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\neauto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_AutoTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Auto.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_AutoTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_BasicsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Basics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_nandb4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_andb34.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_factorial2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_ltb3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_id_exercise.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions mult_n_1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions andb_true_elim2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions zero_nbeq_plus_1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions identity_fn_applied_twice.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.letter_comparison_Eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.test_grade_comparison1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.test_grade_comparison2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.test_grade_comparison3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.test_grade_comparison4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_letter_lowers.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_A_Plus.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_A_Natural.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_A_Minus.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_B_Plus.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_F_Natural.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_twice.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_thrice.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_F_Minus.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.lower_grade_lowers.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.no_penalty_for_mostly_on_time.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions LateDays.grade_lowered_once.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_bin_incr1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_bin_incr2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_bin_incr3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_bin_incr4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_bin_incr5.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_bin_incr6.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_BasicsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Bib.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export Bib.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Bib.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Bib.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_BibTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Bib.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Bib.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_BibTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ImpCEvalFun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export ImpCEvalFun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Stdlib.micromega.Lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.Arith.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.PeanoNat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.EqNat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Imp LF.Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end.",
    "Statement":"Fixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end",
    "Name":"ceval_step1",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end.",
    "Statement":"Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end",
    "Name":"ceval_step2",
    "Dependencies":[
      "t_update",
      "com",
      "empty_st",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end.",
    "Statement":"Fixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end",
    "Name":"ceval_step3",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"'LETOPT' x <== e1 'IN' e2\"\n   := (match e1 with\n         | Some x => e2\n         | None => None\n       end)\n   (right associativity, at level 60).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end.",
    "Statement":"Fixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end",
    "Name":"ceval_step",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end.",
    "Statement":"Definition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end",
    "Name":"test_ceval",
    "Dependencies":[
      "ceval_step",
      "com",
      "Z",
      "Y",
      "X",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample example_test_ceval :\n     test_ceval empty_st\n\n     <{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>\n\n     = Some (2, 0, 4).",
    "Statement":"Example example_test_ceval :\n     test_ceval empty_st\n\n     <{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>\n\n     = Some (2, 0, 4)",
    "Name":"example_test_ceval",
    "Dependencies":[
      "test_ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition pup_to_n : com\n  .",
    "Statement":"Definition pup_to_n : com",
    "Name":"pup_to_n",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition pup_to_n : com\n  .",
    "Statement":"Definition pup_to_n : com",
    "Name":"pup_to_n",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0).",
    "Statement":"Example pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0)",
    "Name":"pup_to_n_1",
    "Dependencies":[
      "t_update",
      "pup_to_n",
      "test_ceval",
      "empty_st",
      "X"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_step__ceval: forall c st st',\n      (exists i, ceval_step st c i = Some st') ->\n      st =[ c ]=> st'.",
    "Statement":"Theorem ceval_step__ceval: forall c st st',\n      (exists i, ceval_step st c i = Some st') ->\n      st =[ c ]=> st'",
    "Name":"ceval_step__ceval",
    "Dependencies":[
      "t_update",
      "ceval_step",
      "E_WhileTrue",
      "E_WhileFalse",
      "E_IfFalse",
      "E_IfTrue",
      "E_Seq",
      "E_Asgn",
      "E_Skip",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st' H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st' H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  inversion H as [i E].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  clear H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent st.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  generalize dependent c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction i as [| i' ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros c st st' H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros c st st' H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros c st st' H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros c st st' H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct c;\n           simpl in H; inversion H; subst; clear H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply E_Skip.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply E_Asgn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n        destruct (ceval_step st c1 i') eqn:Heqr1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n          apply E_Seq with s.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\n          apply E_Seq with s.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n            apply IHi'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Heqr1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n            apply IHi'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n          discriminate H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n        destruct (beval st b) eqn:Heqr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n          apply E_IfTrue.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Heqr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n          apply IHi'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n          apply E_IfFalse.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Heqr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n          apply IHi'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct (beval st b) eqn :Heqr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n         destruct (ceval_step st c i') eqn:Heqr1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n         {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n           apply E_WhileTrue with s.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\n           apply E_WhileTrue with s.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Heqr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n           reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n           apply IHi'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite Heqr1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n           apply IHi'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nassumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n         {",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n          injection H1 as H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n          apply E_WhileFalse.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply Heqr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.",
    "Statement":"Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None",
    "Name":"manual_grade_for_ceval_step__ceval_inf",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_step_more: forall i1 i2 st st' c,\n  i1 <= i2 ->\n  ceval_step st c i1 = Some st' ->\n  ceval_step st c i2 = Some st'.",
    "Statement":"Theorem ceval_step_more: forall i1 i2 st st' c,\n  i1 <= i2 ->\n  ceval_step st c i1 = Some st' ->\n  ceval_step st c i2 = Some st'",
    "Name":"ceval_step_more",
    "Dependencies":[
      "t_update",
      "ceval_step",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction i1 as [|i1']; intros i2 st st' c Hle Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    destruct i2 as [|i2'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion Hle.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    assert (Hle': i1' <= i2') by lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    destruct c.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      destruct (ceval_step st c1 i1') eqn:Heqst1'o.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n        apply (IHi1' i2') in Heqst1'o; try assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        rewrite Heqst1'o.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        apply (IHi1' i2') in Hceval; try assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n        discriminate Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      destruct (beval st b); apply (IHi1' i2') in Hceval;\n        assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      simpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      destruct (beval st b); try assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      destruct (ceval_step st c i1') eqn: Heqst1'o.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n        apply (IHi1' i2') in Heqst1'o; try assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        rewrite -> Heqst1'o.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n        apply (IHi1' i2') in Hceval; try assumption.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      *",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n        simpl in Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndiscriminate Hceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval__ceval_step: forall c st st',\n      st =[ c ]=> st' ->\n      exists i, ceval_step st c i = Some st'.",
    "Statement":"Theorem ceval__ceval_step: forall c st st',\n      st =[ c ]=> st' ->\n      exists i, ceval_step st c i = Some st'",
    "Name":"ceval__ceval_step",
    "Dependencies":[
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st' Hce.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st' Hce.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction Hce.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_and_ceval_step_coincide: forall c st st',\n      st =[ c ]=> st'\n  <-> exists i, ceval_step st c i = Some st'.",
    "Statement":"Theorem ceval_and_ceval_step_coincide: forall c st st',\n      st =[ c ]=> st'\n  <-> exists i, ceval_step st c i = Some st'",
    "Name":"ceval_and_ceval_step_coincide",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step__ceval",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ceval__ceval_step.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ceval_step__ceval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Statement":"Theorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Statement":"Theorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step_more",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Statement":"Theorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2",
    "Name":"ceval_deterministic'",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 He1 He2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros c st st1 st2 He1 He2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ceval__ceval_step in He1.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ceval__ceval_step in He2.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  inversion He1 as [i1 E1].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  inversion He2 as [i2 E2].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ceval_step_more with (i2 := i1 + i2) in E1.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "t_update",
      "ceval_step",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ceval_step_more with (i2 := i1 + i2) in E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "t_update",
      "ceval_step",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  rewrite E1 in E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion E2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  lia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nlia.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd ImpCEvalFun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ImpCEvalFun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ImpParser.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export ImpParser.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Strings.Ascii.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.Arith.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Corelib.Init.Nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.EqNat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Lists.List.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport ListNotations.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Maps LF.Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition isWhite (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n  orb (orb (n =? 32)\n           (n =? 9))\n      (orb (n =? 10)\n           (n =? 13)).",
    "Statement":"Definition isWhite (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n  orb (orb (n =? 32)\n           (n =? 9))\n      (orb (n =? 10)\n           (n =? 13))",
    "Name":"isWhite",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x '<=?' y\" := (x <=? y)\n  (at level 70, no associativity) : nat_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition isLowerAlpha (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n    andb (97 <=? n) (n <=? 122).",
    "Statement":"Definition isLowerAlpha (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n    andb (97 <=? n) (n <=? 122)",
    "Name":"isLowerAlpha",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition isAlpha (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n    orb (andb (65 <=? n) (n <=? 90))\n        (andb (97 <=? n) (n <=? 122)).",
    "Statement":"Definition isAlpha (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n    orb (andb (65 <=? n) (n <=? 90))\n        (andb (97 <=? n) (n <=? 122))",
    "Name":"isAlpha",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition isDigit (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n     andb (48 <=? n) (n <=? 57).",
    "Statement":"Definition isDigit (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n     andb (48 <=? n) (n <=? 57)",
    "Name":"isDigit",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive chartype := white | alpha | digit | other.",
    "Statement":"Inductive chartype := white | alpha | digit | other",
    "Name":"chartype",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition classifyChar (c : ascii) : chartype :=\n  if isWhite c then\n    white\n  else if isAlpha c then\n    alpha\n  else if isDigit c then\n    digit\n  else\n    other.",
    "Statement":"Definition classifyChar (c : ascii) : chartype :=\n  if isWhite c then\n    white\n  else if isAlpha c then\n    alpha\n  else if isDigit c then\n    digit\n  else\n    other",
    "Name":"classifyChar",
    "Dependencies":[
      "other",
      "digit",
      "alpha",
      "white",
      "chartype",
      "isDigit",
      "isAlpha",
      "isWhite"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint list_of_string (s : string) : list ascii :=\n  match s with\n  | EmptyString => []\n  | String c s => c :: (list_of_string s)\n  end.",
    "Statement":"Fixpoint list_of_string (s : string) : list ascii :=\n  match s with\n  | EmptyString => []\n  | String c s => c :: (list_of_string s)\n  end",
    "Name":"list_of_string",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition string_of_list (xs : list ascii) : string :=\n  fold_right String EmptyString xs.",
    "Statement":"Definition string_of_list (xs : list ascii) : string :=\n  fold_right String EmptyString xs",
    "Name":"string_of_list",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition token := string.",
    "Statement":"Definition token := string",
    "Name":"token",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint tokenize_helper (cls : chartype) (acc xs : list ascii)\n                       : list (list ascii) :=\n  let tk := match acc with [] => [] | _::_ => [rev acc] end in\n  match xs with\n  | [] => tk\n  | (x::xs') =>\n    match cls, classifyChar x, x with\n    | _, _, \"(\"      =>\n      tk ++ [\"(\"]::(tokenize_helper other [] xs')\n    | _, _, \")\"      =>\n      tk ++ [\")\"]::(tokenize_helper other [] xs')\n    | _, white, _    =>\n      tk ++ (tokenize_helper white [] xs')\n    | alpha,alpha,x  =>\n      tokenize_helper alpha (x::acc) xs'\n    | digit,digit,x  =>\n      tokenize_helper digit (x::acc) xs'\n    | other,other,x  =>\n      tokenize_helper other (x::acc) xs'\n    | _,tp,x         =>\n      tk ++ (tokenize_helper tp [x] xs')\n    end\n  end %char.",
    "Statement":"Fixpoint tokenize_helper (cls : chartype) (acc xs : list ascii)\n                       : list (list ascii) :=\n  let tk := match acc with [] => [] | _::_ => [rev acc] end in\n  match xs with\n  | [] => tk\n  | (x::xs') =>\n    match cls, classifyChar x, x with\n    | _, _, \"(\"      =>\n      tk ++ [\"(\"]::(tokenize_helper other [] xs')\n    | _, _, \")\"      =>\n      tk ++ [\")\"]::(tokenize_helper other [] xs')\n    | _, white, _    =>\n      tk ++ (tokenize_helper white [] xs')\n    | alpha,alpha,x  =>\n      tokenize_helper alpha (x::acc) xs'\n    | digit,digit,x  =>\n      tokenize_helper digit (x::acc) xs'\n    | other,other,x  =>\n      tokenize_helper other (x::acc) xs'\n    | _,tp,x         =>\n      tk ++ (tokenize_helper tp [x] xs')\n    end\n  end %char",
    "Name":"tokenize_helper",
    "Dependencies":[
      "classifyChar",
      "other",
      "digit",
      "alpha",
      "white",
      "chartype"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition tokenize (s : string) : list string :=\n  map string_of_list (tokenize_helper white [] (list_of_string s)).",
    "Statement":"Definition tokenize (s : string) : list string :=\n  map string_of_list (tokenize_helper white [] (list_of_string s))",
    "Name":"tokenize",
    "Dependencies":[
      "tokenize_helper",
      "string_of_list",
      "list_of_string",
      "white"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample tokenize_ex1 :\n    tokenize \"abc12=3  223*(3+(a+c))\" %string\n  = [\"abc\"; \"12\"; \"=\"; \"3\"; \"223\";\n       \"*\"; \"(\"; \"3\"; \"+\"; \"(\";\n       \"a\"; \"+\"; \"c\"; \")\"; \")\"]%string.",
    "Statement":"Example tokenize_ex1 :\n    tokenize \"abc12=3  223*(3+(a+c))\" %string\n  = [\"abc\"; \"12\"; \"=\"; \"3\"; \"223\";\n       \"*\"; \"(\"; \"3\"; \"+\"; \"(\";\n       \"a\"; \"+\"; \"c\"; \")\"; \")\"]%string",
    "Name":"tokenize_ex1",
    "Dependencies":[
      "tokenize"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive optionE (X:Type) : Type :=\n  | SomeE (x : X)\n  | NoneE (s : string).",
    "Statement":"Inductive optionE (X:Type) : Type :=\n  | SomeE (x : X)\n  | NoneE (s : string)",
    "Name":"optionE",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments SomeE {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments NoneE {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"' p <- e1 ;; e2\"\n   := (match e1 with\n       | SomeE p => e2\n       | NoneE err => NoneE err\n       end)\n   (right associativity, p pattern, at level 60, e1 at next level).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"'TRY' e1 'OR' e2\"\n   := (\n    let result := e1 in\n    match result with\n       | SomeE _  => result\n       | NoneE _ => e2\n       end)\n   (right associativity,\n    at level 60, e1 at next level, e2 at next level).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nOpen Scope string_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition parser (T : Type) :=\n  list token -> optionE (T * list token).",
    "Statement":"Definition parser (T : Type) :=\n  list token -> optionE (T * list token)",
    "Name":"parser",
    "Dependencies":[
      "optionE",
      "token"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint many_helper {T} (p : parser T) acc steps xs :=\n  match steps, p xs with\n  | 0, _ =>\n      NoneE \"Too many recursive calls\"\n  | _, NoneE _ =>\n      SomeE ((rev acc), xs)\n  | S steps', SomeE (t, xs') =>\n      many_helper p (t :: acc) steps' xs'\n  end.",
    "Statement":"Fixpoint many_helper {T} (p : parser T) acc steps xs :=\n  match steps, p xs with\n  | 0, _ =>\n      NoneE \"Too many recursive calls\"\n  | _, NoneE _ =>\n      SomeE ((rev acc), xs)\n  | S steps', SomeE (t, xs') =>\n      many_helper p (t :: acc) steps' xs'\n  end",
    "Name":"many_helper",
    "Dependencies":[
      "parser",
      "NoneE",
      "SomeE",
      "optionE",
      "token"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition many {T} (p : parser T) (steps : nat) : parser (list T) :=\n  many_helper p [] steps.",
    "Statement":"Definition many {T} (p : parser T) (steps : nat) : parser (list T) :=\n  many_helper p [] steps",
    "Name":"many",
    "Dependencies":[
      "many_helper",
      "parser"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition firstExpect {T} (t : token) (p : parser T)\n                     : parser T :=\n  fun xs => match xs with\n            | x::xs' =>\n              if string_dec x t\n              then p xs'\n              else NoneE (\"expected '\" ++ t ++ \"'.\")\n            | [] =>\n              NoneE (\"expected '\" ++ t ++ \"'.\")\n            end.",
    "Statement":"Definition firstExpect {T} (t : token) (p : parser T)\n                     : parser T :=\n  fun xs => match xs with\n            | x::xs' =>\n              if string_dec x t\n              then p xs'\n              else NoneE (\"expected '\" ++ t ++ \"'",
    "Name":"firstExpect",
    "Dependencies":[
      "parser",
      "NoneE",
      "optionE",
      "token"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition expect (t : token) : parser unit :=\n  firstExpect t (fun xs => SomeE (tt, xs)).",
    "Statement":"Definition expect (t : token) : parser unit :=\n  firstExpect t (fun xs => SomeE (tt, xs))",
    "Name":"expect",
    "Dependencies":[
      "firstExpect",
      "parser",
      "SomeE",
      "token"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition parseIdentifier (xs : list token)\n                         : optionE (string * list token) :=\nmatch xs with\n| [] => NoneE \"Expected identifier\"\n| x::xs' =>\n    if forallb isLowerAlpha (list_of_string x) then\n      SomeE (x, xs')\n    else\n      NoneE (\"Illegal identifier:'\" ++ x ++ \"'\")\nend.",
    "Statement":"Definition parseIdentifier (xs : list token)\n                         : optionE (string * list token) :=\nmatch xs with\n| [] => NoneE \"Expected identifier\"\n| x::xs' =>\n    if forallb isLowerAlpha (list_of_string x) then\n      SomeE (x, xs')\n    else\n      NoneE (\"Illegal identifier:'\" ++ x ++ \"'\")\nend",
    "Name":"parseIdentifier",
    "Dependencies":[
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "list_of_string",
      "isLowerAlpha"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition parseNumber (xs : list token)\n                     : optionE (nat * list token) :=\nmatch xs with\n| [] => NoneE \"Expected number\"\n| x::xs' =>\n    if forallb isDigit (list_of_string x) then\n      SomeE (fold_left\n               (fun n d =>\n                  10 * n + (nat_of_ascii d -\n                            nat_of_ascii \"0\"%char))\n               (list_of_string x)\n               0,\n             xs')\n    else\n      NoneE \"Expected number\"\nend.",
    "Statement":"Definition parseNumber (xs : list token)\n                     : optionE (nat * list token) :=\nmatch xs with\n| [] => NoneE \"Expected number\"\n| x::xs' =>\n    if forallb isDigit (list_of_string x) then\n      SomeE (fold_left\n               (fun n d =>\n                  10 * n + (nat_of_ascii d -\n                            nat_of_ascii \"0\"%char))\n               (list_of_string x)\n               0,\n             xs')\n    else\n      NoneE \"Expected number\"\nend",
    "Name":"parseNumber",
    "Dependencies":[
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "list_of_string",
      "isDigit"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint parsePrimaryExp (steps:nat)\n                         (xs : list token)\n                       : optionE (aexp * list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n      TRY ' (i, rest) <- parseIdentifier xs ;;\n          SomeE (AId i, rest)\n      OR\n      TRY ' (n, rest) <- parseNumber xs ;;\n          SomeE (ANum n, rest)\n      OR\n      ' (e, rest) <- firstExpect \"(\" (parseSumExp steps') xs ;;\n      ' (u, rest') <- expect \")\" rest ;;\n      SomeE (e,rest')\n  end\n\nwith parseProductExp (steps:nat)\n                     (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parsePrimaryExp steps' xs ;;\n    ' (es, rest') <- many (firstExpect \"*\" (parsePrimaryExp steps'))\n                          steps' rest ;;\n    SomeE (fold_left AMult es e, rest')\n  end\n\nwith parseSumExp (steps:nat) (xs : list token)  :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parseProductExp steps' xs ;;\n    ' (es, rest') <-\n        many (fun xs =>\n                TRY ' (e,rest') <-\n                    firstExpect \"+\"\n                                (parseProductExp steps') xs ;;\n                    SomeE ( (true, e), rest')\n                OR\n                ' (e, rest') <-\n                    firstExpect \"-\"\n                                (parseProductExp steps') xs ;;\n                SomeE ( (false, e), rest'))\n        steps' rest ;;\n      SomeE (fold_left (fun e0 term =>\n                          match term with\n                          | (true,  e) => APlus e0 e\n                          | (false, e) => AMinus e0 e\n                          end)\n                       es e,\n             rest')\n  end.",
    "Statement":"Fixpoint parsePrimaryExp (steps:nat)\n                         (xs : list token)\n                       : optionE (aexp * list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n      TRY ' (i, rest) <- parseIdentifier xs ;;\n          SomeE (AId i, rest)\n      OR\n      TRY ' (n, rest) <- parseNumber xs ;;\n          SomeE (ANum n, rest)\n      OR\n      ' (e, rest) <- firstExpect \"(\" (parseSumExp steps') xs ;;\n      ' (u, rest') <- expect \")\" rest ;;\n      SomeE (e,rest')\n  end\n\nwith parseProductExp (steps:nat)\n                     (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parsePrimaryExp steps' xs ;;\n    ' (es, rest') <- many (firstExpect \"*\" (parsePrimaryExp steps'))\n                          steps' rest ;;\n    SomeE (fold_left AMult es e, rest')\n  end\n\nwith parseSumExp (steps:nat) (xs : list token)  :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parseProductExp steps' xs ;;\n    ' (es, rest') <-\n        many (fun xs =>\n                TRY ' (e,rest') <-\n                    firstExpect \"+\"\n                                (parseProductExp steps') xs ;;\n                    SomeE ( (true, e), rest')\n                OR\n                ' (e, rest') <-\n                    firstExpect \"-\"\n                                (parseProductExp steps') xs ;;\n                SomeE ( (false, e), rest'))\n        steps' rest ;;\n      SomeE (fold_left (fun e0 term =>\n                          match term with\n                          | (true,  e) => APlus e0 e\n                          | (false, e) => AMinus e0 e\n                          end)\n                       es e,\n             rest')\n  end",
    "Name":"parsePrimaryExp",
    "Dependencies":[
      "parseNumber",
      "parseIdentifier",
      "expect",
      "firstExpect",
      "many",
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "AMult",
      "AMinus",
      "APlus",
      "AId",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition parseAExp := parseSumExp.",
    "Statement":"Definition parseAExp := parseSumExp",
    "Name":"parseAExp",
    "Dependencies":[
      "parseSumExp",
      "optionE",
      "token",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint parseAtomicExp (steps:nat)\n                        (xs : list token)  :=\nmatch steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n     TRY ' (u,rest) <- expect \"true\" xs ;;\n         SomeE (BTrue,rest)\n     OR\n     TRY ' (u,rest) <- expect \"false\" xs ;;\n         SomeE (BFalse,rest)\n     OR\n     TRY ' (e,rest) <- firstExpect \"~\"\n                                   (parseAtomicExp steps')\n                                   xs ;;\n         SomeE (BNot e, rest)\n     OR\n     TRY ' (e,rest) <- firstExpect \"(\"\n                                   (parseConjunctionExp steps')\n                                   xs ;;\n         ' (u,rest') <- expect \")\" rest ;;\n         SomeE (e, rest')\n     OR\n     ' (e, rest) <- parseProductExp steps' xs ;;\n     TRY ' (e', rest') <- firstExpect \"=\"\n                                  (parseAExp steps') rest ;;\n         SomeE (BEq e e', rest')\n     OR\n     TRY ' (e', rest') <- firstExpect \"<=\"\n                                      (parseAExp steps') rest ;;\n         SomeE (BLe e e', rest')\n     OR\n     NoneE \"Expected '=' or '<=' after arithmetic expression\"\nend\n\nwith parseConjunctionExp (steps:nat)\n                         (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parseAtomicExp steps' xs ;;\n    ' (es, rest') <- many (firstExpect \"&&\"\n               (parseAtomicExp steps'))\n            steps' rest ;;\n    SomeE (fold_left BAnd es e, rest')\n  end.",
    "Statement":"Fixpoint parseAtomicExp (steps:nat)\n                        (xs : list token)  :=\nmatch steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n     TRY ' (u,rest) <- expect \"true\" xs ;;\n         SomeE (BTrue,rest)\n     OR\n     TRY ' (u,rest) <- expect \"false\" xs ;;\n         SomeE (BFalse,rest)\n     OR\n     TRY ' (e,rest) <- firstExpect \"~\"\n                                   (parseAtomicExp steps')\n                                   xs ;;\n         SomeE (BNot e, rest)\n     OR\n     TRY ' (e,rest) <- firstExpect \"(\"\n                                   (parseConjunctionExp steps')\n                                   xs ;;\n         ' (u,rest') <- expect \")\" rest ;;\n         SomeE (e, rest')\n     OR\n     ' (e, rest) <- parseProductExp steps' xs ;;\n     TRY ' (e', rest') <- firstExpect \"=\"\n                                  (parseAExp steps') rest ;;\n         SomeE (BEq e e', rest')\n     OR\n     TRY ' (e', rest') <- firstExpect \"<=\"\n                                      (parseAExp steps') rest ;;\n         SomeE (BLe e e', rest')\n     OR\n     NoneE \"Expected '=' or '<=' after arithmetic expression\"\nend\n\nwith parseConjunctionExp (steps:nat)\n                         (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parseAtomicExp steps' xs ;;\n    ' (es, rest') <- many (firstExpect \"&&\"\n               (parseAtomicExp steps'))\n            steps' rest ;;\n    SomeE (fold_left BAnd es e, rest')\n  end",
    "Name":"parseAtomicExp",
    "Dependencies":[
      "parseAExp",
      "parseProductExp",
      "expect",
      "firstExpect",
      "many",
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "BAnd",
      "BNot",
      "BLe",
      "BEq",
      "BFalse",
      "BTrue",
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition parseBExp := parseConjunctionExp.",
    "Statement":"Definition parseBExp := parseConjunctionExp",
    "Name":"parseBExp",
    "Dependencies":[
      "parseConjunctionExp",
      "optionE",
      "token",
      "bexp"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck parseConjunctionExp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition testParsing {X : Type}\n           (p : nat ->\n                list token ->\n                optionE (X * list token))\n           (s : string) :=\n  let t := tokenize s in\n  p 100 t.",
    "Statement":"Definition testParsing {X : Type}\n           (p : nat ->\n                list token ->\n                optionE (X * list token))\n           (s : string) :=\n  let t := tokenize s in\n  p 100 t",
    "Name":"testParsing",
    "Dependencies":[
      "optionE",
      "tokenize",
      "token"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint parseSimpleCommand (steps:nat)\n                            (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    TRY ' (u, rest) <- expect \"skip\" xs ;;\n        SomeE (<{skip}>, rest)\n    OR\n    TRY ' (e,rest) <-\n            firstExpect \"if\"\n                        (parseBExp steps') xs ;;\n        ' (c,rest') <-\n            firstExpect \"then\"\n                        (parseSequencedCommand steps') rest ;;\n        ' (c',rest'') <-\n            firstExpect \"else\"\n                        (parseSequencedCommand steps') rest' ;;\n        ' (tt,rest''') <-\n            expect \"end\" rest'' ;;\n       SomeE(<{if e then c else c' end}>, rest''')\n    OR\n    TRY ' (e,rest) <-\n            firstExpect \"while\"\n                        (parseBExp steps') xs ;;\n        ' (c,rest') <-\n            firstExpect \"do\"\n                        (parseSequencedCommand steps') rest ;;\n        ' (u,rest'') <-\n            expect \"end\" rest' ;;\n        SomeE(<{while e do c end}>, rest'')\n    OR\n    TRY ' (i, rest) <- parseIdentifier xs ;;\n        ' (e, rest') <- firstExpect \":=\" (parseAExp steps') rest ;;\n        SomeE (<{i := e}>, rest')\n    OR\n        NoneE \"Expecting a command\"\nend\n\nwith parseSequencedCommand (steps:nat)\n                           (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (c, rest) <- parseSimpleCommand steps' xs ;;\n    TRY ' (c', rest') <-\n            firstExpect \";\"\n                        (parseSequencedCommand steps') rest ;;\n        SomeE (<{c ; c'}>, rest')\n    OR\n    SomeE (c, rest)\n  end.",
    "Statement":"Fixpoint parseSimpleCommand (steps:nat)\n                            (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    TRY ' (u, rest) <- expect \"skip\" xs ;;\n        SomeE (<{skip}>, rest)\n    OR\n    TRY ' (e,rest) <-\n            firstExpect \"if\"\n                        (parseBExp steps') xs ;;\n        ' (c,rest') <-\n            firstExpect \"then\"\n                        (parseSequencedCommand steps') rest ;;\n        ' (c',rest'') <-\n            firstExpect \"else\"\n                        (parseSequencedCommand steps') rest' ;;\n        ' (tt,rest''') <-\n            expect \"end\" rest'' ;;\n       SomeE(<{if e then c else c' end}>, rest''')\n    OR\n    TRY ' (e,rest) <-\n            firstExpect \"while\"\n                        (parseBExp steps') xs ;;\n        ' (c,rest') <-\n            firstExpect \"do\"\n                        (parseSequencedCommand steps') rest ;;\n        ' (u,rest'') <-\n            expect \"end\" rest' ;;\n        SomeE(<{while e do c end}>, rest'')\n    OR\n    TRY ' (i, rest) <- parseIdentifier xs ;;\n        ' (e, rest') <- firstExpect \":=\" (parseAExp steps') rest ;;\n        SomeE (<{i := e}>, rest')\n    OR\n        NoneE \"Expecting a command\"\nend\n\nwith parseSequencedCommand (steps:nat)\n                           (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (c, rest) <- parseSimpleCommand steps' xs ;;\n    TRY ' (c', rest') <-\n            firstExpect \";\"\n                        (parseSequencedCommand steps') rest ;;\n        SomeE (<{c ; c'}>, rest')\n    OR\n    SomeE (c, rest)\n  end",
    "Name":"parseSimpleCommand",
    "Dependencies":[
      "parseBExp",
      "parseAExp",
      "parseIdentifier",
      "expect",
      "firstExpect",
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition bignumber := 1000.",
    "Statement":"Definition bignumber := 1000",
    "Name":"bignumber",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition parse (str : string) : optionE com :=\n  let tokens := tokenize str in\n  match parseSequencedCommand bignumber tokens with\n  | SomeE (c, []) => SomeE c\n  | SomeE (_, t::_) => NoneE (\"Trailing tokens remaining: \" ++ t)\n  | NoneE err => NoneE err\n  end.",
    "Statement":"Definition parse (str : string) : optionE com :=\n  let tokens := tokenize str in\n  match parseSequencedCommand bignumber tokens with\n  | SomeE (c, []) => SomeE c\n  | SomeE (_, t::_) => NoneE (\"Trailing tokens remaining: \" ++ t)\n  | NoneE err => NoneE err\n  end",
    "Name":"parse",
    "Dependencies":[
      "bignumber",
      "parseSequencedCommand",
      "NoneE",
      "SomeE",
      "optionE",
      "tokenize",
      "token",
      "com"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample eg1 : parse \"\n  if x = y + 1 + 2 - y * 6 + 3 then\n    x := x * 1;\n    y := 0\n  else\n    skip\n  end  \"\n=\n  SomeE <{\n      if (\"x\" = (\"y\" + 1 + 2 - \"y\" * 6 + 3)) then\n        \"x\" := \"x\" * 1;\n        \"y\" := 0\n      else\n        skip\n      end }>.",
    "Statement":"Example eg1 : parse \"\n  if x = y + 1 + 2 - y * 6 + 3 then\n    x := x * 1;\n    y := 0\n  else\n    skip\n  end  \"\n=\n  SomeE <{\n      if (\"x\" = (\"y\" + 1 + 2 - \"y\" * 6 + 3)) then\n        \"x\" := \"x\" * 1;\n        \"y\" := 0\n      else\n        skip\n      end }>",
    "Name":"eg1",
    "Dependencies":[
      "parse",
      "SomeE",
      "optionE",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "BEq",
      "AMult",
      "AMinus",
      "APlus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ncbv.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nExample eg2 : parse \"\n  skip;\n  z:=x*y*(x*x);\n  while x=x do\n    if (z <= z*z) && ~(x = 2) then\n      x := z;\n      y := z\n    else\n      skip\n    end;\n    skip\n  end;\n  x:=z  \"\n=\n  SomeE <{\n      skip;\n      \"z\" := \"x\" * \"y\" * (\"x\" * \"x\");\n      while (\"x\" = \"x\") do\n        if (\"z\" <= \"z\" * \"z\") && ~(\"x\" = 2) then\n          \"x\" := \"z\";\n          \"y\" := \"z\"\n        else\n          skip\n        end;\n        skip\n      end;\n      \"x\" := \"z\" }>.",
    "Statement":"Example eg2 : parse \"\n  skip;\n  z:=x*y*(x*x);\n  while x=x do\n    if (z <= z*z) && ~(x = 2) then\n      x := z;\n      y := z\n    else\n      skip\n    end;\n    skip\n  end;\n  x:=z  \"\n=\n  SomeE <{\n      skip;\n      \"z\" := \"x\" * \"y\" * (\"x\" * \"x\");\n      while (\"x\" = \"x\") do\n        if (\"z\" <= \"z\" * \"z\") && ~(\"x\" = 2) then\n          \"x\" := \"z\";\n          \"y\" := \"z\"\n        else\n          skip\n        end;\n        skip\n      end;\n      \"x\" := \"z\" }>",
    "Name":"eg2",
    "Dependencies":[
      "parse",
      "SomeE",
      "optionE",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "BAnd",
      "BNot",
      "BLe",
      "BEq",
      "AMult",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ncbv.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd ImpParser.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ImpParser.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Extraction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export Extraction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExtraction Language OCaml.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Stdlib.Arith.Arith.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Corelib.Init.Nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.Arith.EqNat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ImpCEvalFun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExtraction \"imp1.ml\" ceval_step.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExtract Inductive bool => \"bool\" [ \"true\" \"false\" ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExtract Inductive nat => \"int\"\n  [ \"0\" \"(fun x -> x + 1)\" ]\n  \"(fun zero succ n ->\n      if n=0 then zero () else succ (n-1))\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExtract Constant plus => \"( + )\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExtract Constant mult => \"( * )\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExtract Constant eqb => \"( = )\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExtraction \"imp2.ml\" ceval_step.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport Corelib.extraction.ExtrOcamlBasic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Stdlib.extraction.ExtrOcamlString.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nExtract Inductive sumbool => \"bool\" [\"true\" \"false\"].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nImport LF.Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ImpParser.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExtraction \"imp.ml\" empty_st ceval_step parse.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Extraction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Extraction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ExtractionTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Extraction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Extraction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ExtractionTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ImpCEvalFunTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ImpCEvalFun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ImpCEvalFun.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ceval__ceval_step.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ImpCEvalFunTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ImpParserTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ImpParser.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ImpParser.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ImpParserTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ImpTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Imp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions AExp.optimize_0plus_b_test1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions AExp.optimize_0plus_b_test2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions AExp.optimize_0plus_b_sound.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions AExp.bevalR_iff_beval.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ceval_example2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions loop_never_stops.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions no_whiles_eqv.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions s_execute1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions s_execute2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions s_compile1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions execute_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions s_compile_correct_aux.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions s_compile_correct.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions BreakImp.break_ignore.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions BreakImp.while_continue.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions BreakImp.while_stops_on_break.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions BreakImp.seq_continue.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions BreakImp.seq_stops_on_break.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ImpTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ProofObjects.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export ProofObjects.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport LF.IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Statement":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n))",
    "Name":"ev",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4 : ev 4.",
    "Statement":"Theorem ev_4 : ev 4",
    "Name":"ev_4",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4 : ev 4.",
    "Statement":"Theorem ev_4 : ev 4",
    "Name":"ev_4",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply ev_0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint ev_4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4': ev 4.",
    "Statement":"Theorem ev_4': ev 4",
    "Name":"ev_4'",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4': ev 4.",
    "Statement":"Theorem ev_4': ev 4",
    "Name":"ev_4'",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply (ev_SS 2 (ev_SS 0 ev_0)).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_4'' : ev 4.",
    "Statement":"Theorem ev_4'' : ev 4",
    "Name":"ev_4''",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n  Show Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n  Show Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n  Show Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n  Show Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0).",
    "Statement":"Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0)",
    "Name":"ev_4'''",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint ev_4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint ev_4'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint ev_4''.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint ev_4'''.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_8 : ev 8.",
    "Statement":"Theorem ev_8 : ev 8",
    "Name":"ev_8",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ev_8' : ev 8\n  .",
    "Statement":"Definition ev_8' : ev 8",
    "Name":"ev_8'",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Statement":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n)",
    "Name":"ev_plus4",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Statement":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n)",
    "Name":"ev_plus4",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H).",
    "Statement":"Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H)",
    "Name":"ev_plus4'",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H).",
    "Statement":"Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H)",
    "Name":"ev_plus4''",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_plus4'' : forall n : nat, ev n -> ev (4 + n).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2).",
    "Statement":"Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2)",
    "Name":"ev_plus2",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2).",
    "Statement":"Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2)",
    "Name":"ev_plus2'",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2).",
    "Statement":"Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)",
    "Name":"ev_plus2''",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition add1 : nat -> nat.",
    "Statement":"Definition add1 : nat -> nat",
    "Name":"add1",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintro n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nShow Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nShow Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nDefined.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint add1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCompute add1 2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Props.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule And.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q.",
    "Statement":"Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q",
    "Name":"and",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments conj [P] [Q].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"P \/\\ Q\" := (and P Q) : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint prod.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem proj1' : forall P Q,\n  P \/\\ Q -> P.",
    "Statement":"Theorem proj1' : forall P Q,\n  P \/\\ Q -> P",
    "Name":"proj1'",
    "Dependencies":[
      "and"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HPQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ndestruct HPQ as [HP HQ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n  Show Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma and_comm : forall P Q : Prop, P \/\\ Q <-> Q \/\\ P.",
    "Statement":"Lemma and_comm : forall P Q : Prop, P \/\\ Q <-> Q \/\\ P",
    "Name":"and_comm",
    "Dependencies":[
      "conj",
      "and"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros [HP HQ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n intros [HQ HP].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd And.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition proj1'' P Q (HPQ : P \/\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end.",
    "Statement":"Definition proj1'' P Q (HPQ : P \/\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end",
    "Name":"proj1''",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition and_comm'_aux P Q (H : P \/\\ Q) : Q \/\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end.",
    "Statement":"Definition and_comm'_aux P Q (H : P \/\\ Q) : Q \/\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end",
    "Name":"and_comm'_aux",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition and_comm' P Q : P \/\\ Q <-> Q \/\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P).",
    "Statement":"Definition and_comm' P Q : P \/\\ Q <-> Q \/\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P)",
    "Name":"and_comm'",
    "Dependencies":[
      "and_comm'_aux"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition conj_fact : forall P Q R, P \/\\ Q -> Q \/\\ R -> P \/\\ R\n  .",
    "Statement":"Definition conj_fact : forall P Q R, P \/\\ Q -> Q \/\\ R -> P \/\\ R",
    "Name":"conj_fact",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q.",
    "Statement":"Inductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q",
    "Name":"or",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments or_introl [P] [Q].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments or_intror [P] [Q].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"P \\\/ Q\" := (or P Q) : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition inj_l : forall (P Q : Prop), P -> P \\\/ Q :=\n  fun P Q HP => or_introl HP.",
    "Statement":"Definition inj_l : forall (P Q : Prop), P -> P \\\/ Q :=\n  fun P Q HP => or_introl HP",
    "Name":"inj_l",
    "Dependencies":[
      "or_introl",
      "or"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem inj_l' : forall (P Q : Prop), P -> P \\\/ Q.",
    "Statement":"Theorem inj_l' : forall (P Q : Prop), P -> P \\\/ Q",
    "Name":"inj_l'",
    "Dependencies":[
      "or_introl",
      "or"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nleft.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n  Show Proof.",
    "Statement":"Show Proof",
    "Name":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition or_elim : forall (P Q R : Prop), (P \\\/ Q) -> (P -> R) -> (Q -> R) -> R :=\n  fun P Q R HPQ HPR HQR =>\n    match HPQ with\n    | or_introl HP => HPR HP\n    | or_intror HQ => HQR HQ\n    end.",
    "Statement":"Definition or_elim : forall (P Q R : Prop), (P \\\/ Q) -> (P -> R) -> (Q -> R) -> R :=\n  fun P Q R HPQ HPR HQR =>\n    match HPQ with\n    | or_introl HP => HPR HP\n    | or_intror HQ => HQR HQ\n    end",
    "Name":"or_elim",
    "Dependencies":[
      "or"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem or_elim' : forall (P Q R : Prop), (P \\\/ Q) -> (P -> R) -> (Q -> R) -> R.",
    "Statement":"Theorem or_elim' : forall (P Q R : Prop), (P \\\/ Q) -> (P -> R) -> (Q -> R) -> R",
    "Name":"or_elim'",
    "Dependencies":[
      "or"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros P Q R HPQ HPR HQR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  destruct HPQ as [HP | HQ].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply HPR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HP.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply HQR.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply HQ.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition or_commut' : forall P Q, P \\\/ Q -> Q \\\/ P\n  .",
    "Statement":"Definition or_commut' : forall P Q, P \\\/ Q -> Q \\\/ P",
    "Name":"or_commut'",
    "Dependencies":[
      "or"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ex {A : Type} (P : A -> Prop) : Prop :=\n  | ex_intro : forall x : A, P x -> ex P.",
    "Statement":"Inductive ex {A : Type} (P : A -> Prop) : Prop :=\n  | ex_intro : forall x : A, P x -> ex P",
    "Name":"ex",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"'exists' x , p\" :=\n  (ex (fun x => p))\n    (at level 200, right associativity) : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ex (fun n => ev n) : Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition some_nat_is_even : exists n, ev n :=\n  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0)).",
    "Statement":"Definition some_nat_is_even : exists n, ev n :=\n  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0))",
    "Name":"some_nat_is_even",
    "Dependencies":[
      "ex_intro",
      "ex",
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ex_ev_Sn : ex (fun n => ev (S n))\n  .",
    "Statement":"Definition ex_ev_Sn : ex (fun n => ev (S n))",
    "Name":"ex_ev_Sn",
    "Dependencies":[
      "ex",
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition dist_exists_or_term (X:Type) (P Q : X -> Prop) :\n  (exists x, P x \\\/ Q x) -> (exists x, P x) \\\/ (exists x, Q x) :=\n  fun H => match H with\n           | ex_intro _ x Hx =>\n               match Hx with\n               | or_introl HPx => or_introl (ex_intro _ x HPx)\n               | or_intror HQx => or_intror (ex_intro _ x HQx)\n               end\n           end.",
    "Statement":"Definition dist_exists_or_term (X:Type) (P Q : X -> Prop) :\n  (exists x, P x \\\/ Q x) -> (exists x, P x) \\\/ (exists x, Q x) :=\n  fun H => match H with\n           | ex_intro _ x Hx =>\n               match Hx with\n               | or_introl HPx => or_introl (ex_intro _ x HPx)\n               | or_intror HQx => or_intror (ex_intro _ x HQx)\n               end\n           end",
    "Name":"dist_exists_or_term",
    "Dependencies":[
      "ex_intro",
      "ex",
      "or_intror",
      "or_introl",
      "or"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ex_match : forall (A : Type) (P Q : A -> Prop),\n  (forall x, P x -> Q x) ->\n  (exists x, P x) -> (exists x, Q x)\n  .",
    "Statement":"Definition ex_match : forall (A : Type) (P Q : A -> Prop),\n  (forall x, P x -> Q x) ->\n  (exists x, P x) -> (exists x, Q x)",
    "Name":"ex_match",
    "Dependencies":[
      "ex"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive True : Prop :=\n  | I : True.",
    "Statement":"Inductive True : Prop :=\n  | I : True",
    "Name":"True",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition p_implies_true : forall P, P -> True\n  .",
    "Statement":"Definition p_implies_true : forall P, P -> True",
    "Name":"p_implies_true",
    "Dependencies":[
      "True"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive False : Prop := .",
    "Statement":"Inductive False : Prop :=",
    "Name":"False",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail\n  Definition contra : False :=\n  42.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition false_implies_zero_eq_one : False -> 0 = 1 :=\n  fun contra => match contra with end.",
    "Statement":"Definition false_implies_zero_eq_one : False -> 0 = 1 :=\n  fun contra => match contra with end",
    "Name":"false_implies_zero_eq_one",
    "Dependencies":[
      "False"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition ex_falso_quodlibet' : forall P, False -> P\n  .",
    "Statement":"Definition ex_falso_quodlibet' : forall P, False -> P",
    "Name":"ex_falso_quodlibet'",
    "Dependencies":[
      "False"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Props.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export EqualityPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive eq {X:Type} : X -> X -> Prop :=\n  | eq_refl : forall x, eq x x.",
    "Statement":"Inductive eq {X:Type} : X -> X -> Prop :=\n  | eq_refl : forall x, eq x x",
    "Name":"eq",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"x == y\" := (eq x y)\n                       (at level 70, no associativity)\n                     : type_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma four: 2 + 2 == 1 + 3.",
    "Statement":"Lemma four: 2 + 2 == 1 + 3",
    "Name":"four",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply eq_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition four' : 2 + 2 == 1 + 3 :=\n  eq_refl 4.",
    "Statement":"Definition four' : 2 + 2 == 1 + 3 :=\n  eq_refl 4",
    "Name":"four'",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition singleton : forall (X:Type) (x:X), []++[x] == x::[]  :=\n  fun (X:Type) (x:X) => eq_refl [x].",
    "Statement":"Definition singleton : forall (X:Type) (x:X), []++[x] == x::[]  :=\n  fun (X:Type) (x:X) => eq_refl [x]",
    "Name":"singleton",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition eq_add : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2) :=\n  fun n1 n2 Heq =>\n    match Heq with\n    | eq_refl n => eq_refl (S n)\n    end.",
    "Statement":"Definition eq_add : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2) :=\n  fun n1 n2 Heq =>\n    match Heq with\n    | eq_refl n => eq_refl (S n)\n    end",
    "Name":"eq_add",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem eq_add' : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2).",
    "Statement":"Theorem eq_add' : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2)",
    "Name":"eq_add'",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n1 n2 Heq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Fail rewrite Heq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  destruct Heq as [n].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  Fail reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  apply eq_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition eq_cons : forall (X : Type) (h1 h2 : X) (t1 t2 : list X),\n    h1 == h2 -> t1 == t2 -> h1 :: t1 == h2 :: t2\n  .",
    "Statement":"Definition eq_cons : forall (X : Type) (h1 h2 : X) (t1 t2 : list X),\n    h1 == h2 -> t1 == t2 -> h1 :: t1 == h2 :: t2",
    "Name":"eq_cons",
    "Dependencies":[
      "cons",
      "list",
      "eq"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma equality__leibniz_equality : forall (X : Type) (x y: X),\n  x == y -> forall (P : X -> Prop), P x -> P y.",
    "Statement":"Lemma equality__leibniz_equality : forall (X : Type) (x y: X),\n  x == y -> forall (P : X -> Prop), P x -> P y",
    "Name":"equality__leibniz_equality",
    "Dependencies":[
      "eq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition equality__leibniz_equality_term : forall (X : Type) (x y: X),\n    x == y -> forall P : (X -> Prop), P x -> P y\n  .",
    "Statement":"Definition equality__leibniz_equality_term : forall (X : Type) (x y: X),\n    x == y -> forall P : (X -> Prop), P x -> P y",
    "Name":"equality__leibniz_equality_term",
    "Dependencies":[
      "eq"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma leibniz_equality__equality : forall (X : Type) (x y: X),\n  (forall P:X->Prop, P x -> P y) -> x == y.",
    "Statement":"Lemma leibniz_equality__equality : forall (X : Type) (x y: X),\n  (forall P:X->Prop, P x -> P y) -> x == y",
    "Name":"leibniz_equality__equality",
    "Dependencies":[
      "eq"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd EqualityPlayground.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Definition or_bogus : forall P Q, P \\\/ Q -> P :=\n  fun (P Q : Prop) (A : P \\\/ Q) =>\n    match A with\n    | or_introl H => H\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Fixpoint infinite_loop {X : Type} (n : nat) {struct n} : X :=\n  infinite_loop n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nFail Definition falso : False := infinite_loop 0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition and_assoc : forall P Q R : Prop,\n    P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R\n  .",
    "Statement":"Definition and_assoc : forall P Q R : Prop,\n    P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R",
    "Name":"and_assoc",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition and_assoc : forall P Q R : Prop,\n    P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R\n  .",
    "Statement":"Definition and_assoc : forall P Q R : Prop,\n    P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R",
    "Name":"and_assoc",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition or_distributes_over_and : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)\n  .",
    "Statement":"Definition or_distributes_over_and : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)",
    "Name":"or_distributes_over_and",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition or_distributes_over_and : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)\n  .",
    "Statement":"Definition or_distributes_over_and : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)",
    "Name":"or_distributes_over_and",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition double_neg : forall P : Prop,\n    P -> ~~P\n  .",
    "Statement":"Definition double_neg : forall P : Prop,\n    P -> ~~P",
    "Name":"double_neg",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition double_neg : forall P : Prop,\n    P -> ~~P\n  .",
    "Statement":"Definition double_neg : forall P : Prop,\n    P -> ~~P",
    "Name":"double_neg",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition contradiction_implies_anything : forall P Q : Prop,\n    (P \/\\ ~P) -> Q\n  .",
    "Statement":"Definition contradiction_implies_anything : forall P Q : Prop,\n    (P \/\\ ~P) -> Q",
    "Name":"contradiction_implies_anything",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition contradiction_implies_anything : forall P Q : Prop,\n    (P \/\\ ~P) -> Q\n  .",
    "Statement":"Definition contradiction_implies_anything : forall P Q : Prop,\n    (P \/\\ ~P) -> Q",
    "Name":"contradiction_implies_anything",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q\n  .",
    "Statement":"Definition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q",
    "Name":"de_morgan_not_or",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q\n  .",
    "Statement":"Definition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q",
    "Name":"de_morgan_not_or",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition curry : forall P Q R : Prop,\n    ((P \/\\ Q) -> R) -> (P -> (Q -> R))\n  .",
    "Statement":"Definition curry : forall P Q R : Prop,\n    ((P \/\\ Q) -> R) -> (P -> (Q -> R))",
    "Name":"curry",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition uncurry : forall P Q R : Prop,\n    (P -> (Q -> R)) -> ((P \/\\ Q) -> R)\n  .",
    "Statement":"Definition uncurry : forall P Q R : Prop,\n    (P -> (Q -> R)) -> ((P \/\\ Q) -> R)",
    "Name":"uncurry",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition propositional_extensionality : Prop :=\n  forall (P Q : Prop), (P <-> Q) -> P = Q.",
    "Statement":"Definition propositional_extensionality : Prop :=\n  forall (P Q : Prop), (P <-> Q) -> P = Q",
    "Name":"propositional_extensionality",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem pe_implies_or_eq :\n  propositional_extensionality ->\n  forall (P Q : Prop), (P \\\/ Q) = (Q \\\/ P).",
    "Statement":"Theorem pe_implies_or_eq :\n  propositional_extensionality ->\n  forall (P Q : Prop), (P \\\/ Q) = (Q \\\/ P)",
    "Name":"pe_implies_or_eq",
    "Dependencies":[
      "propositional_extensionality"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma pe_implies_true_eq :\n  propositional_extensionality ->\n  forall (P : Prop), P -> True = P.",
    "Statement":"Lemma pe_implies_true_eq :\n  propositional_extensionality ->\n  forall (P : Prop), P -> True = P",
    "Name":"pe_implies_true_eq",
    "Dependencies":[
      "propositional_extensionality"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition proof_irrelevance : Prop :=\n  forall (P : Prop) (pf1 pf2 : P), pf1 = pf2.",
    "Statement":"Definition proof_irrelevance : Prop :=\n  forall (P : Prop) (pf1 pf2 : P), pf1 = pf2",
    "Name":"proof_irrelevance",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem pe_implies_pi :\n  propositional_extensionality -> proof_irrelevance.",
    "Statement":"Theorem pe_implies_pi :\n  propositional_extensionality -> proof_irrelevance",
    "Name":"pe_implies_pi",
    "Dependencies":[
      "proof_irrelevance",
      "propositional_extensionality"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd ProofObjects.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ProofObjects.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_IndPrinciples.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export IndPrinciples.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport LF.ProofObjects.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "S",
      "O",
      "nat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mul_0_r' : forall n:nat,\n  n * 0 = 0.",
    "Statement":"Theorem mul_0_r' : forall n:nat,\n  n * 0 = 0",
    "Name":"mul_0_r'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply nat_ind.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n' IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem plus_one_r' : forall n:nat,\n  n + 1 = S n.",
    "Statement":"Theorem plus_one_r' : forall n:nat,\n  n + 1 = S n",
    "Name":"plus_one_r'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive time : Type :=\n  | day\n  | night.",
    "Statement":"Inductive time : Type :=\n  | day\n  | night",
    "Name":"time",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "night",
      "day",
      "time"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Statement":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue",
    "Name":"rgb",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Statement":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue",
    "Name":"rgb",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck rgb_ind.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist).",
    "Statement":"Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)",
    "Name":"natlist",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist).",
    "Statement":"Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist)",
    "Name":"natlist",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ncons",
      "nnil",
      "natlist"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat).",
    "Statement":"Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat)",
    "Name":"natlist'",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "nsnoc",
      "nnil'",
      "natlist'"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree).",
    "Statement":"Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree)",
    "Name":"booltree",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition booltree_property_type : Type := booltree -> Prop.",
    "Statement":"Definition booltree_property_type : Type := booltree -> Prop",
    "Name":"booltree_property_type",
    "Dependencies":[
      "booltree"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition base_case (P : booltree_property_type) : Prop\n  .",
    "Statement":"Definition base_case (P : booltree_property_type) : Prop",
    "Name":"base_case",
    "Dependencies":[
      "booltree_property_type"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition leaf_case (P : booltree_property_type) : Prop\n  .",
    "Statement":"Definition leaf_case (P : booltree_property_type) : Prop",
    "Name":"leaf_case",
    "Dependencies":[
      "booltree_property_type"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition branch_case (P : booltree_property_type) : Prop\n  .",
    "Statement":"Definition branch_case (P : booltree_property_type) : Prop",
    "Name":"branch_case",
    "Dependencies":[
      "booltree_property_type"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b.",
    "Statement":"Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b",
    "Name":"booltree_ind_type",
    "Dependencies":[
      "branch_case",
      "leaf_case",
      "base_case",
      "booltree_property_type",
      "booltree"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem booltree_ind_type_correct : booltree_ind_type.",
    "Statement":"Theorem booltree_ind_type_correct : booltree_ind_type",
    "Name":"booltree_ind_type_correct",
    "Dependencies":[
      "booltree_ind_type"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive Toy : Type :=\n\n.",
    "Statement":"Inductive Toy : Type :=",
    "Name":"Toy",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem Toy_correct : exists f g,\n  forall P : Toy -> Prop,\n    (forall b : bool, P (f b)) ->\n    (forall (n : nat) (t : Toy), P t -> P (g n t)) ->\n    forall t : Toy, P t.",
    "Statement":"Theorem Toy_correct : exists f g,\n  forall P : Toy -> Prop,\n    (forall b : bool, P (f b)) ->\n    (forall (n : nat) (t : Toy), P t -> P (g n t)) ->\n    forall t : Toy, P t",
    "Name":"Toy_correct",
    "Dependencies":[
      "Toy",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X).",
    "Statement":"Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X)",
    "Name":"tree",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck tree_ind.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2.",
    "Statement":"Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2",
    "Name":"foo'",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2.",
    "Statement":"Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2",
    "Name":"foo'",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition P_m0r (n:nat) : Prop :=\n  n * 0 = 0.",
    "Statement":"Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0",
    "Name":"P_m0r",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0.",
    "Statement":"Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0",
    "Name":"P_m0r'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem mul_0_r'' : forall n:nat,\n  P_m0r n.",
    "Statement":"Theorem mul_0_r'' : forall n:nat,\n  P_m0r n",
    "Name":"mul_0_r''",
    "Dependencies":[
      "P_m0r"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply nat_ind.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros n IHn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    unfold P_m0r in IHn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold P_m0r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Statement":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p",
    "Name":"add_assoc'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  intros n m p.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  induction n as [| n'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_comm' : forall n m : nat,\n  n + m = m + n.",
    "Statement":"Theorem add_comm' : forall n m : nat,\n  n + m = m + n",
    "Name":"add_comm'",
    "Dependencies":[
      "plus_n_Sm",
      "add_0_r"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction n as [| n'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> add_0_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsimpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite <- plus_n_Sm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem add_comm'' : forall n m : nat,\n  n + m = m + n.",
    "Statement":"Theorem add_comm'' : forall n m : nat,\n  n + m = m + n",
    "Name":"add_comm''",
    "Dependencies":[
      "plus_n_Sm",
      "add_0_r"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  induction m as [| m'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite -> add_0_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  simpl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nrewrite <- IHm'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    rewrite <- plus_n_Sm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nreflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint ev.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Statement":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)",
    "Name":"ev'",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Statement":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m)",
    "Name":"ev'",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem ev_ev' : forall n, ev n -> ev' n.",
    "Statement":"Theorem ev_ev' : forall n, ev n -> ev' n",
    "Name":"ev_ev'",
    "Dependencies":[
      "ev_ind",
      "ev",
      "ev'_sum",
      "ev'_2",
      "ev'_0",
      "ev'"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply ev_ind.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    apply ev'_0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intros m Hm IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply (ev'_sum 2 m).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply ev'_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply IH.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive le1 : nat -> nat -> Prop :=\n  | le1_n : forall n, le1 n n\n  | le1_S : forall n m, (le1 n m) -> (le1 n (S m)).",
    "Statement":"Inductive le1 : nat -> nat -> Prop :=\n  | le1_n : forall n, le1 n n\n  | le1_S : forall n m, (le1 n m) -> (le1 n (S m))",
    "Name":"le1",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"m <=1 n\" := (le1 m n) (at level 70).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive le2 (n:nat) : nat -> Prop :=\n  | le2_n : le2 n n\n  | le2_S m (H : le2 n m) : le2 n (S m).",
    "Statement":"Inductive le2 (n:nat) : nat -> Prop :=\n  | le2_n : le2 n n\n  | le2_S m (H : le2 n m) : le2 n (S m)",
    "Name":"le2",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"m <=2 n\" := (le2 m n) (at level 70).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck le1_ind :\n  forall P : nat -> nat -> Prop,\n    (forall n : nat, P n n) ->\n    (forall n m : nat, n <=1 m -> P n m -> P n (S m)) ->\n    forall n n0 : nat, n <=1 n0 -> P n n0.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "le1"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck le2_ind :\n  forall (n : nat) (P : nat -> Prop),\n    P n ->\n    (forall m : nat, n <=2 m -> P m -> P (S m)) ->\n    forall n0 : nat, n <=2 n0 -> P n0.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "le2"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "S",
      "O",
      "nat"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint nat_ind.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint build_proof\n         (P : nat -> Prop)\n         (evPO : P 0)\n         (evPS : forall n : nat, P n -> P (S n))\n         (n : nat) : P n :=\n  match n with\n  | 0 => evPO\n  | S k => evPS k (build_proof P evPO evPS k)\n  end.",
    "Statement":"Fixpoint build_proof\n         (P : nat -> Prop)\n         (evPO : P 0)\n         (evPS : forall n : nat, P n -> P (S n))\n         (n : nat) : P n :=\n  match n with\n  | 0 => evPO\n  | S k => evPS k (build_proof P evPO evPS k)\n  end",
    "Name":"build_proof",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition nat_ind_tidy := build_proof.",
    "Statement":"Definition nat_ind_tidy := build_proof",
    "Name":"nat_ind_tidy",
    "Dependencies":[
      "build_proof"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition nat_ind2 :\n  forall (P : nat -> Prop),\n  P 0 ->\n  P 1 ->\n  (forall n : nat, P n -> P (S(S n))) ->\n  forall n : nat , P n :=\n    fun P => fun P0 => fun P1 => fun PSS =>\n      fix f (n:nat) := match n with\n                         0 => P0\n                       | 1 => P1\n                       | S (S n') => PSS n' (f n')\n                       end.",
    "Statement":"Definition nat_ind2 :\n  forall (P : nat -> Prop),\n  P 0 ->\n  P 1 ->\n  (forall n : nat, P n -> P (S(S n))) ->\n  forall n : nat , P n :=\n    fun P => fun P0 => fun P1 => fun PSS =>\n      fix f (n:nat) := match n with\n                         0 => P0\n                       | 1 => P1\n                       | S (S n') => PSS n' (f n')\n                       end",
    "Name":"nat_ind2",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma even_ev : forall n, even n = true -> ev n.",
    "Statement":"Lemma even_ev : forall n, even n = true -> ev n",
    "Name":"even_ev",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev",
      "nat_ind2",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction n as [ | |n'] using nat_ind2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply ev_0.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    inversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n simpl in H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply ev_SS.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply IHn'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nNotation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : core_scope.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive t_tree (X : Type) : Type :=\n| t_leaf\n| t_branch : (t_tree X * X * t_tree X) -> t_tree X.",
    "Statement":"Inductive t_tree (X : Type) : Type :=\n| t_leaf\n| t_branch : (t_tree X * X * t_tree X) -> t_tree X",
    "Name":"t_tree",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nArguments t_leaf {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nArguments t_branch {X}.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck t_tree_ind.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end.",
    "Statement":"Fixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end",
    "Name":"reflect",
    "Dependencies":[
      "pair",
      "prod",
      "t_branch",
      "t_leaf",
      "t_tree"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nFixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end.",
    "Statement":"Fixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end",
    "Name":"reflect",
    "Dependencies":[
      "false",
      "true"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition better_t_tree_ind_type : Prop\n  .",
    "Statement":"Definition better_t_tree_ind_type : Prop",
    "Name":"better_t_tree_ind_type",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition better_t_tree_ind : better_t_tree_ind_type\n  .",
    "Statement":"Definition better_t_tree_ind : better_t_tree_ind_type",
    "Name":"better_t_tree_ind",
    "Dependencies":[
      "better_t_tree_ind_type"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\nAdmitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem reflect_involution : forall (X : Type) (t : t_tree X),\n    reflect (reflect t) = t.",
    "Statement":"Theorem reflect_involution : forall (X : Type) (t : t_tree X),\n    reflect (reflect t) = t",
    "Name":"reflect_involution",
    "Dependencies":[
      "reflect",
      "t_tree"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd IndPrinciples.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_IndPrinciples.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_IndPrinciplesTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.IndPrinciples.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.IndPrinciples.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_one_r'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions booltree_ind_type_correct.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Toy_correct.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_IndPrinciplesTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_IndPropTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ev_double.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Perm3_ex1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Perm3_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions le_inversion.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions SSSSev__even.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ev5_nonsense.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ev_sum.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ev_ev__ev.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Perm3_In.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions le_trans.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions O_le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions n_le_m__Sn_le_Sm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Sn_le_Sm__n_le_m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions le_plus_l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_le.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_le_cases.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_le_compat_l.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_le_compat_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions le_plus_trans.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions subseq_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions subseq_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions subseq_trans.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions EmptySet_is_empty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions MUnion'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions MStar'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions re_not_empty.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions re_not_empty_correct.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Pumping.weak_pumping.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions reflect_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions eqbP_practice.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions merge_filter.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_IndPropTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_InductionTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Induction.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions mul_0_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_n_Sm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions add_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions add_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions double_plus.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions eqb_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions add_shuffle3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions mul_comm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions bin_to_nat_pres_incr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions nat_bin_nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions double_incr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions double_bin_zero.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions double_incr_bin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions bin_nat_bin.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_InductionTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ListsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Lists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Lists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.snd_fst_is_swap.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_nonzeros.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_oddmembers.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_countoddmembers2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_countoddmembers3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_alternate1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_alternate2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_alternate4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_count2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_sum1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_add1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_add2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_member1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_member2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.app_nil_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.rev_app_distr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.rev_involutive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.app_assoc4.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.nonzeros_app.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.eqblist_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.count_member_nonzero.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.remove_does_not_increase_count.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.involution_injective.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.rev_injective.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_hd_error1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions NatList.test_hd_error2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions eqb_id_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions PartialMap.update_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions PartialMap.update_neq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ListsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_LogicTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Logic.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_is_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions and_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions mult_is_O.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions or_commut.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions contrapositive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions not_both_true_and_false.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions de_morgan_not_or.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions or_distributes_over_and.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions dist_not_exists.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions dist_exists_or.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions In_map_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions In_app_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions All_In.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions even_double_conv.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions andb_true_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions orb_true_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions eqb_neq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions eqb_list_true_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions forallb_true_iff.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions tr_rev_correct.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions excluded_middle_irrefutable.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions not_exists_dist.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_LogicTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_MapsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Maps.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions t_update_same.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions t_update_permute.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_MapsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_PolyTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Poly.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Poly.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions app_nil_r.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions app_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions app_length.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions rev_app_distr.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions rev_involutive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_filter_even_gt7_1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_filter_even_gt7_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions partition.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_partition1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_partition2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions map_rev.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions flat_map.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions test_flat_map1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.fold_length_correct.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.uncurry_curry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.curry_uncurry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.scc_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.scc_3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.plus_1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.plus_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.plus_3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.mult_1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.mult_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.mult_3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.exp_1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.exp_2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Exercises.Church.exp_3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_PolyTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Postscript.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export Postscript.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Postscript.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Postscript.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_PostscriptTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Postscript.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Postscript.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_PostscriptTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_Preface.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export Preface.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Preface.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_Preface.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_PrefaceTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Preface.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Preface.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_PrefaceTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_ProofObjectsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ProofObjects.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.ProofObjects.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ev_8.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions ev_8'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Props.conj_fact.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Props.or_commut'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Props.ex_ev_Sn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Props.ex_match.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Props.p_implies_true.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions Props.ex_falso_quodlibet'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions EqualityPlayground.eq_cons.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions EqualityPlayground.equality__leibniz_equality.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions EqualityPlayground.equality__leibniz_equality_term.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions and_assoc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions or_distributes_over_and.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions double_neg.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions contradiction_implies_anything.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions de_morgan_not_or.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions curry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions uncurry.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions pe_implies_or_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions pe_implies_true_eq.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions pe_implies_pi.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_ProofObjectsTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nModule Export LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nModule Export Rel.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport LF.IndProp.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition relation (X: Type) := X -> X -> Prop.",
    "Statement":"Definition relation (X: Type) := X -> X -> Prop",
    "Name":"relation",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nPrint le.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck le : nat -> nat -> Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck le : nat -> nat -> Prop.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck le : relation nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nCheck le : relation nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2.",
    "Statement":"Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2",
    "Name":"partial_function",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n).",
    "Statement":"Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n)",
    "Name":"next_nat",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nCheck next_nat : relation nat.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem next_nat_partial_function :\n  partial_function next_nat.",
    "Statement":"Theorem next_nat_partial_function :\n  partial_function next_nat",
    "Name":"next_nat_partial_function",
    "Dependencies":[
      "next_nat",
      "partial_function"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold partial_function.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros x y1 y2 H1 H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  inversion H1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninversion H2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  reflexivity.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_not_a_partial_function :\n  ~ (partial_function le).",
    "Statement":"Theorem le_not_a_partial_function :\n  ~ (partial_function le)",
    "Name":"le_not_a_partial_function",
    "Dependencies":[
      "partial_function"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold not.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold partial_function.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros Hc.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  assert (0 = 1) as Nonsense.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n{",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    apply Hc with (x := 0).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n}",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  discriminate Nonsense.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive total_relation : nat -> nat -> Prop :=\n\n.",
    "Statement":"Inductive total_relation : nat -> nat -> Prop :=",
    "Name":"total_relation",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem total_relation_not_partial_function :\n  ~ (partial_function total_relation).",
    "Statement":"Theorem total_relation_not_partial_function :\n  ~ (partial_function total_relation)",
    "Name":"total_relation_not_partial_function",
    "Dependencies":[
      "total_relation",
      "partial_function"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive empty_relation : nat -> nat -> Prop :=\n\n.",
    "Statement":"Inductive empty_relation : nat -> nat -> Prop :=",
    "Name":"empty_relation",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem empty_relation_partial_function :\n  partial_function empty_relation.",
    "Statement":"Theorem empty_relation_partial_function :\n  partial_function empty_relation",
    "Name":"empty_relation_partial_function",
    "Dependencies":[
      "empty_relation",
      "partial_function"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a.",
    "Statement":"Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a",
    "Name":"reflexive",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_reflexive :\n  reflexive le.",
    "Statement":"Theorem le_reflexive :\n  reflexive le",
    "Name":"le_reflexive",
    "Dependencies":[
      "reflexive"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold reflexive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nintros n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c).",
    "Statement":"Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c)",
    "Name":"transitive",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_trans :\n  transitive le.",
    "Statement":"Theorem le_trans :\n  transitive le",
    "Name":"le_trans",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_trans :\n  transitive le.",
    "Statement":"Theorem le_trans :\n  transitive le",
    "Name":"le_trans",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o Hnm Hmo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction Hmo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Hnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHHmo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lt_trans:\n  transitive lt.",
    "Statement":"Theorem lt_trans:\n  transitive lt",
    "Name":"lt_trans",
    "Dependencies":[
      "le_trans",
      "transitive"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold lt.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold transitive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o Hnm Hmo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_S in Hnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_S in Hnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_trans with (a := (S n)) (b := (S m)) (c := o).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_trans with (a := (S n)) (b := (S m)) (c := o).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Hnm.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply Hmo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lt_trans' :\n  transitive lt.",
    "Statement":"Theorem lt_trans' :\n  transitive lt",
    "Name":"lt_trans'",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n  unfold lt.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold transitive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o Hnm Hmo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction Hmo as [| m' Hm'o].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n     Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem lt_trans'' :\n  transitive lt.",
    "Statement":"Theorem lt_trans'' :\n  transitive lt",
    "Name":"lt_trans''",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold lt.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nunfold transitive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m o Hnm Hmo.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  induction o as [| o'].",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_Sn_le : forall n m, S n <= m -> n <= m.",
    "Statement":"Theorem le_Sn_le : forall n m, S n <= m -> n <= m",
    "Name":"le_Sn_le",
    "Dependencies":[
      "le_trans"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_trans with (S n).",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_trans with (S n).",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n apply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_S_n : forall n m,\n  (S n <= S m) -> (n <= m).",
    "Statement":"Theorem le_S_n : forall n m,\n  (S n <= S m) -> (n <= m)",
    "Name":"le_S_n",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_Sn_n : forall n,\n  ~ (S n <= n).",
    "Statement":"Theorem le_Sn_n : forall n,\n  ~ (S n <= n)",
    "Name":"le_Sn_n",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a).",
    "Statement":"Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a)",
    "Name":"symmetric",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_not_symmetric :\n  ~ (symmetric le).",
    "Statement":"Theorem le_not_symmetric :\n  ~ (symmetric le)",
    "Name":"le_not_symmetric",
    "Dependencies":[
      "symmetric"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b.",
    "Statement":"Definition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b",
    "Name":"antisymmetric",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_antisymmetric :\n  antisymmetric le.",
    "Statement":"Theorem le_antisymmetric :\n  antisymmetric le",
    "Name":"le_antisymmetric",
    "Dependencies":[
      "antisymmetric"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_step : forall n m p,\n  n < m ->\n  m <= S p ->\n  n <= p.",
    "Statement":"Theorem le_step : forall n m p,\n  n < m ->\n  m <= S p ->\n  n <= p",
    "Name":"le_step",
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition equivalence {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (symmetric R) \/\\ (transitive R).",
    "Statement":"Definition equivalence {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (symmetric R) \/\\ (transitive R)",
    "Name":"equivalence",
    "Dependencies":[
      "symmetric",
      "transitive",
      "reflexive",
      "relation"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition order {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (antisymmetric R) \/\\ (transitive R).",
    "Statement":"Definition order {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (antisymmetric R) \/\\ (transitive R)",
    "Name":"order",
    "Dependencies":[
      "antisymmetric",
      "transitive",
      "reflexive",
      "relation"
    ]
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nDefinition preorder {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (transitive R).",
    "Statement":"Definition preorder {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (transitive R)",
    "Name":"preorder",
    "Dependencies":[
      "transitive",
      "reflexive",
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem le_order :\n  order le.",
    "Statement":"Theorem le_order :\n  order le",
    "Name":"le_order",
    "Dependencies":[
      "order",
      "le_antisymmetric",
      "antisymmetric",
      "le_trans",
      "transitive",
      "le_reflexive",
      "reflexive"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  unfold order.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_reflexive.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_antisymmetric.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_trans.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z.",
    "Statement":"Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z",
    "Name":"clos_refl_trans",
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z.",
    "Statement":"Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z",
    "Name":"clos_refl_trans",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem next_nat_closure_is_le : forall n m,\n  (n <= m) <-> ((clos_refl_trans next_nat) n m).",
    "Statement":"Theorem next_nat_closure_is_le : forall n m,\n  (n <= m) <-> ((clos_refl_trans next_nat) n m)",
    "Name":"next_nat_closure_is_le",
    "Dependencies":[
      "clos_refl_trans_ind",
      "rt_trans",
      "rt_refl",
      "rt_step",
      "clos_refl_trans",
      "le_trans",
      "nn",
      "next_nat"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros n m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nsplit.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intro H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply rt_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply rt_trans with m.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply rt_trans with m.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\napply IHle.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply rt_step.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      apply nn.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  -",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n    intro H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\ninduction H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  inversion H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_S.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply le_n.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n    +",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply le_trans with y.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n      apply le_trans with y.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\n      apply IHclos_refl_trans1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n      apply IHclos_refl_trans2.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nQed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Definitionish",
    "Chunk":"\n\nInductive clos_refl_trans_1n {A : Type}\n                             (R : relation A) (x : A)\n                             : A -> Prop :=\n  | rt1n_refl : clos_refl_trans_1n R x x\n  | rt1n_trans (y z : A)\n      (Hxy : R x y) (Hrest : clos_refl_trans_1n R y z) :\n      clos_refl_trans_1n R x z.",
    "Statement":"Inductive clos_refl_trans_1n {A : Type}\n                             (R : relation A) (x : A)\n                             : A -> Prop :=\n  | rt1n_refl : clos_refl_trans_1n R x x\n  | rt1n_trans (y z : A)\n      (Hxy : R x y) (Hrest : clos_refl_trans_1n R y z) :\n      clos_refl_trans_1n R x z",
    "Name":"clos_refl_trans_1n",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma rsc_R : forall (X:Type) (R:relation X) (x y : X),\n  R x y -> clos_refl_trans_1n R x y.",
    "Statement":"Lemma rsc_R : forall (X:Type) (R:relation X) (x y : X),\n  R x y -> clos_refl_trans_1n R x y",
    "Name":"rsc_R",
    "Dependencies":[
      "rt1n_trans",
      "rt1n_refl",
      "clos_refl_trans_1n",
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  intros X R x y H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  apply rt1n_trans with y.",
    "Statement":null,
    "Name":null,
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Other",
    "Chunk":"\napply H.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\napply rt1n_refl.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n  Qed.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nLemma rsc_trans :\n  forall (X:Type) (R: relation X) (x y z : X),\n      clos_refl_trans_1n R x y  ->\n      clos_refl_trans_1n R y z ->\n      clos_refl_trans_1n R x z.",
    "Statement":"Lemma rsc_trans :\n  forall (X:Type) (R: relation X) (x y z : X),\n      clos_refl_trans_1n R x y  ->\n      clos_refl_trans_1n R y z ->\n      clos_refl_trans_1n R x z",
    "Name":"rsc_trans",
    "Dependencies":[
      "clos_refl_trans_1n",
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Theoremish",
    "Chunk":"\n\nTheorem rtc_rsc_coincide :\n  forall (X:Type) (R: relation X) (x y : X),\n    clos_refl_trans R x y <-> clos_refl_trans_1n R x y.",
    "Statement":"Theorem rtc_rsc_coincide :\n  forall (X:Type) (R: relation X) (x y : X),\n    clos_refl_trans R x y <-> clos_refl_trans_1n R x y",
    "Name":"rtc_rsc_coincide",
    "Dependencies":[
      "clos_refl_trans_1n",
      "clos_refl_trans",
      "relation"
    ]
  },
  {
    "Type":"Theoremish",
    "Chunk":"\nProof.",
    "Statement":"Proof",
    "Name":"",
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n   Admitted.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd Rel.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\n\nModule Export LF_DOT_RelTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Rel.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Rel.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nEnd LF_DOT_RelTest.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nSet Warnings \"-notation-overridden,-parsing\".",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nExport Stdlib.Strings.String.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nParameter MISSING: Type.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n\nLtac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport LF.Tactics.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nImport Check.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions rev_exercise1.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions injection_ex3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions discriminate_ex3.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions eqb_true.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions plus_n_n_injective.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions nth_error_after_last.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions combine_split.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions bool_fn_applied_thrice.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions eqb_sym.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions filter_exercise.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\nPrint Assumptions existsb_existsb'.",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  },
  {
    "Type":"Other",
    "Chunk":"\n",
    "Statement":null,
    "Name":null,
    "Dependencies":null
  }
]