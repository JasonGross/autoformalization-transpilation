[
  {
    "Type":"Misc",
    "Chunk":"(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-w\" \"-deprecated-native-compiler-option,-native-compiler-disabled\" \"-native-compiler\" \"ondemand\" \"-Q\" \".\" \"LF\" \"-top\" \"LF.Everything\") -*- *)",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"(* File reduced by coq-bug-minimizer from original input, then from 46 lines to 59 lines, then from 63 lines to 331 lines, then from 336 lines to 101 lines, then from 105 lines to 188 lines, then from 193 lines to 132 lines, then from 136 lines to 563 lines, then from 568 lines to 401 lines, then from 405 lines to 786 lines, then from 791 lines to 453 lines, then from 457 lines to 530 lines, then from 535 lines to 484 lines, then from 488 lines to 1010 lines, then from 1015 lines to 495 lines, then from 499 lines to 572 lines, then from 577 lines to 526 lines, then from 530 lines to 619 lines, then from 624 lines to 537 lines, then from 541 lines to 1052 lines, then from 1057 lines to 597 lines, then from 601 lines to 709 lines, then from 714 lines to 630 lines, then from 634 lines to 1065 lines, then from 1070 lines to 683 lines, then from 687 lines to 1215 lines, then from 1220 lines to 743 lines, then from 747 lines to 1016 lines, then from 1021 lines to 788 lines, then from 792 lines to 1318 lines, then from 1323 lines to 850 lines, then from 854 lines to 984 lines, then from 989 lines to 884 lines, then from 888 lines to 1870 lines, then from 1873 lines to 1212 lines, then from 1216 lines to 2177 lines, then from 2182 lines to 1609 lines, then from 1613 lines to 1976 lines, then from 1981 lines to 1658 lines, then from 1662 lines to 1745 lines, then from 1750 lines to 1689 lines, then from 1693 lines to 1804 lines, then from 1809 lines to 1721 lines, then from 1725 lines to 1814 lines, then from 1819 lines to 1752 lines, then from 1756 lines to 1903 lines, then from 1908 lines to 1795 lines, then from 1799 lines to 2279 lines, then from 2284 lines to 2210 lines, then from 2214 lines to 2624 lines, then from 2629 lines to 2554 lines, then from 2558 lines to 2631 lines, then from 2636 lines to 2585 lines, then from 2589 lines to 2628 lines, then from 2633 lines to 2596 lines, then from 2600 lines to 3129 lines, then from 3134 lines to 2659 lines, then from 2663 lines to 2745 lines, then from 2750 lines to 2690 lines, then from 2694 lines to 3452 lines, then from 3454 lines to 3213 lines, then from 3217 lines to 5320 lines, then from 5325 lines to 4248 lines, then from 4252 lines to 4642 lines, then from 4647 lines to 4473 lines, then from 4477 lines to 4756 lines, then from 4761 lines to 4516 lines, then from 4520 lines to 6372 lines, then from 6377 lines to 5956 lines, then from 5960 lines to 8709 lines, then from 8712 lines to 7346 lines, then from 7350 lines to 9159 lines, then from 9163 lines to 8301 lines, then from 8305 lines to 9559 lines, then from 9564 lines to 8866 lines, then from 8870 lines to 10105 lines, then from 10110 lines to 9480 lines, then from 9484 lines to 10700 lines, then from 10705 lines to 10072 lines, then from 10076 lines to 10883 lines, then from 10888 lines to 10328 lines, then from 10332 lines to 12374 lines, then from 12379 lines to 11166 lines, then from 11171 lines to 11168 lines *)",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"(* coqc version 9.1+alpha compiled with OCaml 4.14.2\n   coqtop version 9.1+alpha\n   Expected coqc runtime on this file: 2.113 sec *)",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Arith.Arith.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Lists.List.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Corelib.Init.Nat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Corelib.Setoids.Setoid.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Strings.Ascii.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.micromega.Lia.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.setoid_ring.Ring.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Bool.Bool.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Logic.FunctionalExtensionality.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Arith.EqNat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.extraction.Extraction.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.Arith.PeanoNat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Corelib.extraction.ExtrOcamlBasic.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Require Stdlib.extraction.ExtrOcamlString.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Basics.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Basics.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive day : Type :=\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  | sunday.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition next_working_day (d:day) : day :=\n  match d with\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => monday\n  | saturday  => monday\n  | sunday    => monday\n  end.",
    "Dependencies":[
      "friday",
      "thursday",
      "wednesday",
      "tuesday",
      "monday",
      "day"
    ]
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (next_working_day friday).",
    "Dependencies":null
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (next_working_day (next_working_day saturday)).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_next_working_day:\n  (next_working_day (next_working_day saturday)) = tuesday.",
    "Dependencies":[
      "next_working_day",
      "saturday",
      "tuesday",
      "day"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bool : Type :=\n  | true\n  | false.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition negb (b:bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end.",
    "Dependencies":[
      "false",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end.",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_orb1:  (orb true  false) = true.",
    "Dependencies":[
      "orb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_orb2:  (orb false false) = false.",
    "Dependencies":[
      "orb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_orb3:  (orb false true)  = true.",
    "Dependencies":[
      "orb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_orb4:  (orb true  true)  = true.",
    "Dependencies":[
      "orb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x && y\" := (andb x y).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x || y\" := (orb x y).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_orb5:  false || false || true = true.",
    "Dependencies":[
      "orb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition negb' (b:bool) : bool :=\n  if b then false\n  else true.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition andb' (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false.",
    "Dependencies":[
      "false",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition orb' (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2.",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bw : Type :=\n  | bw_black\n  | bw_white.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition invert (x: bw) : bw :=\n  if x then bw_white\n  else bw_black.",
    "Dependencies":[
      "bw_white",
      "bw_black",
      "bw"
    ]
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (invert bw_black).",
    "Dependencies":null
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (invert bw_white).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition nandb (b1:bool) (b2:bool) : bool\n  .",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nandb1:               (nandb true false) = true.",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nandb2:               (nandb false false) = true.",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nandb3:               (nandb false true) = true.",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nandb4:               (nandb true true) = false.",
    "Dependencies":[
      "nandb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool\n  .",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_andb31:                 (andb3 true true true) = true.",
    "Dependencies":[
      "andb3",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_andb32:                 (andb3 false true true) = false.",
    "Dependencies":[
      "andb3",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_andb33:                 (andb3 true false true) = false.",
    "Dependencies":[
      "andb3",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_andb34:                 (andb3 true true false) = false.",
    "Dependencies":[
      "andb3",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check true.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check true\n  : bool.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (negb true)\n  : bool.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check negb\n  : bool -> bool.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb).",
    "Dependencies":[
      "rgb"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition monochrome (c : color) : bool :=\n  match c with\n  | black => true\n  | white => true\n  | primary p => false\n  end.",
    "Dependencies":[
      "color",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition isred (c : color) : bool :=\n  match c with\n  | black => false\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end.",
    "Dependencies":[
      "color",
      "rgb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Playground.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : rgb := blue.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : rgb := blue.",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : rgb := blue.",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : rgb := blue.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Playground.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : bool := true.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : bool := true.",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : bool := true.",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo : bool := true.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check Playground.foo : rgb.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check foo : bool.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check foo : bool.",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check foo : bool.",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check foo : bool.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export TuplePlayground.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bit : Type :=\n  | B1\n  | B0.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit).",
    "Dependencies":[
      "bit"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check (bits B1 B0 B1 B0)\n  : nybble.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end.",
    "Dependencies":[
      "nybble",
      "bit",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (all_zero (bits B1 B0 B1 B0)).",
    "Dependencies":null
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (all_zero (bits B0 B0 B0 B0)).",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End TuplePlayground.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module NatPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive nat : Type :=\n  | O\n  | S (n : nat).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive otherNat : Type :=\n  | stop\n  | tick (foo : otherNat).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition pred (n : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => n'\n  end.",
    "Dependencies":[
      "O",
      "nat"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End NatPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (S (S (S (S O)))).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition minustwo (n : nat) : nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (minustwo 4).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check S        : nat -> nat.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check pred     : nat -> nat.",
    "Dependencies":[
      "O",
      "nat"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check minustwo : nat -> nat.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint even (n:nat) : bool :=\n  match n with\n  | O        => true\n  | S O      => false\n  | S (S n') => even n'\n  end.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition odd (n:nat) : bool :=\n  negb (even n).",
    "Dependencies":[
      "even",
      "negb",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_odd1:    odd 1 = true.",
    "Dependencies":[
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_odd2:    odd 4 = false.",
    "Dependencies":[
      "odd",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module NatPlayground2.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint plus (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (plus 3 2).",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint mult (n m : nat) : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end.",
    "Dependencies":[
      "plus"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_mult1: (mult 3 3) = 9.",
    "Dependencies":[
      "mult"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End NatPlayground2.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint factorial (n:nat) : nat\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_factorial1:          (factorial 3) = 6.",
    "Dependencies":[
      "factorial"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_factorial2:          (factorial 5) = (mult 10 12).",
    "Dependencies":[
      "factorial"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x - y\" := (minus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ((0 + 1) + 1) : nat.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint eqb (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => eqb n' m'\n            end\n  end.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint leb (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => leb n' m'\n      end\n  end.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_leb1:                leb 2 2 = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_leb2:                leb 2 4 = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_leb3:                leb 4 2 = false.",
    "Dependencies":[
      "leb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x =? y\" := (eqb x y) (at level 70) : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x <=? y\" := (leb x y) (at level 70) : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_leb3': (4 <=? 2) = false.",
    "Dependencies":[
      "leb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ltb (n m : nat) : bool\n  .",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x <? y\" := (ltb x y) (at level 70) : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_ltb1:             (ltb 2 2) = false.",
    "Dependencies":[
      "ltb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_ltb2:             (ltb 2 4) = true.",
    "Dependencies":[
      "ltb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_ltb3:             (ltb 4 2) = false.",
    "Dependencies":[
      "ltb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_O_n : forall n : nat, 0 + n = n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_O_n' : forall n : nat, 0 + n = n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_O_n'' : forall n : nat, 0 + n = n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_l : forall n:nat, 1 + n = S n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_0_l : forall n:nat, 0 * n = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_id_exercise : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check mult_n_O.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check mult_n_Sm.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_n_0_m_0 : forall p q : nat,\n  (p * 0) + (q * 0) = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros p q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- mult_n_O.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- mult_n_O.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_n_1 : forall p : nat,\n  p * 1 = p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n as [| n'] eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b eqn:Eb.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b eqn:Eb.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Dependencies":[
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b c d.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b eqn:Eb.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct d eqn:Ed.",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0' : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0' : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [|n].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative'' :\n  forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [] [].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem zero_nbeq_plus_1 : forall n : nat,\n  0 =? (n + 1) = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x + y\" := (plus x y)\n                       (at level 50, left associativity)\n                       : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x * y\" := (mult x y)\n                       (at level 40, left associativity)\n                       : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint plus' (n : nat) (m : nat) : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus' n' m)\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem identity_fn_applied_twice :\n  forall (f : bool -> bool),\n  (forall (x : bool), f x = x) ->\n  forall (b : bool), f (f b) = b.",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LateDays.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive letter : Type :=\n  | A | B | C | D | F.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive modifier : Type :=\n  | Plus | Natural | Minus.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive grade : Type :=\n  Grade (l:letter) (m:modifier).",
    "Dependencies":[
      "modifier",
      "letter"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive comparison : Type :=\n  | Eq\n  | Lt\n  | Gt.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition letter_comparison (l1 l2 : letter) : comparison :=\n  match l1, l2 with\n  | A, A => Eq\n  | A, _ => Gt\n  | B, A => Lt\n  | B, B => Eq\n  | B, _ => Gt\n  | C, (A | B) => Lt\n  | C, C => Eq\n  | C, _ => Gt\n  | D, (A | B | C) => Lt\n  | D, D => Eq\n  | D, _ => Gt\n  | F, (A | B | C | D) => Lt\n  | F, F => Eq\n  end.",
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Compute",
    "Chunk":"Compute letter_comparison B A.",
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Compute",
    "Chunk":"Compute letter_comparison D D.",
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Compute",
    "Chunk":"Compute letter_comparison B F.",
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem letter_comparison_Eq :\n  forall l, letter_comparison l l = Eq.",
    "Dependencies":[
      "letter_comparison",
      "Eq",
      "comparison",
      "letter"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition modifier_comparison (m1 m2 : modifier) : comparison :=\n  match m1, m2 with\n  | Plus, Plus => Eq\n  | Plus, _ => Gt\n  | Natural, Plus => Lt\n  | Natural, Natural => Eq\n  | Natural, _ => Gt\n  | Minus, (Plus | Natural) => Lt\n  | Minus, Minus => Eq\n  end.",
    "Dependencies":[
      "Gt",
      "Lt",
      "Eq",
      "comparison",
      "modifier"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition grade_comparison (g1 g2 : grade) : comparison\n  .",
    "Dependencies":[
      "comparison",
      "grade"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_grade_comparison1 :\n  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.",
    "Dependencies":[
      "grade_comparison",
      "Gt",
      "comparison",
      "Grade",
      "Minus",
      "Plus",
      "B",
      "A"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_grade_comparison2 :\n  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.",
    "Dependencies":[
      "grade_comparison",
      "Lt",
      "comparison",
      "Grade",
      "Minus",
      "Plus",
      "A"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_grade_comparison3 :\n  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.",
    "Dependencies":[
      "grade_comparison",
      "Eq",
      "comparison",
      "Grade",
      "Plus",
      "F"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_grade_comparison4 :\n  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.",
    "Dependencies":[
      "grade_comparison",
      "Gt",
      "comparison",
      "Grade",
      "Minus",
      "Plus",
      "C",
      "B"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition lower_letter (l : letter) : letter :=\n  match l with\n  | A => B\n  | B => C\n  | C => D\n  | D => F\n  | F => F\n  end.",
    "Dependencies":[
      "F",
      "D",
      "C",
      "B",
      "letter"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lower_letter_F_is_F:\n  lower_letter F = F.",
    "Dependencies":[
      "lower_letter",
      "F",
      "letter"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lower_letter_lowers:\n  forall (l : letter),\n    letter_comparison F l = Lt ->\n    letter_comparison (lower_letter l) l = Lt.",
    "Dependencies":[
      "lower_letter",
      "letter_comparison",
      "Lt",
      "comparison",
      "F",
      "letter"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition lower_grade (g : grade) : grade\n  .",
    "Dependencies":[
      "grade"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lower_grade_A_Plus :\n  lower_grade (Grade A Plus) = (Grade A Natural).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Natural",
      "Plus",
      "A"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lower_grade_A_Natural :\n  lower_grade (Grade A Natural) = (Grade A Minus).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Natural",
      "A"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lower_grade_A_Minus :\n  lower_grade (Grade A Minus) = (Grade B Plus).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Plus",
      "B",
      "A"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lower_grade_B_Plus :\n  lower_grade (Grade B Plus) = (Grade B Natural).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Natural",
      "Plus",
      "B"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lower_grade_F_Natural :\n  lower_grade (Grade F Natural) = (Grade F Minus).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Natural",
      "F"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lower_grade_twice :\n  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "Natural",
      "C",
      "B"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lower_grade_thrice :\n  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "C",
      "B"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lower_grade_F_Minus : lower_grade (Grade F Minus) = (Grade F Minus).",
    "Dependencies":[
      "lower_grade",
      "Grade",
      "grade",
      "Minus",
      "F"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lower_grade_lowers :\n  forall (g : grade),\n    grade_comparison (Grade F Minus) g = Lt ->\n    grade_comparison (lower_grade g) g = Lt.",
    "Dependencies":[
      "lower_grade",
      "grade_comparison",
      "Lt",
      "comparison",
      "Grade",
      "grade",
      "Minus",
      "F"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition apply_late_policy (late_days : nat) (g : grade) : grade :=\n  if late_days <? 9 then g\n  else if late_days <? 17 then lower_grade g\n  else if late_days <? 21 then lower_grade (lower_grade g)\n  else lower_grade (lower_grade (lower_grade g)).",
    "Dependencies":[
      "lower_grade",
      "grade",
      "ltb",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem apply_late_policy_unfold :\n  forall (late_days : nat) (g : grade),\n    (apply_late_policy late_days g)\n    =\n    (if late_days <? 9 then g  else\n       if late_days <? 17 then lower_grade g\n       else if late_days <? 21 then lower_grade (lower_grade g)\n            else lower_grade (lower_grade (lower_grade g))).",
    "Dependencies":[
      "apply_late_policy",
      "lower_grade",
      "grade",
      "ltb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem no_penalty_for_mostly_on_time :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = true) ->\n    apply_late_policy late_days g = g.",
    "Dependencies":[
      "apply_late_policy",
      "grade",
      "ltb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem grade_lowered_once :\n  forall (late_days : nat) (g : grade),\n    (late_days <? 9 = false) ->\n    (late_days <? 17 = true) ->\n    (apply_late_policy late_days g) = (lower_grade g).",
    "Dependencies":[
      "apply_late_policy",
      "lower_grade",
      "grade",
      "ltb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LateDays.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin).",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint incr (m:bin) : bin\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint incr (m:bin) : bin\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint bin_to_nat (m:bin) : nat\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint bin_to_nat (m:bin) : nat\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z).",
    "Dependencies":[
      "incr",
      "B1",
      "B0",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z).",
    "Dependencies":[
      "incr",
      "B1",
      "B0",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z)).",
    "Dependencies":[
      "incr",
      "B1",
      "B0",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2.",
    "Dependencies":[
      "bin_to_nat",
      "B1",
      "B0",
      "Z"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_bin_incr5 :\n        bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z).",
    "Dependencies":[
      "bin_to_nat",
      "incr",
      "B1",
      "Z"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_bin_incr6 :\n        bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z).",
    "Dependencies":[
      "bin_to_nat",
      "incr",
      "B1",
      "Z"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Basics.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Basics.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Induction.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Induction.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.Basics.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_0_r : forall n:nat, n + 0 = n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n' IHn'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem minus_n_n : forall n,\n  minus n n = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n' IHn'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mul_0_r : forall n:nat,\n  n * 0 = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_n_Sm : forall n m : nat,\n  S (n + m) = n + (S m).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_n_Sm : forall n m : nat,\n  S (n + m) = n + (S m).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_comm : forall n m : nat,\n  n + m = m + n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma double_plus : forall n, double n = n + n .",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_refl : forall n : nat,\n  (n =? n) = true.",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem even_S : forall n : nat,\n  even (S n) = negb (even n).",
    "Dependencies":[
      "even",
      "negb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_0_plus' : forall n m : nat,\n  (n + 0 + 0) * m = n * m.",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (H: n + 0 + 0 = n).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_rearrange : forall n m p q : nat,\n  (n + m) + (p + q) = (m + n) + (p + q).",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (H: n + m = m + n).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n' IHn'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc'' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc'' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n' IHn'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_add_comm_informal : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_shuffle3 : forall n m p : nat,\n  n + (m + p) = m + (n + p).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mul_comm : forall m n : nat,\n  m * n = n * m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check leb.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_leb_compat_l : forall n m p : nat,\n  n <=? m = true -> (p + n) <=? (p + m) = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem leb_refl : forall n:nat,\n  (n <=? n) = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem zero_neqb_S : forall n:nat,\n  0 =? (S n) = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_false_r : forall b : bool,\n  andb b false = false.",
    "Dependencies":[
      "andb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem S_neqb_0 : forall n:nat,\n  (S n) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_1_l : forall n:nat, 1 * n = n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem all3_spec : forall b c : bool,\n  orb\n    (andb b c)\n    (orb (negb b)\n         (negb c))\n  = true.",
    "Dependencies":[
      "orb",
      "andb",
      "negb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_plus_distr_r : forall n m p : nat,\n  (n + m) * p = (n * p) + (m * p).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_assoc : forall n m p : nat,\n  n * (m * p) = (n * m) * p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_shuffle3' : forall n m p : nat,\n  n + (m + p) = m + (n + p).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bin : Type :=\n  | Z\n  | B0 (n : bin)\n  | B1 (n : bin)\n.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint incr (m:bin) : bin\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint incr (m:bin) : bin\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint bin_to_nat (m:bin) : nat\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint bin_to_nat (m:bin) : nat\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem bin_to_nat_pres_incr : forall b : bin,\n  bin_to_nat (incr b) = 1 + bin_to_nat b.",
    "Dependencies":[
      "bin_to_nat",
      "incr",
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nat_to_bin (n:nat) : bin\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.",
    "Dependencies":[
      "nat_to_bin",
      "bin_to_nat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma double_incr : forall n : nat, double (S n) = S (S (double n)).",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition double_bin (b:bin) : bin\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example double_bin_zero : double_bin Z = Z.",
    "Dependencies":[
      "double_bin",
      "Z",
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma double_incr_bin : forall b,\n    double_bin (incr b) = incr (incr (double_bin b)).",
    "Dependencies":[
      "double_bin",
      "incr",
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint normalize (b:bin) : bin\n  .",
    "Dependencies":[
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b.",
    "Dependencies":[
      "normalize",
      "nat_to_bin",
      "bin_to_nat",
      "bin"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Induction.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Induction.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Lists.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Lists.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.Induction.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export NatList.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive natprod : Type :=\n  | pair (n1 n2 : nat).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (pair 3 5) : natprod.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end.",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fst (p : natprod) : nat :=\n  match p with\n  | pair x y => x\n  end.",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end.",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition snd (p : natprod) : nat :=\n  match p with\n  | pair x y => y\n  end.",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (fst (pair 3 5)).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"( x , y )\" := (pair x y).",
    "Dependencies":null
  },
  {
    "Type":"Compute",
    "Chunk":"Compute (fst (3,5)).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fst' (p : natprod) : nat :=\n  match p with\n  | (x,y) => x\n  end.",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition snd' (p : natprod) : nat :=\n  match p with\n  | (x,y) => y\n  end.",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition swap_pair (p : natprod) : natprod :=\n  match p with\n  | (x,y) => (y,x)\n  end.",
    "Dependencies":[
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem surjective_pairing' : forall (n m : nat),\n  (n,m) = (fst (n,m), snd (n,m)).",
    "Dependencies":[
      "snd",
      "fst",
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem surjective_pairing : forall (p : natprod),\n  p = (fst p, snd p).",
    "Dependencies":[
      "snd",
      "fst",
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct p as [n m].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem snd_fst_is_swap : forall (p : natprod),\n  (snd p, fst p) = swap_pair p.",
    "Dependencies":[
      "swap_pair",
      "snd",
      "fst",
      "pair",
      "natprod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem fst_swap_is_snd : forall (p : natprod),\n  fst (swap_pair p) = snd p.",
    "Dependencies":[
      "swap_pair",
      "snd",
      "fst",
      "natprod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive natlist : Type :=\n  | nil\n  | cons (n : nat) (l : natlist).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mylist := cons 1 (cons 2 (cons 3 nil)).",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x :: l\" := (cons x l)\n                     (at level 60, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"[ ]\" := nil.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mylist1 := 1 :: (2 :: (3 :: nil)).",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mylist2 := 1 :: 2 :: 3 :: nil.",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mylist3 := [1;2;3].",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint repeat (n count : nat) : natlist :=\n  match count with\n  | O => nil\n  | S count' => n :: (repeat n count')\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end.",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint length (l:natlist) : nat :=\n  match l with\n  | nil => O\n  | h :: t => S (length t)\n  end.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end.",
    "Dependencies":[
      "cons",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint app (l1 l2 : natlist) : natlist :=\n  match l1 with\n  | nil    => l2\n  | h :: t => h :: (app t l2)\n  end.",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x ++ y\" := (app x y)\n                     (right associativity, at level 60).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_app2:             nil ++ [4;5] = [4;5].",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_app3:             [1;2;3] ++ nil = [1;2;3].",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition hd (default : nat) (l : natlist) : nat :=\n  match l with\n  | nil => default\n  | h :: t => h\n  end.",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition tl (l : natlist) : natlist :=\n  match l with\n  | nil => nil\n  | h :: t => t\n  end.",
    "Dependencies":[
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd1:             hd 0 [1;2;3] = 1.",
    "Dependencies":[
      "hd",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd2:             hd 0 [] = 0.",
    "Dependencies":[
      "hd",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_tl:              tl [1;2;3] = [2;3].",
    "Dependencies":[
      "tl",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nonzeros (l:natlist) : natlist\n  .",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nonzeros (l:natlist) : natlist\n  .",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nonzeros:\n  nonzeros [0;1;0;2;3;0;0] = [1;2;3].",
    "Dependencies":[
      "nonzeros",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint oddmembers (l:natlist) : natlist\n  .",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_oddmembers:\n  oddmembers [0;1;0;2;3;0;0] = [1;3].",
    "Dependencies":[
      "oddmembers",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition countoddmembers (l:natlist) : nat\n  .",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_countoddmembers1:\n  countoddmembers [1;0;3;1;4;5] = 4.",
    "Dependencies":[
      "countoddmembers",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_countoddmembers2:\n  countoddmembers [0;2;4] = 0.",
    "Dependencies":[
      "countoddmembers",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_countoddmembers3:\n  countoddmembers nil = 0.",
    "Dependencies":[
      "countoddmembers",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint alternate (l1 l2 : natlist) : natlist\n  .",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_alternate1:\n  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_alternate2:\n  alternate [1] [4;5;6] = [1;4;5;6].",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_alternate3:\n  alternate [1;2;3] [4] = [1;4;2;3].",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_alternate4:\n  alternate [] [20;30] = [20;30].",
    "Dependencies":[
      "alternate",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition bag := natlist.",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint count (v : nat) (s : bag) : nat\n  .",
    "Dependencies":[
      "list",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint count (v : nat) (s : bag) : nat\n  .",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_count1:              count 1 [1;2;3;1;4;1] = 3.",
    "Dependencies":[
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_count2:              count 6 [1;2;3;1;4;1] = 0.",
    "Dependencies":[
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition sum : bag -> bag -> bag\n  .",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.",
    "Dependencies":[
      "sum",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition add (v : nat) (s : bag) : bag\n  .",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_add1:                count 1 (add 1 [1;4;1]) = 3.",
    "Dependencies":[
      "add",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_add2:                count 5 (add 1 [1;4;1]) = 0.",
    "Dependencies":[
      "add",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint member (v : nat) (s : bag) : bool\n  .",
    "Dependencies":[
      "bag",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_member1:             member 1 [1;4;1] = true.",
    "Dependencies":[
      "member",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_member2:             member 2 [1;4;1] = false.",
    "Dependencies":[
      "member",
      "cons",
      "nil",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint remove_one (v : nat) (s : bag) : bag\n  .",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_one1:\n  count 5 (remove_one 5 [2;1;5;4;1]) = 0.",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_one2:\n  count 5 (remove_one 5 [2;1;4;1]) = 0.",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_one3:\n  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_one4:\n  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.",
    "Dependencies":[
      "remove_one",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint remove_all (v:nat) (s:bag) : bag\n  .",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.",
    "Dependencies":[
      "remove_all",
      "count",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint included (s1 : bag) (s2 : bag) : bool\n  .",
    "Dependencies":[
      "bag",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_included1:              included [1;2] [2;1;4;1] = true.",
    "Dependencies":[
      "included",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_included2:              included [1;2;2] [2;1;4;1] = false.",
    "Dependencies":[
      "included",
      "cons",
      "nil",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_add_inc_count : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nil_app : forall l : natlist,\n  [] ++ l = l.",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem tl_length_pred : forall l:natlist,\n  pred (length l) = length (tl l).",
    "Dependencies":[
      "tl",
      "length",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct l as [| n l'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).",
    "Dependencies":[
      "app",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_assoc : forall l1 l2 l3 : natlist,\n  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).",
    "Dependencies":[
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l1 l2 l3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l1 as [| n l1' IHl1'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHl1'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem repeat_plus: forall c1 c2 n: nat,\n    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2).",
    "Dependencies":[
      "app",
      "repeat",
      "cons",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c1 c2 n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction c1 as [| c1' IHc1'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- IHc1'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint rev (l:natlist) : natlist :=\n  match l with\n  | nil    => nil\n  | h :: t => rev t ++ [h]\n  end.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev1:            rev [1;2;3] = [3;2;1].",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev1:            rev [1;2;3] = [3;2;1].",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev2:            rev nil = nil.",
    "Dependencies":[
      "rev",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev2:            rev nil = nil.",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length_S: forall l n,\n  length (l ++ [n]) = S (length l).",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [| m l' IHl'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHl'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2).",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2).",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length : forall l1 l2 : natlist,\n  length (l1 ++ l2) = (length l1) + (length l2).",
    "Dependencies":[
      "length",
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l1 l2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l1 as [| n l1' IHl1'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHl1'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_length : forall l : natlist,\n  length (rev l) = length l.",
    "Dependencies":[
      "app_length",
      "rev",
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist",
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [| n l' IHl'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> app_length.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHl'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Search rev.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Search (_ + _ = _ + _).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Search (_ + _ = _ + _) inside Induction.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Search (?x + ?y = ?y + ?x).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall l : natlist,\n  l ++ [] = l.",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall l : natlist,\n  l ++ [] = l.",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall l : natlist,\n  l ++ [] = l.",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_app_distr: forall l1 l2 : natlist,\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Dependencies":[
      "rev",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_app_distr: forall l1 l2 : natlist,\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Dependencies":[
      "rev",
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_involutive : forall l : natlist,\n  rev (rev l) = l.",
    "Dependencies":[
      "rev",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_involutive : forall l : natlist,\n  rev (rev l) = l.",
    "Dependencies":[
      "rev",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,\n  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.",
    "Dependencies":[
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).",
    "Dependencies":[
      "app",
      "list",
      "nonzeros"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma nonzeros_app : forall l1 l2 : natlist,\n  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).",
    "Dependencies":[
      "nonzeros",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint eqblist (l1 l2 : natlist) : bool\n  .",
    "Dependencies":[
      "natlist",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_eqblist1 :\n  (eqblist nil nil = true).",
    "Dependencies":[
      "eqblist",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_eqblist2 :\n  eqblist [1;2;3] [1;2;3] = true.",
    "Dependencies":[
      "eqblist",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_eqblist3 :\n  eqblist [1;2;3] [1;2;4] = false.",
    "Dependencies":[
      "eqblist",
      "cons",
      "nil",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqblist_refl : forall l:natlist,\n  true = eqblist l l.",
    "Dependencies":[
      "eqblist",
      "natlist",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem count_member_nonzero : forall (s : bag),\n  1 <=? (count 1 (1 :: s)) = true.",
    "Dependencies":[
      "count",
      "bag",
      "cons",
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem leb_n_Sn : forall n,\n  n <=? (S n) = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n' IHn'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem remove_does_not_increase_count: forall (s : bag),\n  (count 0 (remove_one 0 s)) <=? (count 0 s) = true.",
    "Dependencies":[
      "remove_one",
      "count",
      "bag",
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem involution_injective : forall (f : nat -> nat),\n    (forall n : nat, n = f (f n)) -> (forall n1 n2 : nat, f n1 = f n2 -> n1 = n2).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_injective : forall (l1 l2 : natlist),\n  rev l1 = rev l2 -> l1 = l2.",
    "Dependencies":[
      "rev",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nth_bad (l:natlist) (n:nat) : nat :=\n  match l with\n  | nil => 42\n  | a :: l' => match n with\n               | 0 => a\n               | S n' => nth_bad l' n'\n               end\n  end.",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive natoption : Type :=\n  | Some (n : nat)\n  | None.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Dependencies":[
      "None",
      "Some",
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nth_error (l:natlist) (n:nat) : natoption :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Dependencies":[
      "None",
      "Some",
      "option",
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.",
    "Dependencies":[
      "nth_error",
      "None",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.",
    "Dependencies":[
      "nth_error",
      "None",
      "option",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition option_elim (d : nat) (o : natoption) : nat :=\n  match o with\n  | Some n' => n'\n  | None => d\n  end.",
    "Dependencies":[
      "natoption"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition hd_error (l : natlist) : natoption\n  .",
    "Dependencies":[
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition hd_error (l : natlist) : natoption\n  .",
    "Dependencies":[
      "option",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error1 : hd_error [] = None.",
    "Dependencies":[
      "hd_error",
      "None",
      "natoption",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error1 : hd_error [] = None.",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error2 : hd_error [1] = Some 1.",
    "Dependencies":[
      "hd_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error2 : hd_error [1] = Some 1.",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error3 : hd_error [5;6] = Some 5.",
    "Dependencies":[
      "hd_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem option_elim_hd : forall (l:natlist) (default:nat),\n  hd default l = option_elim default (hd_error l).",
    "Dependencies":[
      "hd_error",
      "option_elim",
      "hd",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End NatList.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive id : Type :=\n  | Id (n : nat).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition eqb_id (x1 x2 : id) :=\n  match x1, x2 with\n  | Id n1, Id n2 => n1 =? n2\n  end.",
    "Dependencies":[
      "id",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_id_refl : forall x, eqb_id x x = true.",
    "Dependencies":[
      "eqb_id",
      "id",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export PartialMap.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export NatList.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map).",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive partial_map : Type :=\n  | empty\n  | record (i : id) (v : nat) (m : partial_map).",
    "Dependencies":[
      "id"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d.",
    "Dependencies":[
      "partial_map",
      "t_update"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition update (d : partial_map)\n                  (x : id) (value : nat)\n                  : partial_map :=\n  record x value d.",
    "Dependencies":[
      "record",
      "partial_map",
      "id"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint find (x : id) (d : partial_map) : natoption :=\n  match d with\n  | empty         => None\n  | record y v d' => if eqb_id x y\n                     then Some v\n                     else find x d'\n  end.",
    "Dependencies":[
      "partial_map",
      "None",
      "Some",
      "natoption",
      "eqb_id",
      "id",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_eq :\n  forall (d : partial_map) (x : id) (v: nat),\n    find x (update d x v) = Some v.",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_eq",
      "t_update"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_eq :\n  forall (d : partial_map) (x : id) (v: nat),\n    find x (update d x v) = Some v.",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "Some",
      "natoption",
      "id"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_neq :\n  forall (d : partial_map) (x y : id) (o: nat),\n    eqb_id x y = false -> find x (update d y o) = find x d.",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_neq",
      "t_update"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_neq :\n  forall (d : partial_map) (x y : id) (o: nat),\n    eqb_id x y = false -> find x (update d y o) = find x d.",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "natoption",
      "eqb_id",
      "id",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End PartialMap.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Lists.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Lists.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Poly.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Poly.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.Lists.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive boollist : Type :=\n  | bool_nil\n  | bool_cons (b : bool) (l : boollist).",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive list (X:Type) : Type :=\n  | nil\n  | cons (x : X) (l : list X).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check list : Type -> Type.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (nil nat) : list nat.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (cons nat 3 (nil nat)) : list nat.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check nil : forall X : Type, list X.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check nil : forall X : Type, list X.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check cons : forall X : Type, X -> list X -> list X.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check cons : forall X : Type, X -> list X -> list X.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (cons nat 2 (cons nat 1 (nil nat)))\n      : list nat.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n  match count with\n  | 0 => nil X\n  | S count' => cons X x (repeat X x count')\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_repeat1 :\n  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).",
    "Dependencies":[
      "repeat",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_repeat2 :\n  repeat bool false 1 = cons bool false (nil bool).",
    "Dependencies":[
      "repeat",
      "cons",
      "nil",
      "list",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module MumbleGrumble.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive mumble : Type :=\n  | a\n  | b (x : mumble) (y : nat)\n  | c.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive grumble (X:Type) : Type :=\n  | d (m : mumble)\n  | e (x : X).",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End MumbleGrumble.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint repeat' X x count : list X :=\n  match count with\n  | 0        => nil X\n  | S count' => cons X x (repeat' X x count')\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check repeat'\n  : forall X : Type, X -> nat -> list X.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check repeat\n  : forall X : Type, X -> nat -> list X.",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check repeat\n  : forall X : Type, X -> nat -> list X.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint repeat'' X x count : list X :=\n  match count with\n  | 0        => nil _\n  | S count' => cons _ x (repeat'' _ x count')\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition list123 :=\n  cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition list123' :=\n  cons _ 1 (cons _ 2 (cons _ 3 (nil _))).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments nil {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments nil {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments cons {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments cons {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments repeat {X}.",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments repeat {X}.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition list123'' := cons 1 (cons 2 (cons 3 nil)).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=\n  match count with\n  | 0        => nil\n  | S count' => cons x (repeat''' x count')\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive list' {X:Type} : Type :=\n  | nil'\n  | cons' (x : X) (l : list').",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end.",
    "Dependencies":[
      "cons",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint app {X : Type} (l1 l2 : list X) : list X :=\n  match l1 with\n  | nil      => l2\n  | cons h t => cons h (app t l2)\n  end.",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint rev {X:Type} (l:list X) : list X :=\n  match l with\n  | nil      => nil\n  | cons h t => app (rev t) (cons h nil)\n  end.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end.",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint length {X : Type} (l : list X) : nat :=\n  match l with\n  | nil => 0\n  | cons _ l' => S (length l')\n  end.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev1 :\n  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev2:\n  rev (cons true nil) = cons true nil.",
    "Dependencies":[
      "rev",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_rev2:\n  rev (cons true nil) = cons true nil.",
    "Dependencies":[
      "rev",
      "cons",
      "nil",
      "list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.",
    "Dependencies":[
      "length",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Definition mynil := nil.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mynil : list nat := nil.",
    "Dependencies":[
      "nil",
      "list"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check @nil : forall X : Type, list X.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mynil' := @nil nat.",
    "Dependencies":[
      "nil",
      "list"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"[ ]\" := nil.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition list123''' := [1; 2; 3].",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l.",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l.",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall (X:Type), forall l:list X,\n  l ++ [] = l.",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n.",
    "Dependencies":[
      "app",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n.",
    "Dependencies":[
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma app_length : forall (X:Type) (l1 l2 : list X),\n  length (l1 ++ l2) = length l1 + length l2.",
    "Dependencies":[
      "length",
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_app_distr: forall X (l1 l2 : list X),\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Dependencies":[
      "rev",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_app_distr: forall X (l1 l2 : list X),\n  rev (l1 ++ l2) = rev l2 ++ rev l1.",
    "Dependencies":[
      "rev",
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_involutive : forall X : Type, forall l : list X,\n  rev (rev l) = l.",
    "Dependencies":[
      "rev",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_involutive : forall X : Type, forall l : list X,\n  rev (rev l) = l.",
    "Dependencies":[
      "rev",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive prod (X Y : Type) : Type :=\n| pair (x : X) (y : Y).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments pair {X} {Y}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments pair {X} {Y}.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"( x , y )\" := (pair x y).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"X * Y\" := (prod X Y) : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end.",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fst {X Y : Type} (p : X * Y) : X :=\n  match p with\n  | (x, y) => x\n  end.",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end.",
    "Dependencies":[
      "natprod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition snd {X Y : Type} (p : X * Y) : Y :=\n  match p with\n  | (x, y) => y\n  end.",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n           : list (X*Y) :=\n  match lx, ly with\n  | [], _ => []\n  | _, [] => []\n  | x :: tx, y :: ty => (x, y) :: (combine tx ty)\n  end.",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  .",
    "Dependencies":[
      "prod",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)\n  .",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_split:\n  split [(1,false);(2,false)] = ([1;2],[false;false]).",
    "Dependencies":[
      "split",
      "pair",
      "prod",
      "cons",
      "nil",
      "list",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive option (X:Type) : Type :=\n  | Some (x : X)\n  | None.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments Some {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments Some {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments None {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments None {X}.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Dependencies":[
      "None",
      "Some",
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nth_error {X : Type} (l : list X) (n : nat)\n                   : option X :=\n  match l with\n  | nil => None\n  | a :: l' => match n with\n               | O => Some a\n               | S n' => nth_error l' n'\n               end\n  end.",
    "Dependencies":[
      "None",
      "Some",
      "option",
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].",
    "Dependencies":[
      "nth_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].",
    "Dependencies":[
      "nth_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error3 : nth_error [true] 2 = None.",
    "Dependencies":[
      "nth_error",
      "None",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nth_error3 : nth_error [true] 2 = None.",
    "Dependencies":[
      "nth_error",
      "None",
      "option",
      "cons",
      "nil",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition hd_error {X : Type} (l : list X) : option X\n  .",
    "Dependencies":[
      "natoption",
      "natlist"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition hd_error {X : Type} (l : list X) : option X\n  .",
    "Dependencies":[
      "option",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @hd_error : forall X : Type, list X -> option X.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error1 : hd_error [1;2] = Some 1.",
    "Dependencies":[
      "hd_error",
      "None",
      "natoption",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error1 : hd_error [1;2] = Some 1.",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].",
    "Dependencies":[
      "hd_error",
      "Some",
      "natoption",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].",
    "Dependencies":[
      "hd_error",
      "Some",
      "option",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition doit3times {X : Type} (f : X->X) (n : X) : X :=\n  f (f (f n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @doit3times : forall X : Type, (X -> X) -> X -> X.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_doit3times: doit3times minustwo 9 = 3.",
    "Dependencies":[
      "doit3times",
      "minustwo"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_doit3times': doit3times negb true = false.",
    "Dependencies":[
      "doit3times",
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=\n  match l with\n  | [] => []\n  | h :: t =>\n    if test h then h :: (filter test t)\n    else filter test t\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_filter1: filter even [1;2;3;4] = [2;4].",
    "Dependencies":[
      "filter",
      "cons",
      "nil",
      "list",
      "even"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition length_is_1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1.",
    "Dependencies":[
      "length",
      "list",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_filter2:\n    filter length_is_1\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].",
    "Dependencies":[
      "length_is_1",
      "filter",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition countoddmembers' (l:list nat) : nat :=\n  length (filter odd l).",
    "Dependencies":[
      "filter",
      "length",
      "list",
      "odd"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.",
    "Dependencies":[
      "countoddmembers'",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.",
    "Dependencies":[
      "countoddmembers'",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_countoddmembers'3:   countoddmembers' nil = 0.",
    "Dependencies":[
      "countoddmembers'",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_anon_fun':\n  doit3times (fun n => n * n) 2 = 256.",
    "Dependencies":[
      "doit3times"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_filter2':\n    filter (fun l => (length l) =? 1)\n           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]\n  = [ [3]; [4]; [8] ].",
    "Dependencies":[
      "filter",
      "length",
      "cons",
      "nil",
      "list",
      "eqb"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition filter_even_gt7 (l : list nat) : list nat\n  .",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_filter_even_gt7_1 :\n  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].",
    "Dependencies":[
      "filter_even_gt7",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_filter_even_gt7_2 :\n  filter_even_gt7 [5;2;6;19;129] = [].",
    "Dependencies":[
      "filter_even_gt7",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition partition {X : Type}\n                     (test : X -> bool)\n                     (l : list X)\n                   : list X * list X\n  .",
    "Dependencies":[
      "prod",
      "list",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).",
    "Dependencies":[
      "partition",
      "pair",
      "prod",
      "cons",
      "nil",
      "list",
      "odd"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).",
    "Dependencies":[
      "partition",
      "pair",
      "prod",
      "cons",
      "nil",
      "list",
      "false"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=\n  match l with\n  | []     => []\n  | h :: t => (f h) :: (map f t)\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_map2:\n  map odd [2;1;2;5] = [false;true;false;true].",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list",
      "odd",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_map3:\n    map (fun n => [even n;odd n]) [2;1;2;5]\n  = [[true;false];[false;true];[true;false];[false;true]].",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list",
      "odd",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),\n  map f (rev l) = rev (map f l).",
    "Dependencies":[
      "map",
      "rev",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)\n                   : list Y\n  .",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_flat_map1:\n  flat_map (fun n => [n;n;n]) [1;5;4]\n  = [1; 1; 1; 5; 5; 5; 4; 4; 4].",
    "Dependencies":[
      "flat_map",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition option_map {X Y : Type} (f : X -> Y) (xo : option X)\n                      : option Y :=\n  match xo with\n  | None => None\n  | Some x => Some (f x)\n  end.",
    "Dependencies":[
      "None",
      "Some",
      "option"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)\n                         : Y :=\n  match l with\n  | nil => b\n  | h :: t => f h (fold f t b)\n  end.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check (fold andb) : list bool -> bool -> bool.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example fold_example1 :\n  fold andb [true;true;false;true] true = false.",
    "Dependencies":[
      "fold",
      "cons",
      "nil",
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example fold_example2 :\n  fold mult [1;2;3;4] 1 = 24.",
    "Dependencies":[
      "fold",
      "cons",
      "nil"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example fold_example3 :\n  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].",
    "Dependencies":[
      "fold",
      "app",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition constfun {X: Type} (x: X) : nat -> X :=\n  fun (k:nat) => x.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ftrue := constfun true.",
    "Dependencies":[
      "constfun",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example constfun_example1 : ftrue 0 = true.",
    "Dependencies":[
      "ftrue",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example constfun_example2 : (constfun 5) 99 = 5.",
    "Dependencies":[
      "constfun"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check plus : nat -> nat -> nat.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check plus : nat -> nat -> nat.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition plus3 := plus 3.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check plus3 : nat -> nat.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_plus3 :    plus3 4 = 7.",
    "Dependencies":[
      "plus3"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_plus3' :   doit3times plus3 0 = 9.",
    "Dependencies":[
      "plus3",
      "doit3times"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_plus3'' :  doit3times (plus 3) 0 = 9.",
    "Dependencies":[
      "doit3times"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Exercises.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fold_length {X : Type} (l : list X) : nat :=\n  fold (fun _ n => S n) l 0.",
    "Dependencies":[
      "fold",
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_fold_length1 : fold_length [4;7;0] = 3.",
    "Dependencies":[
      "cons",
      "nil",
      "fold_length"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem fold_length_correct : forall X (l : list X),\n  fold_length l = length l.",
    "Dependencies":[
      "length",
      "list",
      "fold_length"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y\n  .",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_fold_map : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition prod_curry {X Y Z : Type}\n  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).",
    "Dependencies":[
      "pair",
      "prod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition prod_uncurry {X Y Z : Type}\n  (f : X -> Y -> Z) (p : X * Y) : Z\n  .",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_map1': map (plus 3) [2;0;2] = [5;3;5].",
    "Dependencies":[
      "map",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @prod_curry.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @prod_uncurry.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem uncurry_curry : forall (X Y Z : Type)\n                        (f : X -> Y -> Z)\n                        x y,\n  prod_curry (prod_uncurry f) x y = f x y.",
    "Dependencies":[
      "prod_uncurry",
      "prod_curry"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem curry_uncurry : forall (X Y Z : Type)\n                        (f : (X * Y) -> Z) (p : X * Y),\n  prod_uncurry (prod_curry f) p = f p.",
    "Dependencies":[
      "prod",
      "prod_uncurry",
      "prod_curry"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Church.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition cnat := forall X : Type, (X -> X) -> X -> X.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition one : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => f x.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition two : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => f (f x).",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition zero : cnat :=\n  fun (X : Type) (f : X -> X) (x : X) => x.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition three : cnat := @doit3times.",
    "Dependencies":[
      "doit3times",
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition zero' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => zero.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition one' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => succ zero.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition two' : cnat :=\n  fun (X : Type) (succ : X -> X) (zero : X) => succ (succ zero).",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example zero_church_peano : zero nat S O = 0.",
    "Dependencies":[
      "zero"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example one_church_peano : one nat S O = 1.",
    "Dependencies":[
      "one"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example two_church_peano : two nat S O = 2.",
    "Dependencies":[
      "two"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition scc (n : cnat) : cnat\n  .",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example scc_1 : scc zero = one.",
    "Dependencies":[
      "scc",
      "zero",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example scc_2 : scc one = two.",
    "Dependencies":[
      "scc",
      "two",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example scc_3 : scc two = three.",
    "Dependencies":[
      "scc",
      "three",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition plus (n m : cnat) : cnat\n  .",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition plus (n m : cnat) : cnat\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example plus_1 : plus zero one = one.",
    "Dependencies":[
      "plus",
      "zero",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example plus_2 : plus two three = plus three two.",
    "Dependencies":[
      "plus",
      "three",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example plus_3 :\n  plus (plus two two) three = plus one (plus three three).",
    "Dependencies":[
      "plus",
      "three",
      "two",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mult (n m : cnat) : cnat\n  .",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition mult (n m : cnat) : cnat\n  .",
    "Dependencies":[
      "plus"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example mult_1 : mult one one = one.",
    "Dependencies":[
      "mult",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example mult_2 : mult zero (plus three three) = zero.",
    "Dependencies":[
      "mult",
      "plus",
      "three",
      "zero",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example mult_3 : mult two three = plus three three.",
    "Dependencies":[
      "mult",
      "plus",
      "three",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition exp (n m : cnat) : cnat\n  .",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition exp (n m : cnat) : cnat\n  .",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example exp_1 : exp two two = plus two two.",
    "Dependencies":[
      "exp",
      "plus",
      "two",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example exp_2 : exp three zero = one.",
    "Dependencies":[
      "exp",
      "three",
      "zero",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example exp_3 : exp three two = plus (mult two (mult two two)) one.",
    "Dependencies":[
      "exp",
      "mult",
      "plus",
      "three",
      "two",
      "one",
      "cnat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Church.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Exercises.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Poly.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Poly.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Tactics.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Tactics.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.Poly.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall (n m : nat),\n  n = m ->\n  n = m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].",
    "Dependencies":[
      "aeval",
      "aexp"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall (n m o p : nat),\n  n = m ->\n  (n = m -> [n;o] = [m;p]) ->\n  [n;o] = [m;p].",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o p eq1 eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2a : forall (n m : nat),\n  (n,n) = (m,m)  ->\n  (forall (q r : nat), (q,q) = (r,r) -> [q] = [r]) ->\n  [n] = [m].",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m eq1 eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly_ex : forall p,\n  (forall n, even n = true -> even (S n) = false) ->\n  (forall n, even n = false -> odd n = true) ->\n  even p = true ->\n  odd (S p) = true.",
    "Dependencies":[
      "odd",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly3 : forall (n m : nat),\n  n = m ->\n  m = n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"symmetry.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rev_exercise1 : forall (l l' : list nat),\n  l = rev l' ->\n  l' = rev l.",
    "Dependencies":[
      "rev",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_eq_example : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a b c d e f eq1 eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> eq1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem trans_eq : forall (X:Type) (n m o : X),\n  n = m -> m = o -> n = o.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros X n m o eq1 eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> eq1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_eq_example' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Dependencies":[
      "trans_eq",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a b c d e f eq1 eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply trans_eq with (m:=[c;d]).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_eq_example'' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a b c d e f eq1 eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"transitivity [c;d].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_eq_exercise : forall (n m o p : nat),\n     m = (minustwo o) ->\n     (n + p) = m ->\n     (n + p) = (minustwo o).",
    "Dependencies":[
      "minustwo"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem S_injective : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (H2: n = pred (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem S_injective' : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"injection H as Hnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem injection_ex1 : forall (n m o : nat),\n  [n;m] = [o;o] ->\n  n = m.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"injection H as H1 H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),\n  x :: y :: l = z :: j ->\n  j = z :: l ->\n  x = y.",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem discriminate_ex1 : forall (n m : nat),\n  false = true ->\n  n = m.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem discriminate_ex2 : forall (n : nat),\n  S n = O ->\n  2 + 2 = 5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example discriminate_ex3 :\n  forall (X : Type) (x y z : X) (l j : list X),\n    x :: y :: l = [] ->\n    x = z.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_0_l : forall n,\n   0 =? n = true -> n = 0.",
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n as [| n'] eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),\n  x = y -> f x = f y.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A B f x y eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eq_implies_succ_equal : forall (n m : nat),\n  n = m -> S n = S m.",
    "Dependencies":[
      "f_equal"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply f_equal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eq_implies_succ_equal' : forall (n m : nat),\n  n = m -> S n = S m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"f_equal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem S_inj : forall (n m : nat) (b : bool),\n  ((S n) =? (S m)) = b  ->\n  (n =? m) = b.",
    "Dependencies":[
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m b H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly4 : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p q EQ H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"symmetry in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply EQ in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"symmetry in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem specialize_example: forall n,\n     (forall m, m*n = 0)\n  -> n = 0.",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"specialize H with (m := 1).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_eq_example''' : forall (a b c d e f : nat),\n     [a;b] = [c;d] ->\n     [c;d] = [e;f] ->\n     [a;b] = [e;f].",
    "Dependencies":[
      "trans_eq",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a b c d e f eq1 eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"specialize trans_eq with (m:=[c;d]) as H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem double_injective : forall n m,\n  double n = double m ->\n  n = m.",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n' IHn'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct m as [| m'] eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct m as [| m'] eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"f_equal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"injection eq as goal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply goal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_true : forall n m,\n  n =? m = true -> n = m.",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_informal_proof : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_n_n_injective : forall n m,\n  n + n = m + m ->\n  n = m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem double_injective_take2 : forall n m,\n  double n = double m ->\n  n = m.",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction m as [| m' IHm'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n as [| n'] eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n as [| n'] eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"f_equal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHm'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"injection eq as goal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply goal.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X),\n  length l = n ->\n  nth_error l n = None.",
    "Dependencies":[
      "nth_error",
      "None",
      "option",
      "length",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition square n := n * n.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma square_mult : forall n m, square (n * m) = square n * square m.",
    "Dependencies":[
      "square",
      "mult_assoc",
      "mul_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold square.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mult_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (H : n * m * n = n * n * m).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mul_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply mult_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mult_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo (x: nat) := 5.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo (x: nat) := 5.",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo (x: nat) := 5.",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition foo (x: nat) := 5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.",
    "Dependencies":[
      "foo"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition bar x :=\n  match x with\n  | O => 5\n  | S _ => 5\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.",
    "Dependencies":[
      "bar"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct m eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.",
    "Dependencies":[
      "bar"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold bar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct m eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition sillyfun (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem sillyfun_false : forall (n : nat),\n  sillyfun n = false.",
    "Dependencies":[
      "sillyfun",
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold sillyfun.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (n =? 3) eqn:E1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (n =? 5) eqn:E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end.",
    "Dependencies":[
      "prod",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint split {X Y : Type} (l : list (X*Y))\n               : (list X) * (list Y) :=\n  match l with\n  | [] => ([], [])\n  | (x, y) :: t =>\n      match split t with\n      | (lx, ly) => (x :: lx, y :: ly)\n      end\n  end.",
    "Dependencies":[
      "pair",
      "prod",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem combine_split : forall X Y (l : list (X * Y)) l1 l2,\n  split l = (l1, l2) ->\n  combine l1 l2 = l.",
    "Dependencies":[
      "split",
      "combine",
      "pair",
      "prod",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition sillyfun1 (n : nat) : bool :=\n  if n =? 3 then true\n  else if n =? 5 then true\n  else false.",
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem sillyfun1_odd : forall (n : nat),\n  sillyfun1 n = true ->\n  odd n = true.",
    "Dependencies":[
      "sillyfun1",
      "eqb_true",
      "eqb",
      "odd",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold sillyfun1 in eq.",
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (n =? 3) eqn:Heqe3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eqb_true in Heqe3.",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> Heqe3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (n =? 5) eqn:Heqe5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eqb_true in Heqe5.",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> Heqe5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem bool_fn_applied_thrice :\n  forall (f : bool -> bool) (b : bool),\n  f (f (f b)) = f b.",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_sym : forall (n m : nat),\n  (n =? m) = (m =? n).",
    "Dependencies":[
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_trans : forall n m p,\n  n =? m = true ->\n  m =? p = true ->\n  n =? p = true.",
    "Dependencies":[
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition split_combine_statement : Prop\n\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem split_combine : split_combine_statement.",
    "Dependencies":[
      "split_combine_statement"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_split_combine : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem filter_exercise : forall (X : Type) (test : X -> bool)\n                                 (x : X) (l lf : list X),\n  filter test l = x :: lf ->\n  test x = true.",
    "Dependencies":[
      "filter",
      "cons",
      "list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_forallb_1 : forallb odd [1;3;5;7;9] = true.",
    "Dependencies":[
      "forallb",
      "cons",
      "nil",
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_forallb_2 : forallb negb [false;false] = true.",
    "Dependencies":[
      "forallb",
      "cons",
      "nil",
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_forallb_3 : forallb even [0;2;4;5] = false.",
    "Dependencies":[
      "forallb",
      "cons",
      "nil",
      "even",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_forallb_4 : forallb (eqb 5) [] = true.",
    "Dependencies":[
      "forallb",
      "nil",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint existsb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_existsb_1 : existsb (eqb 5) [0;2;3;6] = false.",
    "Dependencies":[
      "existsb",
      "cons",
      "nil",
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_existsb_2 : existsb (andb true) [true;true;false] = true.",
    "Dependencies":[
      "existsb",
      "cons",
      "nil",
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_existsb_3 : existsb odd [1;0;0;0;0;3] = true.",
    "Dependencies":[
      "existsb",
      "cons",
      "nil",
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_existsb_4 : existsb even [] = false.",
    "Dependencies":[
      "existsb",
      "nil",
      "even",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition existsb' {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem existsb_existsb' : forall (X : Type) (test : X -> bool) (l : list X),\n  existsb test l = existsb' test l.",
    "Dependencies":[
      "existsb'",
      "existsb",
      "list",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Tactics.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Tactics.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Logic.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Logic.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.Tactics.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (forall n m : nat, n + m = m + n) : Prop.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check 2 = 2 : Prop.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check 3 = 2 : Prop.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check forall n : nat, n = 2 : Prop.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_2_2_is_4 :\n  2 + 2 = 4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition plus_claim : Prop := 2 + 2 = 4.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check plus_claim : Prop.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_claim_is_true :\n  plus_claim.",
    "Dependencies":[
      "plus_claim"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition is_three (n : nat) : Prop :=\n  n = 3.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check is_three : nat -> Prop.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition injective {A B} (f : A -> B) : Prop :=\n  forall x y : A, f x = f y -> x = y.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma succ_inj : injective S.",
    "Dependencies":[
      "injective"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros x y H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"injection H as H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @eq : forall A : Type, A -> A -> Prop.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example and_example : 3 + 4 = 7 \/\\ 2 * 2 = 4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @conj : forall A B : Prop, A -> B -> A \/\\ B.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example and_example' : 3 + 4 = 7 \/\\ 2 * 2 = 4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply conj.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example plus_is_O :\n  forall n m : nat, n + m = 0 -> n = 0 \/\\ m = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma and_example2 :\n  forall n m : nat, n = 0 \/\\ m = 0 -> n + m = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H as [Hn Hm].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma and_example2' :\n  forall n m : nat, n = 0 \/\\ m = 0 -> n + m = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m [Hn Hm].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma and_example2'' :\n  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m Hn Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma and_example3 :\n  forall n m : nat, n + m = 0 -> n * m = 0.",
    "Dependencies":[
      "plus_is_O"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply plus_is_O in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H as [Hn Hm].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma proj1 : forall P Q : Prop,\n  P \/\\ Q -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HPQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct HPQ as [HP _].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma proj2 : forall P Q : Prop,\n  P \/\\ Q -> Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem and_commut : forall P Q : Prop,\n  P \/\\ Q -> Q \/\\ P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q [HP HQ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem and_assoc : forall P Q R : Prop,\n  P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem and_assoc : forall P Q R : Prop,\n  P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q R [HP [HQ HR]].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check and : Prop -> Prop -> Prop.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma factor_is_O:\n  forall n m : nat, n = 0 \\\/ m = 0 -> n * m = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m [Hn | Hm].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- mult_n_O.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma or_intro_l : forall A B : Prop, A -> A \\\/ B.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A B HA.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HA.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma zero_or_succ :\n  forall n : nat, n = 0 \\\/ n = S (pred n).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [|n'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma mult_is_O :\n  forall n m, n * m = 0 -> n = 0 \\\/ m = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem or_commut : forall P Q : Prop,\n  P \\\/ Q  -> Q \\\/ P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module NotPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition not (P:Prop) := P -> False.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check not : Prop -> Prop.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"~ x\" := (not x) : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End NotPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ex_falso_quodlibet : forall (P:Prop),\n  False -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem not_implies_our_not : forall (P:Prop),\n  ~ P -> (forall (Q:Prop), P -> Q).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x <> y\" := (~(x = y)) : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem zero_not_one : 0 <> 1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem not_False :\n  ~ False.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem contradiction_implies_anything : forall P Q : Prop,\n  (P \/\\ ~P) -> Q.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem contradiction_implies_anything : forall P Q : Prop,\n  (P \/\\ ~P) -> Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q [HP HNP].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not in HNP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HNP in HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem double_neg : forall P : Prop,\n  P -> ~~P.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem double_neg : forall P : Prop,\n  P -> ~~P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros G.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply G.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_double_neg_informal : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem contrapositive : forall (P Q : Prop),\n  (P -> Q) -> (~Q -> ~P).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem not_both_true_and_false : forall P : Prop,\n  ~ (P \/\\ ~P).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_not_PNP_informal : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem de_morgan_not_or : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem de_morgan_not_or : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem not_true_is_false : forall b : bool,\n  b <> true -> b = false.",
    "Dependencies":[
      "ex_falso_quodlibet",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b eqn:HE.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ex_falso_quodlibet.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem not_true_is_false' : forall b : bool,\n  b <> true -> b = false.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [] H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exfalso.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma True_is_true : True.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply I.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition disc_fn (n: nat) : Prop :=\n  match n with\n  | O => True\n  | S _ => False\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem disc_example : forall n, ~ (O = S n).",
    "Dependencies":[
      "disc_fn"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (H : disc_fn O).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply I.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite contra in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nil_is_not_cons : forall X (x : X) (xs : list X), ~ (nil = x :: xs).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module IffPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition iff (P Q : Prop) := (P -> Q) \/\\ (Q -> P).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"P <-> Q\" := (iff P Q)\n                      (at level 95, no associativity)\n                      : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End IffPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem iff_sym : forall P Q : Prop,\n  (P <-> Q) -> (Q <-> P).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q [HAB HBA].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HBA.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HAB.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma not_true_iff_false : forall b,\n  b <> true <-> b = false.",
    "Dependencies":[
      "not_true_is_false",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply not_true_is_false.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma apply_iff_example1:\n  forall P Q R : Prop, (P <-> Q) -> (Q -> R) -> (P -> R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q R Hiff H HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hiff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma apply_iff_example2:\n  forall P Q R : Prop, (P <-> Q) -> (P -> R) -> (Q -> R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q R Hiff H HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hiff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem iff_refl : forall P : Prop,\n  P <-> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem iff_trans : forall P Q R : Prop,\n  (P <-> Q) -> (Q <-> R) -> (P <-> R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem or_distributes_over_and : forall P Q R : Prop,\n  P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem or_distributes_over_and : forall P Q R : Prop,\n  P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Corelib.Setoids.Setoid.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma mul_eq_0 : forall n m, n * m = 0 <-> n = 0 \\\/ m = 0.",
    "Dependencies":[
      "mult_is_O",
      "factor_is_O"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply mult_is_O.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply factor_is_O.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem or_assoc :\n  forall P Q R : Prop, P \\\/ (Q \\\/ R) <-> (P \\\/ Q) \\\/ R.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q R.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [H | [H | H]].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [[H | H] | H].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma mul_eq_0_ternary :\n  forall n m p, n * m * p = 0 <-> n = 0 \\\/ m = 0 \\\/ p = 0.",
    "Dependencies":[
      "or_assoc",
      "mul_eq_0"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mul_eq_0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mul_eq_0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite or_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition Even x := exists n : nat, x = double n.",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check Even : nat -> Prop.",
    "Dependencies":[
      "double"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma four_is_Even : Even 4.",
    "Dependencies":[
      "Even",
      "double"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold Even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists 2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem exists_example_2 : forall n,\n  (exists m, n = 4 + m) ->\n  (exists o, n = 2 + o).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n [m Hm].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists (2 + m).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem dist_not_exists : forall (X:Type) (P : X -> Prop),\n  (forall x, P x) -> ~ (exists x, ~ P x).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),\n  (exists x, P x \\\/ Q x) <-> (exists x, P x) \\\/ (exists x, Q x).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem leb_plus_exists : forall n m, n <=? m = true -> exists x, m = n+x.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_exists_leb : forall n m, (exists x, m = n+x) -> n <=? m = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\\/ In x l'\n  end.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=\n  match l with\n  | [] => False\n  | x' :: l' => x' = x \\\/ In x l'\n  end.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example In_example_1 : In 4 [1; 2; 3; 4; 5].",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example In_example_2 :\n  forall n, In n [2; 4] ->\n  exists n', n = 2 * n'.",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n [H | [H | []]].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists 1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists 2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In_map :\n  forall (A B : Type) (f : A -> B) (l : list A) (x : A),\n         In x l ->\n         In (f x) (map f l).",
    "Dependencies":[
      "map",
      "list_ind",
      "cons",
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A B f l x.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [|x' l' IHl'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [H | H].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHl'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In_map_iff :\n  forall (A B : Type) (f : A -> B) (l : list A) (y : B),\n         In y (map f l) <->\n         exists x, f x = y \/\\ In x l.",
    "Dependencies":[
      "map",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A B f l y.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [|x l' IHl'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In_app_iff : forall A l l' (a:A),\n  In a (l++l') <-> In a l \\\/ In a l'.",
    "Dependencies":[
      "app",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [|a' l' IH].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint All {T : Type} (P : T -> Prop) (l : list T) : Prop\n  .",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem All_In :\n  forall T (P : T -> Prop) (l : list T),\n    (forall x, In x l -> P x) <->\n    All P l.",
    "Dependencies":[
      "list",
      "All",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem combine_odd_even_intro :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    (odd n = true -> Podd n) ->\n    (odd n = false -> Peven n) ->\n    combine_odd_even Podd Peven n.",
    "Dependencies":[
      "combine_odd_even",
      "odd",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem combine_odd_even_elim_odd :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = true ->\n    Podd n.",
    "Dependencies":[
      "combine_odd_even",
      "odd",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem combine_odd_even_elim_even :\n  forall (Podd Peven : nat -> Prop) (n : nat),\n    combine_odd_even Podd Peven n ->\n    odd n = false ->\n    Peven n.",
    "Dependencies":[
      "combine_odd_even",
      "odd",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check plus : nat -> nat -> nat.",
    "Dependencies":[
      "cnat"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check plus : nat -> nat -> nat.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @rev : forall X, list X -> list X.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check add_comm        : forall n m : nat, n + m = m + n.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check plus_id_example : forall n m : nat, n = m -> n + n = m + m.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma add_comm3_take2 :\n  forall x y z, x + (y + z) = (z + y) + x.",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros x y z.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (H : y + z = z + y).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma add_comm3_take3 :\n  forall x y z, x + (y + z) = (z + y) + x.",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros x y z.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (add_comm y z).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma add_comm3_take4 :\n  forall x y z, x + (y + z) = (z + y) + x.",
    "Dependencies":[
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros x y z.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (add_comm x (y + z)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (add_comm y z).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem in_not_nil :\n  forall A (x : A) (l : list A), In x l -> l <> [].",
    "Dependencies":[
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A x l H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intro Hl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma in_not_nil_42_take2 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply in_not_nil with (x := 42).",
    "Dependencies":[
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma in_not_nil_42_take3 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply in_not_nil in H.",
    "Dependencies":[
      "nil",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma in_not_nil_42_take4 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (in_not_nil nat 42).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma in_not_nil_42_take5 :\n  forall l : list nat, In 42 l -> l <> [].",
    "Dependencies":[
      "nil",
      "list",
      "in_not_nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros l H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (in_not_nil _ _ _ H).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example lemma_application_ex :\n  forall {n : nat} {ns : list nat},\n    In n (map (fun m => m * 0) ns) ->\n    n = 0.",
    "Dependencies":[
      "map",
      "list",
      "In_map_iff",
      "In",
      "proj1",
      "mul_0_r"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n ns H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n           as [m [Hm _]].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mul_0_r in Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example even_42_bool : even 42 = true.",
    "Dependencies":[
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example even_42_prop : Even 42.",
    "Dependencies":[
      "Even",
      "double"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold Even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists 21.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma even_double : forall k, even (double k) = true.",
    "Dependencies":[
      "double",
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros k.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction k as [|k' IHk'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHk'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma even_double_conv : forall n, exists k,\n  n = if even n then double k else S (double k).",
    "Dependencies":[
      "double",
      "even",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem even_bool_prop : forall n,\n  even n = true <-> Even n.",
    "Dependencies":[
      "even_double_conv",
      "even_double",
      "Even",
      "double",
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (even_double_conv n) as [k Hk].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hk.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists k.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [k Hk].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hk.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply even_double.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_eq : forall n1 n2 : nat,\n  n1 =? n2 = true <-> n1 = n2.",
    "Dependencies":[
      "eqb_true",
      "eqb_refl",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n1 n2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eqb_true.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite eqb_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail\nDefinition is_even_prime n :=\n  if n = 2 then true\n  else false.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition is_even_prime n :=\n  if n =? 2 then true\n  else false.",
    "Dependencies":[
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example even_1000 : Even 1000.",
    "Dependencies":[
      "Even",
      "double"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold Even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists 500.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example even_1000' : even 1000 = true.",
    "Dependencies":[
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example even_1000'' : Even 1000.",
    "Dependencies":[
      "even_bool_prop",
      "Even",
      "even",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply even_bool_prop.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example not_even_1001 : even 1001 = false.",
    "Dependencies":[
      "even",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example not_even_1001' : ~(Even 1001).",
    "Dependencies":[
      "even_bool_prop",
      "Even",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- even_bool_prop.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intro H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma plus_eqb_example : forall n m p : nat,\n  n =? m = true -> n + p =? m + p = true.",
    "Dependencies":[
      "eqb_eq",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite eqb_eq in H.",
    "Dependencies":[
      "eqb_true",
      "eqb_refl",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite eqb_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_true_iff : forall b1 b2:bool,\n  b1 && b2 = true <-> b1 = true \/\\ b2 = true.",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem orb_true_iff : forall b1 b2,\n  b1 || b2 = true <-> b1 = true \\\/ b2 = true.",
    "Dependencies":[
      "orb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_neq : forall x y : nat,\n  x =? y = false <-> x <> y.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint eqb_list {A : Type} (eqb : A -> A -> bool)\n                  (l1 l2 : list A) : bool\n  .",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqb_list_true_iff :\n  forall A (eqb : A -> A -> bool),\n    (forall a1 a2, eqb a1 a2 = true <-> a1 = a2) ->\n    forall l1 l2, eqb_list eqb l1 l2 = true <-> l1 = l2.",
    "Dependencies":[
      "list",
      "eqb_list",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool\n  .",
    "Dependencies":[
      "list",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem forallb_true_iff : forall X test (l : list X),\n  forallb test l = true <-> All (fun x => test x = true) l.",
    "Dependencies":[
      "list",
      "forallb",
      "All",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example function_equality_ex1 :\n  (fun x => 3 + x) = (fun x => (pred 4) + x).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Axiom functional_extensionality : forall {X Y: Type}\n                                    {f g : X -> Y},\n  (forall (x:X), f x = g x) -> f = g.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example function_equality_ex2 :\n  (fun x => plus x 1) = (fun x => plus 1 x).",
    "Dependencies":[
      "functional_extensionality",
      "add_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply functional_extensionality.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros x.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint rev_append {X} (l1 l2 : list X) : list X :=\n  match l1 with\n  | [] => l2\n  | x :: l1' => rev_append l1' (x :: l2)\n  end.",
    "Dependencies":[
      "cons",
      "list"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition tr_rev {X} (l : list X) : list X :=\n  rev_append l [].",
    "Dependencies":[
      "nil",
      "list",
      "rev_append"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem tr_rev_correct : forall X, @tr_rev X = @rev X.",
    "Dependencies":[
      "rev",
      "list",
      "tr_rev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition excluded_middle := forall P : Prop,\n  P \\\/ ~ P.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem restricted_excluded_middle : forall P b,\n  (P <-> b = true) -> P \\\/ ~ P.",
    "Dependencies":[
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P [] H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem restricted_excluded_middle_eq : forall (n m : nat),\n  n = m \\\/ n <> m.",
    "Dependencies":[
      "restricted_excluded_middle",
      "eqb_eq",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (restricted_excluded_middle (n = m) (n =? m)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"symmetry.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eqb_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem excluded_middle_irrefutable: forall (P : Prop),\n  ~ ~ (P \\\/ ~ P).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem not_exists_dist :\n  excluded_middle ->\n  forall (X:Type) (P : X -> Prop),\n    ~ (exists x, ~ P x) -> (forall x, P x).",
    "Dependencies":[
      "excluded_middle"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition peirce := forall P Q: Prop,\n  ((P -> Q) -> P) -> P.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition double_negation_elimination := forall P:Prop,\n  ~~P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition de_morgan_not_and_not := forall P Q:Prop,\n  ~(~P \/\\ ~Q) -> P \\\/ Q.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition implies_to_or := forall P Q:Prop,\n  (P -> Q) -> (~P \\\/ Q).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition consequentia_mirabilis := forall P:Prop,\n  (~P -> P) -> P.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Logic.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Logic.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_IndProp.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module IndProp.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.Logic.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint div2 (n : nat) : nat :=\n  match n with\n    0 => 0\n  | 1 => 0\n  | S (S n) => S (div2 n)\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition csf (n : nat) : nat :=\n  if even n then div2 n\n  else (3 * n) + 1.",
    "Dependencies":[
      "div2",
      "even",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Fixpoint reaches1_in (n : nat) : nat :=\n  if n =? 1 then 0\n  else 1 + reaches1_in (csf n).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Fixpoint Collatz_holds_for (n : nat) : Prop :=\n  match n with\n  | 0 => False\n  | 1 => True\n  | _ => if even n then Collatz_holds_for (div2 n)\n                   else Collatz_holds_for ((3 * n) + 1)\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive Collatz_holds_for : nat -> Prop :=\n  | Chf_one : Collatz_holds_for 1\n  | Chf_even (n : nat) : even n = true ->\n                         Collatz_holds_for (div2 n) ->\n                         Collatz_holds_for n\n  | Chf_odd (n : nat) :  even n = false ->\n                         Collatz_holds_for ((3 * n) + 1) ->\n                         Collatz_holds_for n.",
    "Dependencies":[
      "div2",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example Collatz_holds_for_12 : Collatz_holds_for 12.",
    "Dependencies":[
      "Chf_odd",
      "Chf_even",
      "Chf_one",
      "Collatz_holds_for",
      "div2",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_odd.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_odd.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Chf_one.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Conjecture collatz : forall n, n <> 0 -> Collatz_holds_for n.",
    "Dependencies":[
      "Collatz_holds_for"
    ]
  },
  {
    "Type":"Module",
    "Chunk":"Module LePlayground.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)   : le n n\n  | le_S (n m : nat) : le n m -> le n (S m).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"n <= m\" := (le n m) (at level 70).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example le_3_5 : 3 <= 5.",
    "Dependencies":[
      "le_S",
      "le_n",
      "le"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LePlayground.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive clos_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | t_step (x y : X) :\n      R x y ->\n      clos_trans R x y\n  | t_trans (x y z : X) :\n      clos_trans R x y ->\n      clos_trans R y z ->\n      clos_trans R x z.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive Person : Type := Sage | Cleo | Ridley | Moss.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive parent_of : Person -> Person -> Prop :=\n  po_SC : parent_of Sage Cleo\n| po_SR : parent_of Sage Ridley\n| po_CM : parent_of Cleo Moss.",
    "Dependencies":[
      "Moss",
      "Ridley",
      "Cleo",
      "Sage"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ancestor_of : Person -> Person -> Prop :=\n  clos_trans parent_of.",
    "Dependencies":[
      "parent_of",
      "Person",
      "clos_trans"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example ancestor_of_ex : ancestor_of Sage Moss.",
    "Dependencies":[
      "ancestor_of",
      "po_CM",
      "po_SC",
      "parent_of",
      "Moss",
      "Cleo",
      "Sage",
      "Person",
      "t_trans",
      "t_step"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold ancestor_of.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply t_trans with Cleo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply t_step.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply po_SC.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply t_step.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply po_CM.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive clos_refl_trans {X: Type} (R: X->X->Prop) : X->X->Prop :=\n  | rt_step (x y : X) :\n      R x y ->\n      clos_refl_trans R x y\n  | rt_refl (x : X) :\n      clos_refl_trans R x x\n  | rt_trans (x y z : X) :\n      clos_refl_trans R x y ->\n      clos_refl_trans R y z ->\n      clos_refl_trans R x z.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition cs (n m : nat) : Prop := csf n = m.",
    "Dependencies":[
      "csf"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition cms n m := clos_refl_trans cs n m.",
    "Dependencies":[
      "cs",
      "clos_refl_trans"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Conjecture collatz' : forall n, n <> 0 -> cms n 1.",
    "Dependencies":[
      "cms"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Inductive wrong_ev (n : nat) : Prop :=\n  | wrong_ev_0 : wrong_ev 0\n  | wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_0 : ev 0.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_0 : ev 0.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_0 : ev 0.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export EvPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0  : ev 0\n  | ev_SS : forall (n : nat), ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End EvPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4 : ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4 : ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4' : ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4' : ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (ev_SS 2 (ev_SS 0 ev_0)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros Hn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_double : forall n,\n  ev (double n).",
    "Dependencies":[
      "double",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma Perm3_rev : Perm3 [1;2;3] [3;2;1].",
    "Dependencies":[
      "cons",
      "nil",
      "perm3_trans",
      "perm3_swap23",
      "perm3_swap12",
      "Perm3"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_trans with (l2:=[2;3;1]).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_trans with (l2:=[2;3;1]).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_trans with (l2:=[2;1;3]).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_trans with (l2:=[2;1;3]).",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_swap12.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_swap23.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_swap12.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma Perm3_rev' : Perm3 [1;2;3] [3;2;1].",
    "Dependencies":[
      "cons",
      "nil",
      "perm3_trans",
      "perm3_swap23",
      "perm3_swap12",
      "Perm3"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (perm3_trans _ [2;3;1] _\n          (perm3_trans _ [2;1;3] _\n            (perm3_swap12 _ _ _)\n            (perm3_swap23 _ _ _))\n          (perm3_swap12 _ _ _)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma Perm3_ex1 : Perm3 [1;2;3] [2;3;1].",
    "Dependencies":[
      "cons",
      "nil",
      "Perm3"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma Perm3_refl : forall (X : Type) (a b c : X),\n  Perm3 [a;b;c] [a;b;c].",
    "Dependencies":[
      "cons",
      "nil",
      "Perm3"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_inversion : forall (n : nat),\n    ev n ->\n    (n = 0) \\\/ (exists n', n = S (S n') \/\\ ev n').",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct E as [ | n' E'] eqn:EE.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists n'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_inversion : forall (n m : nat),\n  le n m ->\n  (n = m) \\\/ (exists m', m = S m' \/\\ le n m').",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem evSS_ev : forall n, ev (S (S n)) -> ev n.",
    "Dependencies":[
      "ev_inversion",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_inversion in E.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"destruct E as [H0|H1].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H1 as [n' [Hnn' E']].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"injection Hnn' as Hnn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hnn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem evSS_ev' : forall n,\n  ev (S (S n)) -> ev n.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion E as [| n' E' Hnn'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem one_not_even : ~ ev 1.",
    "Dependencies":[
      "ev_inversion",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_inversion in H.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H as [ | [m [Hm _]]].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate Hm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem one_not_even' : ~ ev 1.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem SSSSev__even : forall n,\n  ev (S (S (S (S n)))) -> ev n.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev5_nonsense :\n  ev 5 -> 2 + 2 = 9.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem inversion_ex1 : forall (n m o : nat),\n  [n; m] = [o; o] -> [n] = [m].",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem inversion_ex2 : forall (n : nat),\n  S n = O -> 2 + 2 = 5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma ev_Even : forall n,\n  ev n -> Even n.",
    "Dependencies":[
      "Even",
      "double",
      "ev_ind",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold Even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction E as [|n' E' IH].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct IH as [k Hk].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hk.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists (S k).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_Even_iff : forall n,\n  ev n <-> Even n.",
    "Dependencies":[
      "Even",
      "double",
      "ev_Even",
      "ev_double",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_Even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold Even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [k Hk].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hk.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_double.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m).",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_ev__ev : forall n m,\n  ev (n+m) -> ev n -> ev m.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_plus_plus : forall n m p,\n  ev (n+m) -> ev (n+p) -> ev (m+p).",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev'_ev : forall n, ev' n <-> ev n.",
    "Dependencies":[
      "ev'",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Perm3Reminder.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive Perm3 {X : Type} : list X -> list X -> Prop :=\n  | perm3_swap12 (a b c : X) :\n      Perm3 [a;b;c] [b;a;c]\n  | perm3_swap23 (a b c : X) :\n      Perm3 [a;b;c] [a;c;b]\n  | perm3_trans (l1 l2 l3 : list X) :\n      Perm3 l1 l2 -> Perm3 l2 l3 -> Perm3 l1 l3.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End Perm3Reminder.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma Perm3_symm : forall (X : Type) (l1 l2 : list X),\n  Perm3 l1 l2 -> Perm3 l2 l1.",
    "Dependencies":[
      "list",
      "Perm3_ind",
      "perm3_trans",
      "perm3_swap23",
      "perm3_swap12",
      "Perm3"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros X l1 l2 E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction E as [a b c | a b c | l1 l2 l3 E12 IH12 E23 IH23].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_swap12.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply perm3_swap23.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (perm3_trans _ l2 _).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH23.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH12.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma Perm3_In : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> In x l1 -> In x l2.",
    "Dependencies":[
      "list",
      "Perm3",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma Perm3_NotIn : forall (X : Type) (x : X) (l1 l2 : list X),\n    Perm3 l1 l2 -> ~In x l1 -> ~In x l2.",
    "Dependencies":[
      "list",
      "Perm3",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example Perm3_example2 : ~ Perm3 [1;2;3] [1;2;4].",
    "Dependencies":[
      "cons",
      "nil",
      "Perm3"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Playground.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive le : nat -> nat -> Prop :=\n  | le_n (n : nat)                : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"n <= m\" := (le n m).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem test_le1 :\n  3 <= 3.",
    "Dependencies":[
      "le_n",
      "le"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem test_le2 :\n  3 <= 6.",
    "Dependencies":[
      "le_S",
      "le_n",
      "le"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem test_le3 :\n  (2 <= 1) -> 2 + 2 = 5.",
    "Dependencies":[
      "le"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition lt (n m : nat) := le (S n) m.",
    "Dependencies":[
      "le"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"n < m\" := (lt n m).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ge (m n : nat) : Prop := le n m.",
    "Dependencies":[
      "le"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"m >= n\" := (ge m n).",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Playground.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem O_le_n : forall n,\n  0 <= n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem n_le_m__Sn_le_Sm : forall n m,\n  n <= m -> S n <= S m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem Sn_le_Sm__n_le_m : forall n m,\n  S n <= S m -> n <= m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_plus_l : forall a b,\n  a <= a + b.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_le : forall n1 n2 m,\n  n1 + n2 <= m ->\n  n1 <= m \/\\ n2 <= m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_le_cases : forall n m p q,\n  n + m <= p + q -> n <= p \\\/ m <= q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_le_compat_l : forall n m p,\n  n <= m ->\n  p + n <= p + m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_le_compat_r : forall n m p,\n  n <= m ->\n  n + p <= m + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_plus_trans : forall n m p,\n  n <= m ->\n  n <= m + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lt_ge_cases : forall n m,\n  n < m \\\/ n >= m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem n_lt_m__n_le_m : forall n m,\n  n < m ->\n  n <= m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_lt : forall n1 n2 m,\n  n1 + n2 < m ->\n  n1 < m \/\\ n2 < m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem leb_complete : forall n m,\n  n <=? m = true -> n <= m.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem leb_correct : forall n m,\n  n <= m ->\n  n <=? m = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem leb_iff : forall n m,\n  n <=? m = true <-> n <= m.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem leb_true_trans : forall n m o,\n  n <=? m = true -> m <=? o = true -> n <=? o = true.",
    "Dependencies":[
      "leb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive R : nat -> nat -> nat -> Prop :=\n  | c1                                     : R 0     0     0\n  | c2 m n o (H : R m     n     o        ) : R (S m) n     (S o)\n  | c3 m n o (H : R m     n     o        ) : R m     (S n) (S o)\n  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m     n     o\n  | c5 m n o (H : R m     n     o        ) : R n     m     o\n.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_R_provability : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fR : nat -> nat -> nat\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem R_equiv_fR : forall m n o, R m n o <-> fR m n = o.",
    "Dependencies":[
      "fR",
      "R"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive subseq : list nat -> list nat -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem subseq_refl : forall (l : list nat), subseq l l.",
    "Dependencies":[
      "list",
      "subseq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem subseq_app : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l1 (l2 ++ l3).",
    "Dependencies":[
      "app",
      "list",
      "subseq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem subseq_trans : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l2 l3 ->\n  subseq l1 l3.",
    "Dependencies":[
      "list",
      "subseq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments EmptySet {T}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments EmptyStr {T}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments Char {T} _.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments App {T} _ _.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments Union {T} _ _.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments Star {T} _.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation \"s =~ re\" (at level 80).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR s2 re1 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)\n\n  where \"s =~ re\" := (exp_match s re).",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example reg_exp_ex1 : [1] =~ Char 1.",
    "Dependencies":[
      "cons",
      "nil",
      "MChar",
      "exp_match",
      "Char"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).",
    "Dependencies":[
      "cons",
      "nil",
      "MApp",
      "MChar",
      "exp_match",
      "App",
      "Char"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (MApp [1]).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example reg_exp_ex3 : ~ ([1; 2] =~ Char 1).",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint reg_exp_of_list {T} (l : list T) :=\n  match l with\n  | [] => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end.",
    "Dependencies":[
      "list",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].",
    "Dependencies":[
      "cons",
      "nil",
      "reg_exp_of_list",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "App",
      "Char",
      "EmptyStr"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (MApp [1]).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (MApp [2]).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (MApp [3]).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma MStar1 :\n  forall T s (re : reg_exp T) ,\n    s =~ re ->\n    s =~ Star re.",
    "Dependencies":[
      "app_nil_r",
      "app",
      "nil",
      "list",
      "MStarApp",
      "MStar0",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T s re H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- (app_nil_r _ s).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStarApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma EmptySet_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).",
    "Dependencies":[
      "list",
      "exp_match",
      "EmptySet"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\\/ s =~ re2 ->\n  s =~ Union re1 re2.",
    "Dependencies":[
      "list",
      "exp_match",
      "Union",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold app ss [] =~ Star re.",
    "Dependencies":[
      "fold",
      "app",
      "nil",
      "list",
      "In",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition EmptyStr' {T:Type} := @Star T (EmptySet).",
    "Dependencies":[
      "Star",
      "EmptySet",
      "reg_exp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet => []\n  | EmptyStr => []\n  | Char x => [x]\n  | App re1 re2 => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re => re_chars re\n  end.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "reg_exp"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem in_re_match : forall T (s : list T) (re : reg_exp T) (x : T),\n  s =~ re ->\n  In x s ->\n  In x (re_chars re).",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "In_app_iff",
      "In",
      "re_chars",
      "exp_match_ind",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T s re x Hmatch Hin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction Hmatch\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct Hin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite In_app_iff in *.",
    "Dependencies":[
      "app",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"destruct Hin as [Hin | Hin].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IH1 Hin).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IH2 Hin).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite In_app_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IH Hin).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite In_app_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IH Hin).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct Hin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite In_app_iff in Hin.",
    "Dependencies":[
      "app",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"destruct Hin as [Hin | Hin].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IH1 Hin).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IH2 Hin).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n  .",
    "Dependencies":[
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.",
    "Dependencies":[
      "list",
      "re_not_empty",
      "exp_match",
      "reg_exp",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.",
    "Dependencies":[
      "app_assoc",
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T s1 s2 re H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"remember (Star re) as re' eqn:Eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- app_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStarApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hmatch1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T),\n    s = fold app ss []\n    \/\\ forall s', In s' ss -> s' =~ re.",
    "Dependencies":[
      "fold",
      "app",
      "nil",
      "list",
      "In",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Pumping.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end.",
    "Dependencies":[
      "reg_exp"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma pumping_constant_ge_1 :\n  forall T (re : reg_exp T),\n    pumping_constant re >= 1.",
    "Dependencies":[
      "pumping_constant",
      "reg_exp_ind",
      "Star",
      "Union",
      "App",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "le_plus_l",
      "le_trans"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction re.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (n:=pumping_constant re1).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (n:=pumping_constant re1).",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHre1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_plus_l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (n:=pumping_constant re1).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (n:=pumping_constant re1).",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHre1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_plus_l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHre.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma pumping_constant_0_false :\n  forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.",
    "Dependencies":[
      "pumping_constant_ge_1",
      "pumping_constant",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (Hp1 : pumping_constant re >= 1).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply pumping_constant_ge_1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in Hp1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Hp1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end.",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.",
    "Dependencies":[
      "napp",
      "app_assoc",
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T n m l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [|n IHn].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHn, app_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.",
    "Dependencies":[
      "napp",
      "app_assoc",
      "app",
      "list",
      "MStarApp",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T m s1 s2 re Hs1 Hs2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hs2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- app_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStarApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hs1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re s Hmatch.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    length s1 + length s2 <= pumping_constant re \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 \/\\\n    s2 <> [] \/\\\n    length s1 + length s2 <= pumping_constant re \/\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re s Hmatch.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Pumping.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem filter_not_empty_In : forall n l,\n  filter (fun x => n =? x) l <> [] -> In n l.",
    "Dependencies":[
      "filter",
      "list_ind",
      "cons",
      "nil",
      "list",
      "eqb_eq",
      "In",
      "eqb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [|m l' IHl'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (n =? m) eqn:H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros _.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite eqb_eq in H.",
    "Dependencies":[
      "eqb_true",
      "eqb_refl",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHl'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false.",
    "Dependencies":[
      "pair",
      "prod",
      "t_branch",
      "t_leaf",
      "t_tree"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H :   P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false.",
    "Dependencies":[
      "false",
      "true"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem iff_reflect : forall P b, (P <-> b = true) -> reflect P b.",
    "Dependencies":[
      "ReflectF",
      "ReflectT",
      "reflect",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P b H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b eqn:Eb.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ReflectT.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ReflectF.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem reflect_iff : forall P b, reflect P b -> (P <-> b = true).",
    "Dependencies":[
      "reflect",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma eqbP : forall n m, reflect (n = m) (n =? m).",
    "Dependencies":[
      "eqb_eq",
      "iff_reflect",
      "reflect",
      "eqb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply iff_reflect.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite eqb_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem filter_not_empty_In' : forall n l,\n  filter (fun x => n =? x) l <> [] ->\n  In n l.",
    "Dependencies":[
      "filter",
      "list_ind",
      "cons",
      "nil",
      "list",
      "In",
      "eqbP",
      "reflect",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [|m l' IHl'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (eqbP n m) as [EQnm | NEQnm].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros _.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite EQnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHl'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end.",
    "Dependencies":[
      "list",
      "eqb",
      "bool"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end.",
    "Dependencies":[
      "bag"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eqbP_practice : forall n l,\n  count n l = 0 -> ~(In n l).",
    "Dependencies":[
      "list",
      "In",
      "count"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n l Hcount.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l as [| m l' IHl'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive nostutter {X:Type} : list X -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nostutter_1: nostutter [3;1;4;1;5;6].",
    "Dependencies":[
      "cons",
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nostutter_2:  nostutter (@nil nat).",
    "Dependencies":[
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nostutter_3:  nostutter [5].",
    "Dependencies":[
      "cons",
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_nostutter_4:      not (nostutter [3;1;1;4]).",
    "Dependencies":[
      "cons",
      "nil",
      "nostutter"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_nostutter : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive merge {X:Type} : list X -> list X -> list X -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem merge_filter : forall (X : Set) (test: X->bool) (l l1 l2 : list X),\n  merge l1 l2 l ->\n  All (fun n => test n = true) l1 ->\n  All (fun n => test n = false) l2 ->\n  filter test l = l1.",
    "Dependencies":[
      "filter",
      "list",
      "All",
      "merge",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive pal {X:Type} : list X -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem pal_app_rev : forall (X:Type) (l : list X),\n  pal (l ++ (rev l)).",
    "Dependencies":[
      "rev",
      "app",
      "list",
      "pal"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem pal_rev : forall (X:Type) (l: list X) , pal l -> l = rev l.",
    "Dependencies":[
      "rev",
      "list",
      "pal"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem palindrome_converse: forall {X: Type} (l: list X),\n    l = rev l -> pal l.",
    "Dependencies":[
      "rev",
      "list",
      "pal"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module RecallIn.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\\/ In A x l'\n     end.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint In (A : Type) (x : A) (l : list A) : Prop :=\n     match l with\n     | [] => False\n     | x' :: l' => x' = x \\\/ In A x l'\n     end.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End RecallIn.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_NoDup_disjoint_etc : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma in_split : forall (X:Type) (x:X) (l:list X),\n  In x l ->\n  exists l1 l2, l = l1 ++ x :: l2.",
    "Dependencies":[
      "app",
      "cons",
      "list",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive repeats {X:Type} : list X -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_check_repeats : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem pigeonhole_principle: excluded_middle ->\n  forall (X:Type) (l1  l2:list X),\n  (forall x, In x l1 -> In x l2) ->\n  length l2 < length l1 ->\n  repeats l1.",
    "Dependencies":[
      "length",
      "list",
      "excluded_middle",
      "In",
      "repeats"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros EM X l1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction l1 as [|x l1' IHl1'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Coq.Strings.Ascii.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition string := list ascii.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma provable_equiv_true : forall (P : Prop), P -> (P <-> True).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"constructor.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros _.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma not_equiv_false : forall (P : Prop), ~P -> (P <-> False).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma null_matches_none : forall (s : string), (s =~ EmptySet) <-> False.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "not_equiv_false",
      "string",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply not_equiv_false.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma empty_matches_eps : forall (s : string), s =~ EmptyStr <-> s = [ ].",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "string",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma empty_nomatch_ne : forall (a : ascii) s, (a :: s =~ EmptyStr) <-> False.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "not_equiv_false",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply not_equiv_false.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma char_nomatch_char :\n  forall (a b : ascii) s, b <> a -> (b :: s =~ Char a <-> False).",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "not_equiv_false",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply not_equiv_false.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma char_eps_suffix : forall (a : ascii) s, a :: s =~ Char a <-> s = [ ].",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "MChar",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma app_exists : forall (s : string) re0 re1,\n  s =~ App re0 re1 <->\n  exists s0 s1, s = s0 ++ s1 \/\\ s0 =~ re0 \/\\ s1 =~ re1.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "string",
      "MApp",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exists s1, s2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [ s0 [ s1 [ Happ [ Hmat0 Hmat1 ] ] ] ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Happ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (MApp s0 _ s1 _ Hmat0 Hmat1).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma app_ne : forall (a : ascii) s re0 re1,\n  a :: s =~ (App re0 re1) <->\n  ([ ] =~ re0 \/\\ a :: s =~ re1) \\\/\n  exists s0 s1, s = s0 ++ s1 \/\\ a :: s0 =~ re0 \/\\ s1 =~ re1.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match",
      "App",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma union_disj : forall (s : string) re0 re1,\n  s =~ Union re0 re1 <-> s =~ re0 \\\/ s =~ re1.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "string",
      "MUnionR",
      "MUnionL",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"right.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [ H | H ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma star_ne : forall (a : ascii) s re,\n  a :: s =~ Star re <->\n  exists s0 s1, s = s0 ++ s1 \/\\ a :: s0 =~ re \/\\ s1 =~ Star re.",
    "Dependencies":[
      "app",
      "cons",
      "list",
      "exp_match",
      "Star",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition refl_matches_eps m :=\n  forall re : reg_exp ascii, reflect ([ ] =~ re) (m re).",
    "Dependencies":[
      "nil",
      "reflect",
      "exp_match",
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint match_eps (re: reg_exp ascii) : bool\n  .",
    "Dependencies":[
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma match_eps_refl : refl_matches_eps match_eps.",
    "Dependencies":[
      "match_eps",
      "refl_matches_eps"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition is_der re (a : ascii) re' :=\n  forall s, a :: s =~ re <-> s =~ re'.",
    "Dependencies":[
      "cons",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition derives d := forall a re, is_der re a (d a re).",
    "Dependencies":[
      "is_der",
      "reg_exp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint derive (a : ascii) (re : reg_exp ascii) : reg_exp ascii\n  .",
    "Dependencies":[
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example c := ascii_of_nat 99.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example c := ascii_of_nat 99.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example d := ascii_of_nat 100.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example d := ascii_of_nat 100.",
    "Dependencies":[
      "mumble"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der0 : match_eps (derive c (EmptySet)) = false.",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "EmptySet",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der1 : match_eps (derive c (Char c)) = true.",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "Char",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der2 : match_eps (derive c (Char d)) = false.",
    "Dependencies":[
      "d",
      "c",
      "derive",
      "match_eps",
      "Char",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der3 : match_eps (derive c (App (Char c) EmptyStr)) = true.",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "EmptyStr",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der4 : match_eps (derive c (App EmptyStr (Char c))) = true.",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "EmptyStr",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der5 : match_eps (derive c (Star (Char c))) = true.",
    "Dependencies":[
      "c",
      "derive",
      "match_eps",
      "Star",
      "Char",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der6 :\n  match_eps (derive d (derive c (App (Char c) (Char d)))) = true.",
    "Dependencies":[
      "d",
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example test_der7 :\n  match_eps (derive d (derive c (App (Char d) (Char c)))) = false.",
    "Dependencies":[
      "d",
      "c",
      "derive",
      "match_eps",
      "App",
      "Char",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma derive_corr : derives derive.",
    "Dependencies":[
      "derive",
      "derives"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition matches_regex m : Prop :=\n  forall (s : string) re, reflect (s =~ re) (m s re).",
    "Dependencies":[
      "string",
      "reflect",
      "exp_match",
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint regex_match (s : string) (re : reg_exp ascii) : bool\n  .",
    "Dependencies":[
      "string",
      "reg_exp",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem regex_match_correct : matches_regex regex_match.",
    "Dependencies":[
      "regex_match",
      "matches_regex"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End IndProp.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_IndProp.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_AltAuto.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export AltAuto.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality,-deprecated-syntactic-definition,-deprecated]\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.Arith Stdlib.Lists.List.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.IndProp.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App EmptyStr re2 => re_opt_e re2\n  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)\n  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)\n  | Star re => Star (re_opt_e re)\n  | _ => re\n  end.",
    "Dependencies":[
      "Star",
      "Union",
      "App",
      "reg_exp"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma re_opt_e_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt_e"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re s M.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Hmatch1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStarApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall n, 1 + n = S n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall n, 1 + n = S n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall n, 1 + n = S n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall (P : Prop), P -> P.",
    "Dependencies":[
      "aeval",
      "aexp"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall (P : Prop), P -> P.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma simple_semi : forall n, (n + 1 =? 0) = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n eqn:E.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma simple_semi' : forall n, (n + 1 =? 0) = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n;\n\n  simpl;\n\n  reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma simple_semi'' : forall n, (n + 1 =? 0) = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n; reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_eq_orb :\n  forall (b c : bool),\n  (andb b c = orb b c) ->\n  b = c.",
    "Dependencies":[
      "orb",
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint nonzeros (lst : list nat) :=\n  match lst with\n  | [] => []\n  | 0 :: t => nonzeros t\n  | h :: t => h :: nonzeros t\n  end.",
    "Dependencies":[
      "natlist"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).",
    "Dependencies":[
      "app",
      "list",
      "nonzeros"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma nonzeros_app : forall lst1 lst2 : list nat,\n  nonzeros (lst1 ++ lst2) = (nonzeros lst1) ++ (nonzeros lst2).",
    "Dependencies":[
      "nonzeros",
      "app",
      "natlist"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma re_opt_e_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt_e"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re s M.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];\n\n    simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re1;\n\n    try (apply MApp; try apply IH1; apply IH2).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Hmatch1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStarApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Dependencies":[
      "app",
      "length",
      "natlist_ind",
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Dependencies":[
      "length",
      "app",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros; induction lst1;\n    [reflexivity | simpl; rewrite IHlst1; reflexivity].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_length' : forall (X : Type) (lst1 lst2 : list X),\n    length (lst1 ++ lst2) = (length lst1) + (length lst2).",
    "Dependencies":[
      "length",
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros; induction lst1;\n    [idtac | simpl; rewrite IHlst1];\n    reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma re_opt_e_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt_e re.",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "exp_match_ind",
      "MStarApp",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt_e"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re s M.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];\n\n    simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re1;\n    try (apply MApp; [apply IH1 | apply IH2]).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Hmatch1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStarApp; [apply IH1 | apply IH2].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"repeat (try (left; reflexivity); right).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"repeat (left; reflexivity).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"repeat (right; try (left; reflexivity)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev100: ev 100.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint re_opt {T:Type} (re: reg_exp T) : reg_exp T :=\n  match re with\n  | App _ EmptySet => EmptySet\n  | App EmptyStr re2 => re_opt re2\n  | App re1 EmptyStr => re_opt re1\n  | App re1 re2 => App (re_opt re1) (re_opt re2)\n  | Union EmptySet re2 => re_opt re2\n  | Union re1 EmptySet => re_opt re1\n  | Union re1 re2 => Union (re_opt re1) (re_opt re2)\n  | Star EmptySet => EmptyStr\n  | Star EmptyStr => EmptyStr\n  | Star re => Star (re_opt re)\n  | EmptySet => EmptySet\n  | EmptyStr => EmptyStr\n  | Char x => Char x\n  end.",
    "Dependencies":[
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma re_opt_match : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.",
    "Dependencies":[
      "app_nil_r",
      "app",
      "cons",
      "nil",
      "list",
      "star_app",
      "MStar1",
      "exp_match_ind",
      "MStar0",
      "MUnionR",
      "MUnionL",
      "MApp",
      "MChar",
      "MEmpty",
      "exp_match",
      "Star",
      "Union",
      "App",
      "Char",
      "EmptyStr",
      "EmptySet",
      "reg_exp",
      "re_opt"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re s M.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction M\n    as [| x'\n        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n        | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MChar.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite app_nil_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite app_nil_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite app_nil_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite app_nil_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MApp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionL.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MUnionR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct re.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MEmpty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply star_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply star_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply star_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply star_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply MStar1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma re_opt_match' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.",
    "Dependencies":[
      "list",
      "exp_match",
      "reg_exp",
      "re_opt"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_re_opt : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem hyp_name : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem no_hyp_name : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem false_assumed : False -> 0 = 1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem false_assumed' : False -> 0 = 1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"contradiction.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem contras : forall (P : Prop), P -> ~P -> 0 = 1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P HP HNP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"exfalso.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HNP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem contras' : forall (P : Prop), P -> ~P -> 0 = 1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"contradiction.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem many_eq : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p].",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o p Hnm Hop.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hop.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem many_eq' : forall (n m o p : nat),\n  n = m ->\n  o = p ->\n  [n; o] = [m; p].",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"subst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_0 : ev 0.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_0 : ev 0.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_0 : ev 0.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS : forall n : nat, ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS : forall n : nat, ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS : forall n : nat, ev n -> ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example constructor_example: forall (n:nat),\n    ev (n + n).",
    "Dependencies":[
      "add_comm",
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n; simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"constructor.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"constructor.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.micromega.Lia.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lia_succeed1 : forall (n : nat),\n  n > 0 -> n * 2 > n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lia_succeed2 : forall (n m : nat),\n    n * m = m * n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.setoid_ring.Ring.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mult_comm : forall (n m : nat),\n    n * m = m * n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"ring.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eq_example1 :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eq_example1' :\n  forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A) (y : B),\n    y = f x -> g y = g (f x).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"congruence.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eq_example2 : forall (n m o p : nat),\n    n = m ->\n    o = p ->\n    (n, o) = (m, p).",
    "Dependencies":[
      "pair",
      "prod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"congruence.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eq_example3 : forall (X : Type) (h : X) (t : list X),\n    [] <> h :: t.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"congruence.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem intuition_succeed1 : forall (P : Prop),\n    P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intuition.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem intuition_succeed2 : forall (P Q : Prop),\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intuition.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem intuition_simplify2 : forall (x y : nat) (P Q : nat -> Prop),\n  x = y \/\\ (P x -> Q x) \/\\ P x -> Q y.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail congruence.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intuition.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"congruence.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem intuition_simplify2' : forall (x y : nat) (P Q : nat -> Prop),\n  x = y \/\\ (P x -> Q x) \/\\ P x -> Q y.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intuition congruence.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_id_exercise_from_basics : forall n m o : nat,\n  n = m -> m = o -> n + m = m + o.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc_from_induction : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem S_injective_from_tactics : forall (n m : nat),\n  S n = S m ->\n  n = m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem or_distributes_over_and_from_logic : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q R H1 H2 H3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto 6.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_5 : 2 = 2.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_5 : 2 = 2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"info_auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto using le_antisym.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Create HintDb le_db.",
    "Dependencies":null
  },
  {
    "Type":"Hint",
    "Chunk":"Hint Resolve le_antisym : le_db.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6' : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto with le_db.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition is_fortytwo x := (x = 42).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition is_fortytwo x := (x = 42).",
    "Dependencies":null
  },
  {
    "Type":"Hint",
    "Chunk":"Hint Unfold is_fortytwo : le_db.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"info_auto with le_db.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_8 : forall (n m : nat),\n    n + m = m + n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"info_auto with arith.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma re_opt_match'' : forall T (re: reg_exp T) s,\n  s =~ re -> s =~ re_opt re.",
    "Dependencies":[
      "list",
      "exp_match",
      "reg_exp",
      "re_opt"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_re_opt_match'' : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Import",
    "Chunk":"Import Pumping.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma weak_pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_pumping_redux : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        length s1 + length s2 <= pumping_constant re \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma pumping : forall T (re : reg_exp T) s,\n    s =~ re ->\n    pumping_constant re <= length s ->\n    exists s1 s2 s3,\n      s = s1 ++ s2 ++ s3 \/\\\n        s2 <> [] \/\\\n        length s1 + length s2 <= pumping_constant re \/\\\n        forall m, s1 ++ napp m s2 ++ s3 =~ re.",
    "Dependencies":[
      "napp",
      "pumping_constant",
      "length",
      "app",
      "nil",
      "list",
      "exp_match",
      "reg_exp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros T re s Hmatch.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | s2 re1 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ];\n    simpl; try lia;\n    intros Hlen.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_pumping_redux_strong : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_example1:  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.",
    "Dependencies":[
      "mul_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a b c d H1 H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Nat.le_trans with (b + b * c).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mul_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_example1':  forall a b c d,\n    a <= b + b * c  ->\n    (1 + c) * b <= d ->\n    a <= d.",
    "Dependencies":[
      "mul_comm"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a b c d H1 H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"eapply Nat.le_trans.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite mul_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example trans_example2:  forall a b c d,\n    a <= b + b * c  ->\n    b + b * c <= d ->\n    a <= d.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a b c d H1 H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"info_eauto using Nat.le_trans.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac simpl_and_try tac := simpl; try tac.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example sat_ex1 : 1 + 1 = 2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl_and_try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example sat_ex2 : forall (n : nat), 1 - 1 + n + 1 = 1 + n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl_and_try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b.",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac destructpf x :=\n  destruct x; try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0' : forall n : nat,\n    (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_1_neq_0' : forall n : nat,\n    (n + 1) =? 0 = false.",
    "Dependencies":[
      "eqb",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n; destructpf n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem negb_involutive' : forall b : bool,\n  negb (negb b) = b.",
    "Dependencies":[
      "negb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b; destructpf b.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_commutative' : forall b c, andb b c = andb c b.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b c; destructpf b; destructpf c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Dependencies":[
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb3_exchange :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Dependencies":[
      "andb",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_true_elim2 : forall b c : bool,\n  andb b c = true -> c = true.",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros b c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct b eqn:Eb.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c eqn:Ec.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb_true_elim2' : forall b c : bool,\n    andb b c = true -> c = true.",
    "Dependencies":[
      "andb",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem andb3_exchange' :\n  forall b c d, andb (andb b c) d = andb (andb b d) c.",
    "Dependencies":[
      "andb",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Dependencies":[
      "app",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Dependencies":[
      "app",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros X lst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction lst as [ | h t IHt].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHt.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex1 : True.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ |- True ] => apply I\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex2 : True \/\\ True.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ |- True ] => apply I\n  | [ |- True \/\\ True ] => split; apply I\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex2' : True \/\\ True.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ |- True ] => idtac \"branch 1\"; apply I\n  | [ |- True \/\\ True ] => idtac \"branch 2\"; split; apply I\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Definition redundant_match (n : nat) : nat :=\n  match n with\n  | x => x\n  | 0 => 1\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex2'' : True \/\\ True.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ |- _ ] => idtac \"branch 1\"; apply I\n  | [ |- True \/\\ True ] => idtac \"branch 2\"; split; apply I\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex3 : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ H : _ |- _ ] => apply H\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex3' : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ H : _ |- _ ] => idtac H; apply H\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex4 : forall (P Q : Prop), P -> Q -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HP HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ H : _ |- _ ] => idtac H; apply H\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem match_ex5 : forall (P Q : Prop), P -> Q -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HP HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"match goal with\n  | [ H : ?X |- ?X ] => idtac H; apply H\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Definition dup_first_two_elts (lst : list nat) :=\n  match lst with\n  | x :: x :: _ => true\n  | _ => false\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros X lst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction lst as [ | h t IHt].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHt.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac simple_induction t :=\n  induction t; simpl;\n  try match goal with\n      | [H : _ = _ |- _] => rewrite H\n      end;\n  reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem app_nil_r'' : forall (X : Type) (lst : list X),\n    lst ++ [] = lst.",
    "Dependencies":[
      "app",
      "list_ind",
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros X lst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simple_induction lst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc'' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc'' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc''' : forall n m p : nat,\n    n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simple_induction n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_n_Sm : forall n m : nat,\n    S (n + m) = n + (S m).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_n_Sm : forall n m : nat,\n    S (n + m) = n + (S m).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_n_Sm' : forall n m : nat,\n    S (n + m) = n + (S m).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simple_induction n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac imp_intuition :=\n  repeat match goal with\n         | [ H : ?P |- ?P ] => apply H\n         | [ |- forall _, _ ] => intro\n         | [ H1 : ?P -> ?Q, H2 : ?P |- _ ] => apply H1 in H2\n         end.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example imp1 : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"imp_intuition.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example imp2 : forall (P Q : Prop), P -> (P -> Q) -> Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"imp_intuition.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example imp3 : forall (P Q R : Prop), (P -> Q -> R) -> (Q -> P -> R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"imp_intuition.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive nor (P Q : Prop) :=\n| stroke : ~P -> ~Q -> nor P Q.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nor_not_or : forall (P Q : Prop),\n    nor P Q -> ~ (P \\\/ Q).",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nor_comm : forall (P Q : Prop),\n    nor P Q <-> nor Q P.",
    "Dependencies":[
      "stroke",
      "nor"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply stroke; assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply stroke; assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nor_not : forall (P : Prop),\n    nor P P <-> ~P.",
    "Dependencies":[
      "stroke",
      "nor"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply stroke; assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nor_comm' : forall (P Q : Prop),\n    nor P Q <-> nor Q P.",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nor_not' : forall (P : Prop),\n    nor P P <-> ~P.",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem nor_not_and' : forall (P Q : Prop),\n    nor P Q -> ~ (P \/\\ Q).",
    "Dependencies":[
      "nor"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_nor_intuition : option (nat*string) := None.",
    "Dependencies":[
      "None",
      "option",
      "prod",
      "string"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End AltAuto.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_AltAuto.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_AltAutoTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.AltAuto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Check.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Check.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.AltAuto.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions andb_eq_orb.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions add_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions nonzeros_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions add_assoc'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ev100.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_id_exercise_from_basics.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions add_assoc_from_induction.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions S_injective_from_tactics.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions or_distributes_over_and_from_logic.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions andb3_exchange.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions andb_true_elim2'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions andb3_exchange'.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_AltAutoTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Maps.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Maps.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.Arith.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Bool.Bool.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Logic.FunctionalExtensionality.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Lists.List.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import ListNotations.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Default Goal Selector \"!\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Locate \"+\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Init.Nat.add.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check String.eqb_refl :\n  forall x : string, (x =? x)%string = true.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check String.eqb_eq :\n  forall n m : string, (n =? m)%string = true <-> n = m.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check String.eqb_neq :\n  forall n m : string, (n =? m)%string = false <-> n <> m.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check String.eqb_spec :\n  forall x y : string, reflect (x = y) (String.eqb x y).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition total_map (A : Type) := string -> A.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition t_empty {A : Type} (v : A) : total_map A :=\n  (fun _ => v).",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'.",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition examplemap :=\n  t_update (t_update (t_empty false) \"foo\" true)\n           \"bar\" true.",
    "Dependencies":[
      "t_update",
      "t_empty"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example example_empty := (_ !-> false).",
    "Dependencies":[
      "t_empty",
      "total_map"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x '!->' v ';' m\" := (t_update m x v)\n                              (at level 100, v at next level, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition examplemap' :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _     !-> false\n  ).",
    "Dependencies":[
      "t_update",
      "t_empty"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example update_example1 : examplemap' \"baz\" = false.",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example update_example2 : examplemap' \"foo\" = true.",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example update_example3 : examplemap' \"quux\" = false.",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example update_example4 : examplemap' \"bar\" = true.",
    "Dependencies":[
      "examplemap'"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma t_apply_empty : forall (A : Type) (x : string) (v : A),\n  (_ !-> v) x = v.",
    "Dependencies":[
      "t_empty"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem t_update_neq : forall (A : Type) (m : total_map A) x1 x2 v,\n  x1 <> x2 ->\n  (x1 !-> v ; m) x2 = m x2.",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,\n  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem t_update_same : forall (A : Type) (m : total_map A) x,\n  (x !-> m x ; m) = m.",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem t_update_permute : forall (A : Type) (m : total_map A)\n                                  v1 v2 x1 x2,\n  x2 <> x1 ->\n  (x1 !-> v1 ; x2 !-> v2 ; m)\n  =\n  (x2 !-> v2 ; x1 !-> v1 ; m).",
    "Dependencies":[
      "t_update",
      "total_map"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition partial_map (A : Type) := total_map (option A).",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition partial_map (A : Type) := total_map (option A).",
    "Dependencies":[
      "id"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition empty {A : Type} : partial_map A :=\n  t_empty None.",
    "Dependencies":[
      "partial_map",
      "t_empty"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition empty {A : Type} : partial_map A :=\n  t_empty None.",
    "Dependencies":[
      "id"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m).",
    "Dependencies":[
      "partial_map",
      "t_update"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition update {A : Type} (m : partial_map A)\n           (x : string) (v : A) :=\n  (x !-> Some v ; m).",
    "Dependencies":[
      "record",
      "partial_map",
      "id"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x '|->' v ';' m\" := (update m x v)\n  (at level 100, v at next level, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x '|->' v\" := (update empty x v)\n  (at level 100).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition examplepmap :=\n  (\"Church\" |-> true ; \"Turing\" |-> false).",
    "Dependencies":[
      "update",
      "empty"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma apply_empty : forall (A : Type) (x : string),\n  @empty A x = None.",
    "Dependencies":[
      "empty",
      "t_apply_empty",
      "t_empty"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold empty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite t_apply_empty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v.",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_eq",
      "t_update"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma update_eq : forall (A : Type) (m : partial_map A) x v,\n  (x |-> v ; m) x = Some v.",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "Some",
      "natoption",
      "id"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold update.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite t_update_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"#[global] Hint Resolve update_eq : core.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,\n  x2 <> x1 ->\n  (x2 |-> v ; m) x1 = m x1.",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_neq",
      "t_update"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,\n  x2 <> x1 ->\n  (x2 |-> v ; m) x1 = m x1.",
    "Dependencies":[
      "find",
      "update",
      "partial_map",
      "natoption",
      "eqb_id",
      "id",
      "false",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A m x1 x2 v H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold update.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite t_update_neq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,\n  (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m).",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_shadow",
      "t_update"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A m x v1 v2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold update.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite t_update_shadow.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_same : forall (A : Type) (m : partial_map A) x v,\n  m x = Some v ->\n  (x |-> v ; m) = m.",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_same",
      "t_update"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A m x v H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold update.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply t_update_same.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem update_permute : forall (A : Type) (m : partial_map A)\n                                x1 x2 v1 v2,\n  x2 <> x1 ->\n  (x1 |-> v1 ; x2 |-> v2 ; m) = (x2 |-> v2 ; x1 |-> v1 ; m).",
    "Dependencies":[
      "update",
      "partial_map",
      "t_update_permute"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A m x1 x2 v1 v2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold update.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply t_update_permute.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition includedin {A : Type} (m m' : partial_map A) :=\n  forall x v, m x = Some v -> m' x = Some v.",
    "Dependencies":[
      "partial_map"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma includedin_update : forall (A : Type) (m m' : partial_map A)\n                                 (x : string) (vx : A),\n  includedin m m' ->\n  includedin (x |-> vx ; m) (x |-> vx ; m').",
    "Dependencies":[
      "includedin",
      "update_neq",
      "update_eq",
      "update",
      "partial_map"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold includedin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros A m m' x vx H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros y vy.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (eqb_spec x y) as [Hxy | Hxy].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Hxy.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite update_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite update_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intro H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite update_neq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite update_neq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hxy.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hxy.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Maps.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Maps.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Imp.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Imp.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Bool.Bool.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Corelib.Init.Nat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.Arith.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.EqNat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Nat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.micromega.Lia.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Lists.List.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import ListNotations.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Maps.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Default Goal Selector \"!\".",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export AExp.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end.",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint aeval (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | APlus  a1 a2 => (aeval a1) + (aeval a2)\n  | AMinus a1 a2 => (aeval a1) - (aeval a2)\n  | AMult  a1 a2 => (aeval a1) * (aeval a2)\n  end.",
    "Dependencies":[
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_aeval1:\n  aeval (APlus (ANum 2) (ANum 2)) = 4.",
    "Dependencies":[
      "aeval",
      "APlus",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end.",
    "Dependencies":[
      "aeval",
      "bexp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint beval (b : bexp) : bool :=\n  match b with\n  | BTrue       => true\n  | BFalse      => false\n  | BEq a1 a2   => (aeval a1) =? (aeval a2)\n  | BNeq a1 a2  => negb ((aeval a1) =? (aeval a2))\n  | BLe a1 a2   => (aeval a1) <=? (aeval a2)\n  | BGt a1 a2   => negb ((aeval a1) <=? (aeval a2))\n  | BNot b1     => negb (beval b1)\n  | BAnd b1 b2  => andb (beval b1) (beval b2)\n  end.",
    "Dependencies":[
      "aeval",
      "bexp",
      "state"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint optimize_0plus (a:aexp) : aexp :=\n  match a with\n  | ANum n => ANum n\n  | APlus (ANum 0) e2 => optimize_0plus e2\n  | APlus  e1 e2 => APlus  (optimize_0plus e1) (optimize_0plus e2)\n  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)\n  | AMult  e1 e2 => AMult  (optimize_0plus e1) (optimize_0plus e2)\n  end.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example test_optimize_0plus:\n  optimize_0plus (APlus (ANum 2)\n                        (APlus (ANum 0)\n                               (APlus (ANum 0) (ANum 1))))\n  = APlus (ANum 2) (ANum 1).",
    "Dependencies":[
      "optimize_0plus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem optimize_0plus_sound: forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "Dependencies":[
      "optimize_0plus",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction a.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct a1 eqn:Ea1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n eqn:En.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly1 : forall (P : Prop), P -> P.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall ae, aeval ae = aeval ae.",
    "Dependencies":[
      "aeval",
      "aexp"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall ae, aeval ae = aeval ae.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem silly2 : forall ae, aeval ae = aeval ae.",
    "Dependencies":[
      "cons",
      "nil",
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma foo : forall n, 0 <=? n = true.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma foo : forall n, 0 <=? n = true.",
    "Dependencies":[
      "true",
      "bool"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma foo : forall n, 0 <=? n = true.",
    "Dependencies":[
      "blue",
      "rgb"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma foo : forall n, 0 <=? n = true.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma foo' : forall n, 0 <=? n = true.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma foo' : forall n, 0 <=? n = true.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n;\n\n  simpl;\n\n  reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem optimize_0plus_sound': forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "Dependencies":[
      "optimize_0plus",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction a;\n\n    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct a1 eqn:Ea1;\n\n      try (simpl; simpl in IHa1; rewrite IHa1;\n           rewrite IHa2; reflexivity).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n eqn:En;\n      simpl; rewrite IHa2; reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem optimize_0plus_sound'': forall a,\n  aeval (optimize_0plus a) = aeval a.",
    "Dependencies":[
      "optimize_0plus",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros a.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction a;\n\n    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);\n\n    try reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;\n                      rewrite IHa2; reflexivity).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct n;\n      simpl; rewrite IHa2; reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"repeat (try (left; reflexivity); right).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].",
    "Dependencies":[
      "cons",
      "nil",
      "In"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"repeat simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"repeat (left; reflexivity).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"repeat (right; try (left; reflexivity)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem repeat_loop : forall (m n : nat),\n  m + n = n + m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint optimize_0plus_b (b : bexp) : bexp\n  .",
    "Dependencies":[
      "bexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example optimize_0plus_b_test1:\n  optimize_0plus_b (BNot (BGt (APlus (ANum 0) (ANum 4)) (ANum 8))) =\n                   (BNot (BGt (ANum 4) (ANum 8))).",
    "Dependencies":[
      "optimize_0plus_b",
      "BNot",
      "BGt",
      "bexp",
      "APlus",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example optimize_0plus_b_test2:\n  optimize_0plus_b (BAnd (BLe (APlus (ANum 0) (ANum 4)) (ANum 5)) BTrue) =\n                   (BAnd (BLe (ANum 4) (ANum 5)) BTrue).",
    "Dependencies":[
      "optimize_0plus_b",
      "BAnd",
      "BLe",
      "BTrue",
      "bexp",
      "APlus",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem optimize_0plus_b_sound : forall b,\n  beval (optimize_0plus_b b) = beval b.",
    "Dependencies":[
      "optimize_0plus_b",
      "beval",
      "bexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac invert H :=\n  inversion H; subst; clear H.",
    "Dependencies":[
      "bw_white",
      "bw_black",
      "bw"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma invert_example1: forall {a b c: nat}, [a ;b] = [a;c] -> b = c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"invert H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example silly_presburger_example : forall m n o p,\n  m + n <= n + o \/\\ o + 3 = p + 3 ->\n  m <= p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example add_comm__lia : forall m n,\n    m + n = n + m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example add_assoc__lia : forall m n p,\n    m + (n + p) = m + n + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export aevalR_first_try.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      aevalR e1 n1 ->\n      aevalR e2 n2 ->\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Module",
    "Chunk":"Module Export HypothesisNames.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      aevalR (ANum n) n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (APlus e1 e2) (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMinus e1 e2) (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat)\n      (H1 : aevalR e1 n1)\n      (H2 : aevalR e2 n2) :\n      aevalR (AMult e1 e2) (n1 * n2).",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End HypothesisNames.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"e '==>' n\"\n         := (aevalR e n)\n            (at level 90, left associativity)\n         : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End aevalR_first_try.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation \"e '==>' n\" (at level 90, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (APlus e1 e2)  ==> (n1 + n2)\n  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMinus e1 e2) ==> (n1 - n2)\n  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :\n      (e1 ==> n1) ->\n      (e2 ==> n2) ->\n      (AMult e1 e2)  ==> (n1 * n2)\n\n  where \"e '==>' n\" := (aevalR e n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_beval_rules : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem aevalR_iff_aeval : forall a n,\n  (a ==> n) <-> aeval a = n.",
    "Dependencies":[
      "aevalR_ind",
      "E_AMult",
      "E_AMinus",
      "E_APlus",
      "E_ANum",
      "aevalR",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction H; simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHaevalR1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHaevalR2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHaevalR1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHaevalR2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHaevalR1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite IHaevalR2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction a;\n       simpl; intros; subst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_ANum.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_APlus.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_AMinus.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_AMult.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHa1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHa2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem aevalR_iff_aeval' : forall a n,\n  (a ==> n) <-> aeval a = n.",
    "Dependencies":[
      "aevalR_ind",
      "E_AMult",
      "E_AMinus",
      "E_APlus",
      "E_ANum",
      "aevalR",
      "aeval",
      "aexp_ind",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros H; induction H; subst; reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction a; simpl; intros; subst; constructor;\n       try apply IHa1; try apply IHa2; reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation \"e '==>b' b\" (at level 90, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bevalR: bexp -> bool -> Prop :=\n\nwhere \"e '==>b' b\" := (bevalR e b) : type_scope\n.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma bevalR_iff_beval : forall b bv,\n  b ==>b bv <-> beval b = bv.",
    "Dependencies":[
      "bevalR",
      "beval",
      "bexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End AExp.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export aevalR_division.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp)\n  | ADiv (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation \"e '==>' n\"\n                  (at level 90, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (n2 > 0) ->\n      (mult n2 n3 = n1) -> (ADiv a1 a2) ==> n3\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End aevalR_division.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export aevalR_extended.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation \"e '==>' n\" (at level 90, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | AAny\n  | ANum (n : nat)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "ADiv",
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "AAny",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aevalR : aexp -> nat -> Prop :=\n  | E_Any (n : nat) :\n      AAny ==> n\n  | E_ANum (n : nat) :\n      (ANum n) ==> n\n  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (APlus a1 a2) ==> (n1 + n2)\n  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMinus a1 a2) ==> (n1 - n2)\n  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :\n      (a1 ==> n1) -> (a2 ==> n2) -> (AMult a1 a2) ==> (n1 * n2)\n\nwhere \"a '==>' n\" := (aevalR a n) : type_scope.",
    "Dependencies":[
      "AMult",
      "AMinus",
      "APlus",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"End",
    "Chunk":"End aevalR_extended.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition state := total_map nat.",
    "Dependencies":[
      "total_map"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive aexp : Type :=\n  | ANum (n : nat)\n  | AId (x : string)\n  | APlus (a1 a2 : aexp)\n  | AMinus (a1 a2 : aexp)\n  | AMult (a1 a2 : aexp).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition W : string := \"W\".",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition X : string := \"X\".",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition Y : string := \"Y\".",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition Z : string := \"Z\".",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition Z : string := \"Z\".",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition Z : string := \"Z\".",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive bexp : Type :=\n  | BTrue\n  | BFalse\n  | BEq (a1 a2 : aexp)\n  | BNeq (a1 a2 : aexp)\n  | BLe (a1 a2 : aexp)\n  | BGt (a1 a2 : aexp)\n  | BNot (b : bexp)\n  | BAnd (b1 b2 : bexp).",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Coercion AId : string >-> aexp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Coercion ANum : nat >-> aexp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Coercion ANum : nat >-> aexp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Coercion ANum : nat >-> aexp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Coercion ANum : nat >-> aexp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Declare Custom Entry com.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Declare Scope com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Declare Custom Entry com_aux.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"<{ e }>\" := e (e custom com_aux) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"e\" := e (in custom com_aux at level 0, e custom com) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"( x )\" := x (in custom com, x at level 99) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x\" := x (in custom com at level 0, x constr at level 0) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"f x .. y\" := (.. (f x) .. y)\n                  (in custom com at level 0, only parsing,\n                  f constr at level 0, x constr at level 9,\n                  y constr at level 9) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x + y\"   := (APlus x y) (in custom com at level 50, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x - y\"   := (AMinus x y) (in custom com at level 50, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x * y\"   := (AMult x y) (in custom com at level 40, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'true'\"  := true (at level 1).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'true'\"  := BTrue (in custom com at level 0).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'false'\" := false (at level 1).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'false'\" := BFalse (in custom com at level 0).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x <= y\"  := (BLe x y) (in custom com at level 70, no associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x > y\"   := (BGt x y) (in custom com at level 70, no associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x = y\"   := (BEq x y) (in custom com at level 70, no associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x <> y\"  := (BNeq x y) (in custom com at level 70, no associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x && y\"  := (BAnd x y) (in custom com at level 80, left associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'~' b\"   := (BNot b) (in custom com at level 75, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Open Scope com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition example_aexp : aexp := <{ 3 + (X * 2) }>.",
    "Dependencies":[
      "X",
      "AMult",
      "APlus",
      "AId",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition example_bexp : bexp := <{ true && ~(X <= 4) }>.",
    "Dependencies":[
      "BAnd",
      "BNot",
      "BLe",
      "BTrue",
      "bexp",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end.",
    "Dependencies":[
      "aexp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint aeval (st : state)\n               (a : aexp) : nat :=\n  match a with\n  | ANum n => n\n  | AId x => st x\n  | <{a1 + a2}> => (aeval st a1) + (aeval st a2)\n  | <{a1 - a2}> => (aeval st a1) - (aeval st a2)\n  | <{a1 * a2}> => (aeval st a1) * (aeval st a2)\n  end.",
    "Dependencies":[
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end.",
    "Dependencies":[
      "aeval",
      "bexp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint beval (st : state)\n               (b : bexp) : bool :=\n  match b with\n  | <{true}>      => true\n  | <{false}>     => false\n  | <{a1 = a2}>   => (aeval st a1) =? (aeval st a2)\n  | <{a1 <> a2}>  => negb ((aeval st a1) =? (aeval st a2))\n  | <{a1 <= a2}>  => (aeval st a1) <=? (aeval st a2)\n  | <{a1 > a2}>   => negb ((aeval st a1) <=? (aeval st a2))\n  | <{~ b1}>      => negb (beval st b1)\n  | <{b1 && b2}>  => andb (beval st b1) (beval st b2)\n  end.",
    "Dependencies":[
      "aeval",
      "bexp",
      "state"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition empty_st := (_ !-> 0).",
    "Dependencies":[
      "t_empty",
      "total_map"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x '!->' v\" := (x !-> v ; empty_st) (at level 100).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example aexp1 :\n    aeval (X !-> 5) <{ 3 + (X * 2) }>\n  = 13.",
    "Dependencies":[
      "t_update",
      "empty_st",
      "aeval",
      "X",
      "AMult",
      "APlus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example aexp2 :\n    aeval (X !-> 5 ; Y !-> 4) <{ Z + (X * Y) }>\n  = 20.",
    "Dependencies":[
      "t_update",
      "empty_st",
      "aeval",
      "Z",
      "Y",
      "X",
      "AMult",
      "APlus",
      "AId"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example bexp1 :\n    beval (X !-> 5) <{ true && ~(X <= 4) }>\n  = true.",
    "Dependencies":[
      "t_update",
      "empty_st",
      "beval",
      "BAnd",
      "BNot",
      "BLe",
      "BTrue",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90,\n            right associativity) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n           (in custom com at level 89, x at level 99,\n            y at level 99) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition fact_in_coq : com :=\n  <{ Z := X;\n     Y := 1;\n     while Z <> 0 do\n       Y := Y * Z;\n       Z := Z - 1\n     end }>.",
    "Dependencies":[
      "CWhile",
      "CSeq",
      "CAsgn",
      "com",
      "BNeq",
      "Z",
      "Y",
      "X",
      "AMult",
      "AMinus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Print fact_in_coq.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Unset Printing Notations.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print fact_in_coq.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Printing Notations.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print example_bexp.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Printing Coercions.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print example_bexp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print fact_in_coq.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Unset Printing Coercions.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Locate aexp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Locate \"&&\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Locate \";\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Locate \"while\".",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition plus2 : com :=\n  <{ X := X + 2 }>.",
    "Dependencies":[
      "CAsgn",
      "com",
      "X",
      "APlus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition XtimesYinZ : com :=\n  <{ Z := X * Y }>.",
    "Dependencies":[
      "CAsgn",
      "com",
      "Z",
      "Y",
      "X",
      "AMult",
      "AId"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition subtract_slowly_body : com :=\n  <{ Z := Z - 1 ;\n     X := X - 1 }>.",
    "Dependencies":[
      "CSeq",
      "CAsgn",
      "com",
      "Z",
      "X",
      "AMinus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition subtract_slowly : com :=\n  <{ while X <> 0 do\n       subtract_slowly_body\n     end }>.",
    "Dependencies":[
      "subtract_slowly_body",
      "CWhile",
      "com",
      "BNeq",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition subtract_3_from_5_slowly : com :=\n  <{ X := 3 ;\n     Z := 5 ;\n     subtract_slowly }>.",
    "Dependencies":[
      "subtract_slowly",
      "CSeq",
      "CAsgn",
      "com",
      "Z",
      "X",
      "ANum"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition loop : com :=\n  <{ while true do\n       skip\n     end }>.",
    "Dependencies":[
      "CWhile",
      "CSkip",
      "com",
      "BTrue"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ x := a }> =>\n        (x !-> (aeval st a) ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_fun_no_while st c1 in\n        ceval_fun_no_while st' c2\n    | <{ if b then c1 else c2 end}> =>\n        if (beval st b)\n          then ceval_fun_no_while st c1\n          else ceval_fun_no_while st c2\n    | <{ while b do c end }> =>\n        st\n  end.",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation\n         \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99,\n          st constr, st' constr at next level).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Dependencies":[
      "state",
      "SContinue",
      "CSkip"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a n x,\n      aeval st a = n ->\n      st =[ x := a ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Dependencies":[
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "t_update",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example ceval_example1:\n  empty_st =[\n     X := 2;\n     if (X <= 1)\n       then Y := 3\n       else Z := 4\n     end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Dependencies":[
      "t_update",
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Seq with (X !-> 2).",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Seq with (X !-> 2).",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Asgn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_IfFalse.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Asgn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example ceval_example2:\n  empty_st =[\n    X := 0;\n    Y := 1;\n    Z := 2\n  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).",
    "Dependencies":[
      "t_update",
      "ceval",
      "CSeq",
      "CAsgn",
      "empty_st",
      "Z",
      "Y",
      "X",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Printing Implicit.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check @ceval_example2.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition pup_to_n : com\n  .",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition pup_to_n : com\n  .",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem pup_to_2_ceval :\n  (X !-> 2) =[\n    pup_to_n\n  ]=> (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2).",
    "Dependencies":[
      "t_update",
      "pup_to_n",
      "ceval",
      "empty_st",
      "Y",
      "X"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n     st =[ c ]=> st1  ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction E1; intros st2 E2; inversion E2; subst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H1) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H3) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus2_spec : forall st n st',\n  st X = n ->\n  st =[ plus2 ]=> st' ->\n  st' X = n + 2.",
    "Dependencies":[
      "t_update_eq",
      "t_update",
      "ceval",
      "plus2",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "X",
      "APlus",
      "AId",
      "ANum",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros st n st' HX Heval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Heval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"subst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"clear Heval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply t_update_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_XtimesYinZ_spec : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem loop_never_stops : forall st st',\n  ~(st =[ loop ]=> st').",
    "Dependencies":[
      "ceval",
      "loop",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros st st' contra.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold loop in contra.",
    "Dependencies":[
      "CWhile",
      "CSkip",
      "com",
      "BTrue"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"remember <{ while true do skip end }> as loopdef\n           eqn:Heqloopdef.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint no_whiles (c : com) : bool :=\n  match c with\n  | <{ skip }> =>\n      true\n  | <{ _ := _ }> =>\n      true\n  | <{ c1 ; c2 }> =>\n      andb (no_whiles c1) (no_whiles c2)\n  | <{ if _ then ct else cf end }> =>\n      andb (no_whiles ct) (no_whiles cf)\n  | <{ while _ do _ end }>  =>\n      false\n  end.",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive no_whilesR: com -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem no_whiles_eqv:\n  forall c, no_whiles c = true <-> no_whilesR c.",
    "Dependencies":[
      "no_whilesR",
      "no_whiles",
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_no_whiles_terminating : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive sinstr : Type :=\n| SPush (n : nat)\n| SLoad (x : string)\n| SPlus\n| SMinus\n| SMult.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint s_execute (st : state) (stack : list nat)\n                   (prog : list sinstr)\n                 : list nat\n  .",
    "Dependencies":[
      "sinstr",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check s_execute.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example s_execute1 :\n     s_execute empty_st []\n       [SPush 5; SPush 3; SPush 1; SMinus]\n   = [2; 5].",
    "Dependencies":[
      "s_execute",
      "SMinus",
      "SPush",
      "sinstr",
      "empty_st"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example s_execute2 :\n     s_execute (X !-> 3) [3;4]\n       [SPush 4; SLoad X; SMult; SPlus]\n   = [15; 4].",
    "Dependencies":[
      "t_update",
      "s_execute",
      "SMult",
      "SPlus",
      "SLoad",
      "SPush",
      "sinstr",
      "empty_st",
      "X"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint s_compile (e : aexp) : list sinstr\n  .",
    "Dependencies":[
      "sinstr",
      "aexp"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example s_compile1 :\n  s_compile <{ X - (2 * Y) }>\n  = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].",
    "Dependencies":[
      "s_compile",
      "SMult",
      "SMinus",
      "SLoad",
      "SPush",
      "sinstr",
      "Y",
      "X",
      "AMult",
      "AMinus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem execute_app : forall st p1 p2 stack,\n  s_execute st stack (p1 ++ p2) = s_execute st (s_execute st stack p1) p2.",
    "Dependencies":[
      "s_execute",
      "sinstr",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma s_compile_correct_aux : forall st e stack,\n  s_execute st stack (s_compile e) = aeval st e :: stack.",
    "Dependencies":[
      "s_compile",
      "s_execute",
      "aeval",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem s_compile_correct : forall (st : state) (e : aexp),\n  s_execute st [] (s_compile e) = [ aeval st e ].",
    "Dependencies":[
      "s_compile",
      "s_execute",
      "aeval",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module BreakImp.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CBreak\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'break'\" := CBreak (in custom com at level 0).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99) : com_scope.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive result : Type :=\n  | SContinue\n  | SBreak.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation \"st '=[' c ']=>' st' '\/' s\"\n     (at level 40, c custom com at level 99, st' constr at next level).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st').",
    "Dependencies":[
      "state",
      "SContinue",
      "CSkip"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st').",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> result -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ CSkip ]=> st \/ SContinue\n\n  where \"st '=[' c ']=>' st' '\/' s\" := (ceval c st s st').",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem break_ignore : forall c st st' s,\n     st =[ break; c ]=> st' \/ s ->\n     st = st'.",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "CSeq",
      "CBreak",
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem while_continue : forall b c st st' s,\n  st =[ while b do c end ]=> st' \/ s ->\n  s = SContinue.",
    "Dependencies":[
      "bexp",
      "state",
      "ceval",
      "SContinue",
      "result",
      "CWhile",
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem while_stops_on_break : forall b c st st',\n  beval st b = true ->\n  st =[ c ]=> st' \/ SBreak ->\n  st =[ while b do c end ]=> st' \/ SContinue.",
    "Dependencies":[
      "beval",
      "bexp",
      "state",
      "ceval",
      "SBreak",
      "SContinue",
      "CWhile",
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem seq_continue : forall c1 c2 st st' st'',\n  st =[ c1 ]=> st' \/ SContinue ->\n  st' =[ c2 ]=> st'' \/ SContinue ->\n  st =[ c1 ; c2 ]=> st'' \/ SContinue.",
    "Dependencies":[
      "state",
      "ceval",
      "SContinue",
      "CSeq",
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem seq_stops_on_break : forall c1 c2 st st',\n  st =[ c1 ]=> st' \/ SBreak ->\n  st =[ c1 ; c2 ]=> st' \/ SBreak.",
    "Dependencies":[
      "state",
      "ceval",
      "SBreak",
      "CSeq",
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem while_break_true : forall b c st st',\n  st =[ while b do c end ]=> st' \/ SContinue ->\n  beval st' b = true ->\n  exists st'', st'' =[ c ]=> st' \/ SBreak.",
    "Dependencies":[
      "beval",
      "bexp",
      "state",
      "ceval",
      "SBreak",
      "SContinue",
      "CWhile",
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall (c:com) st st1 st2 s1 s2,\n     st =[ c ]=> st1 \/ s1 ->\n     st =[ c ]=> st2 \/ s2 ->\n     st1 = st2 \/\\ s1 = s2.",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End BreakImp.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Imp.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Imp.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Auto.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Auto.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.micromega.Lia.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Maps.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Imp.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H1) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H3) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHE1_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1 : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q R H1 H2 H3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_1' : forall (P Q R: Prop),\n  (P -> Q) -> (Q -> R) -> P -> R.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_2 : forall P Q R S T U : Prop,\n  (P -> Q) ->\n  (P -> R) ->\n  (T -> R) ->\n  (S -> T -> U) ->\n  ((P -> Q) -> (P -> S)) ->\n  T ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_3 : forall (P Q R S T U: Prop),\n  (P -> Q) ->\n  (Q -> R) ->\n  (R -> S) ->\n  (S -> T) ->\n  (T -> U) ->\n  P ->\n  U.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"debug auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto 6.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_4 : forall P Q R : Prop,\n  Q ->\n  (Q -> R) ->\n  P \\\/ (Q \/\\ R).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_5: 2 = 2.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_5: 2 = 2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"info_auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_5' : forall (P Q R S T U W: Prop),\n  (U -> T) ->\n  (W -> U) ->\n  (R -> S) ->\n  (S -> T) ->\n  (P -> R) ->\n  (U -> T) ->\n  P ->\n  T.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"info_auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma le_antisym : forall n m: nat, (n <= m \/\\ m <= n) -> n = m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6 : forall n m p : nat,\n  (n <= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto using le_antisym.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Hint",
    "Chunk":"Hint Resolve le_antisym : core.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_6' : forall n m p : nat,\n  (n<= p -> (n <= m \/\\ m <= n)) ->\n  n <= p ->\n  n = m.",
    "Dependencies":[
      "le_antisym"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition is_fortytwo x := (x = 42).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition is_fortytwo x := (x = 42).",
    "Dependencies":null
  },
  {
    "Type":"Hint",
    "Chunk":"Hint Unfold is_fortytwo : core.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example auto_example_7' : forall x,\n  (x <= 42 \/\\ 42 <= x) -> is_fortytwo x.",
    "Dependencies":[
      "is_fortytwo",
      "le_antisym"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step_more",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st2;\n    induction E1; intros st2 E2; inversion E2; subst;\n    auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H1) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H3) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic'_alt: forall c st st1 st2,\n  st =[ c ]=> st1 ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof with auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1;\n           intros st2 E2; inversion E2; subst...",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2;\n  generalize dependent st2;\n  induction E1;\n           intros st2 E2; inversion E2; subst...",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H1) in *...",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite H in H4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H3) in *...",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac rwd H1 H2 := rewrite H1 in H2; discriminate.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic'': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H1) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rwd H H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rwd H H5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rwd H H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rwd H H4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H3) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac find_rwd :=\n  match goal with\n    H1: ?E = true,\n    H2: ?E = false\n    |- _ => rwd H1 H2\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; try find_rwd; auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H1) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite (IHE1_1 st'0 H3) in *.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac find_eqn :=\n  match goal with\n    H1: forall x, ?P x -> ?L = ?R,\n    H2: ?P ?X\n    |- _ => rewrite (H1 X H2) in *\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic'''': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st2;\n  induction E1; intros st2 E2; inversion E2; subst; try find_rwd;\n    try find_eqn; auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Repeat.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive com : Type :=\n  | CSkip\n  | CAsgn (x : string) (a : aexp)\n  | CSeq (c1 c2 : com)\n  | CIf (b : bexp) (c1 c2 : com)\n  | CWhile (b : bexp) (c : com)\n  | CRepeat (c : com) (b : bexp).",
    "Dependencies":[
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'repeat' x 'until' y 'end'\" :=\n         (CRepeat x y)\n            (in custom com at level 0,\n             x at level 99, y at level 99).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'skip'\"  :=\n         CSkip (in custom com at level 0).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x := y\"  :=\n         (CAsgn x y)\n            (in custom com at level 0, x constr at level 0,\n             y at level 85, no associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x ; y\" :=\n         (CSeq x y)\n           (in custom com at level 90, right associativity).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'if' x 'then' y 'else' z 'end'\" :=\n         (CIf x y z)\n           (in custom com at level 89, x at level 99,\n            y at level 99, z at level 99).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'while' x 'do' y 'end'\" :=\n         (CWhile x y)\n            (in custom com at level 89, x at level 99, y at level 99).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Reserved Notation \"st '=[' c ']=>' st'\"\n         (at level 40, c custom com at level 99, st' constr at next level).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Dependencies":[
      "state",
      "SContinue",
      "CSkip"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ceval : com -> state -> state -> Prop :=\n  | E_Skip : forall st,\n      st =[ skip ]=> st\n  | E_Asgn  : forall st a1 n x,\n      aeval st a1 = n ->\n      st =[ x := a1 ]=> (x !-> n ; st)\n  | E_Seq : forall c1 c2 st st' st'',\n      st  =[ c1 ]=> st'  ->\n      st' =[ c2 ]=> st'' ->\n      st  =[ c1 ; c2 ]=> st''\n  | E_IfTrue : forall st st' b c1 c2,\n      beval st b = true ->\n      st =[ c1 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_IfFalse : forall st st' b c1 c2,\n      beval st b = false ->\n      st =[ c2 ]=> st' ->\n      st =[ if b then c1 else c2 end ]=> st'\n  | E_WhileFalse : forall b st c,\n      beval st b = false ->\n      st =[ while b do c end ]=> st\n  | E_WhileTrue : forall st st' st'' b c,\n      beval st b = true ->\n      st  =[ c ]=> st' ->\n      st' =[ while b do c end ]=> st'' ->\n      st  =[ while b do c end ]=> st''\n  | E_RepeatEnd : forall st st' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = true ->\n      st  =[ repeat c until b end ]=> st'\n  | E_RepeatLoop : forall st st' st'' b c,\n      st  =[ c ]=> st' ->\n      beval st' b = false ->\n      st' =[ repeat c until b end ]=> st'' ->\n      st  =[ repeat c until b end ]=> st''\n\n  where \"st =[ c ]=> st'\" := (ceval c st st').",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "state",
      "ceval",
      "result",
      "com"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic: forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st2;\n  induction E1;\n    intros st2 E2; inversion E2; subst; try find_rwd; try find_eqn; auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"find_rwd.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"find_rwd.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step_more",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic': forall c st st1 st2,\n  st =[ c ]=> st1  ->\n  st =[ c ]=> st2 ->\n  st1 = st2.",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 E1 E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st2;\n  induction E1;\n    intros st2 E2; inversion E2; subst; try find_eqn; try find_rwd; auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Repeat.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example ceval_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Dependencies":[
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "t_update",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example ceval_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Dependencies":[
      "t_update",
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Seq with (X !-> 2).",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Seq with (X !-> 2).",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Asgn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_IfFalse.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Asgn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example ceval'_example1:\n  empty_st =[\n    X := 2;\n    if (X <= 1)\n      then Y := 3\n      else Z := 4\n    end\n  ]=> (Z !-> 4 ; X !-> 2).",
    "Dependencies":[
      "E_IfFalse",
      "E_Seq",
      "E_Asgn",
      "ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "t_update",
      "empty_st",
      "aeval",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"eapply E_Seq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Asgn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_IfFalse.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Asgn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Hint",
    "Chunk":"Hint Constructors ceval : core.",
    "Dependencies":null
  },
  {
    "Type":"Hint",
    "Chunk":"Hint Transparent state total_map : core.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example eauto_example : exists s',\n  (Y !-> 1 ; X !-> 2) =[\n    if (X <= Y)\n      then Z := Y - X\n      else Y := X + Z\n    end\n  ]=> s'.",
    "Dependencies":[
      "E_IfFalse",
      "E_Asgn",
      "ceval",
      "CIf",
      "CAsgn",
      "t_update",
      "empty_st",
      "aeval",
      "BLe",
      "Z",
      "Y",
      "X",
      "AMinus",
      "APlus",
      "AId",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"info_eauto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma silly2_fixed :\n  forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HP HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct HP as [y HP'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"eapply HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma silly2_eassumption : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HP HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct HP as [y HP'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"eapply HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"eassumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma silly2_eauto : forall (P : nat -> nat -> Prop) (Q : nat -> Prop),\n  (exists y, P 42 y) ->\n  (forall x y : nat, P x y -> Q x) ->\n  Q 42.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HP HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct HP as [y HP'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"eauto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Auto.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Auto.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_AutoTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Auto.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Auto.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_AutoTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_BasicsTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Basics.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Basics.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_nandb4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_andb34.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_factorial2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_ltb3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_id_exercise.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions mult_n_1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions andb_true_elim2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions zero_nbeq_plus_1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions identity_fn_applied_twice.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.letter_comparison_Eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.test_grade_comparison1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.test_grade_comparison2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.test_grade_comparison3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.test_grade_comparison4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_letter_lowers.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_A_Plus.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_A_Natural.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_A_Minus.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_B_Plus.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_F_Natural.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_twice.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_thrice.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_F_Minus.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.lower_grade_lowers.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.no_penalty_for_mostly_on_time.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions LateDays.grade_lowered_once.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_bin_incr1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_bin_incr2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_bin_incr3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_bin_incr4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_bin_incr5.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_bin_incr6.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_BasicsTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Bib.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Bib.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Bib.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Bib.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_BibTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Bib.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Bib.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_BibTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ImpCEvalFun.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export ImpCEvalFun.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.micromega.Lia.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.Arith.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.PeanoNat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Nat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.EqNat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Imp LF.Maps.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint ceval_step1 (st : state) (c : com) : state :=\n  match c with\n    | <{ skip }> =>\n        st\n    | <{ l := a1 }> =>\n        (l !-> aeval st a1 ; st)\n    | <{ c1 ; c2 }> =>\n        let st' := ceval_step1 st c1 in\n        ceval_step1 st' c2\n    | <{ if b then c1 else c2 end }> =>\n        if (beval st b)\n          then ceval_step1 st c1\n          else ceval_step1 st c2\n    | <{ while b1 do c1 end }> =>\n        st\n  end.",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :=\n  match i with\n  | O => empty_st\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          st\n      | <{ l := a1 }> =>\n          (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          let st' := ceval_step2 st c1 i' in\n          ceval_step2 st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step2 st c1 i'\n            else ceval_step2 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then let st' := ceval_step2 st c1 i' in\n               ceval_step2 st' c i'\n          else st\n    end\n  end.",
    "Dependencies":[
      "t_update",
      "com",
      "empty_st",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint ceval_step3 (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          match (ceval_step3 st c1 i') with\n          | Some st' => ceval_step3 st' c2 i'\n          | None => None\n          end\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step3 st c1 i'\n            else ceval_step3 st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then match (ceval_step3 st c1 i') with\n               | Some st' => ceval_step3 st' c i'\n               | None => None\n               end\n          else Some st\n    end\n  end.",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'LETOPT' x <== e1 'IN' e2\"\n   := (match e1 with\n         | Some x => e2\n         | None => None\n       end)\n   (right associativity, at level 60).",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint ceval_step (st : state) (c : com) (i : nat)\n                    : option state :=\n  match i with\n  | O => None\n  | S i' =>\n    match c with\n      | <{ skip }> =>\n          Some st\n      | <{ l := a1 }> =>\n          Some (l !-> aeval st a1 ; st)\n      | <{ c1 ; c2 }> =>\n          LETOPT st' <== ceval_step st c1 i' IN\n          ceval_step st' c2 i'\n      | <{ if b then c1 else c2 end }> =>\n          if (beval st b)\n            then ceval_step st c1 i'\n            else ceval_step st c2 i'\n      | <{ while b1 do c1 end }> =>\n          if (beval st b1)\n          then LETOPT st' <== ceval_step st c1 i' IN\n               ceval_step st' c i'\n          else Some st\n    end\n  end.",
    "Dependencies":[
      "t_update",
      "com",
      "beval",
      "aeval",
      "state"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition test_ceval (st:state) (c:com) :=\n  match ceval_step st c 500 with\n  | None    => None\n  | Some st => Some (st X, st Y, st Z)\n  end.",
    "Dependencies":[
      "ceval_step",
      "com",
      "Z",
      "Y",
      "X",
      "state"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example example_test_ceval :\n     test_ceval empty_st\n\n     <{ X := 2;\n        if (X <= 1)\n        then Y := 3\n        else Z := 4\n        end }>\n\n     = Some (2, 0, 4).",
    "Dependencies":[
      "test_ceval",
      "CIf",
      "CSeq",
      "CAsgn",
      "empty_st",
      "BLe",
      "Z",
      "Y",
      "X",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition pup_to_n : com\n  .",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition pup_to_n : com\n  .",
    "Dependencies":[
      "com"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example pup_to_n_1 :\n  test_ceval (X !-> 5) pup_to_n\n  = Some (0, 15, 0).",
    "Dependencies":[
      "t_update",
      "pup_to_n",
      "test_ceval",
      "empty_st",
      "X"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_step__ceval: forall c st st',\n      (exists i, ceval_step st c i = Some st') ->\n      st =[ c ]=> st'.",
    "Dependencies":[
      "t_update",
      "ceval_step",
      "E_WhileTrue",
      "E_WhileFalse",
      "E_IfFalse",
      "E_IfTrue",
      "E_Seq",
      "E_Asgn",
      "E_Skip",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H as [i E].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"clear H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent st.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"generalize dependent c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction i as [| i' ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c;\n           simpl in H; inversion H; subst; clear H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Skip.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Asgn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (ceval_step st c1 i') eqn:Heqr1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Seq with s.",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_Seq with s.",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHi'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Heqr1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHi'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (beval st b) eqn:Heqr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_IfTrue.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Heqr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHi'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_IfFalse.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Heqr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHi'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (beval st b) eqn :Heqr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (ceval_step st c i') eqn:Heqr1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_WhileTrue with s.",
    "Dependencies":[
      "t_update",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_WhileTrue with s.",
    "Dependencies":[
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Heqr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHi'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Heqr1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHi'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"injection H1 as H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply E_WhileFalse.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Heqr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition manual_grade_for_ceval_step__ceval_inf : option (nat*string) := None.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_step_more: forall i1 i2 st st' c,\n  i1 <= i2 ->\n  ceval_step st c i1 = Some st' ->\n  ceval_step st c i2 = Some st'.",
    "Dependencies":[
      "t_update",
      "ceval_step",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction i1 as [|i1']; intros i2 st st' c Hle Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct i2 as [|i2'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Hle.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (Hle': i1' <= i2') by lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct c.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (ceval_step st c1 i1') eqn:Heqst1'o.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IHi1' i2') in Heqst1'o; try assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite Heqst1'o.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IHi1' i2') in Hceval; try assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (beval st b); apply (IHi1' i2') in Hceval;\n        assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (beval st b); try assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct (ceval_step st c i1') eqn: Heqst1'o.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IHi1' i2') in Heqst1'o; try assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> Heqst1'o.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (IHi1' i2') in Hceval; try assumption.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"*",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate Hceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval__ceval_step: forall c st st',\n      st =[ c ]=> st' ->\n      exists i, ceval_step st c i = Some st'.",
    "Dependencies":[
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' Hce.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st' Hce.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction Hce.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_and_ceval_step_coincide: forall c st st',\n      st =[ c ]=> st'\n  <-> exists i, ceval_step st c i = Some st'.",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step__ceval",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ceval__ceval_step.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ceval_step__ceval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Dependencies":[
      "t_update",
      "ceval_ind",
      "ceval",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Dependencies":[
      "ceval__ceval_step",
      "ceval_step_more",
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ceval_deterministic' : forall c st st1 st2,\n     st =[ c ]=> st1 ->\n     st =[ c ]=> st2 ->\n     st1 = st2.",
    "Dependencies":[
      "ceval_ind",
      "ceval",
      "CRepeat",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "t_update",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 He1 He2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros c st st1 st2 He1 He2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ceval__ceval_step in He1.",
    "Dependencies":[
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply ceval__ceval_step in He2.",
    "Dependencies":[
      "ceval_step",
      "ceval",
      "com",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"inversion He1 as [i1 E1].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion He2 as [i2 E2].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ceval_step_more with (i2 := i1 + i2) in E1.",
    "Dependencies":[
      "t_update",
      "ceval_step",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply ceval_step_more with (i2 := i1 + i2) in E2.",
    "Dependencies":[
      "t_update",
      "ceval_step",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "beval",
      "aeval",
      "bexp",
      "aexp",
      "state"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite E1 in E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion E2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"lia.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End ImpCEvalFun.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ImpCEvalFun.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ImpParser.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export ImpParser.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Strings.Ascii.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.Arith.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Corelib.Init.Nat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.EqNat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Lists.List.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import ListNotations.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Maps LF.Imp.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition isWhite (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n  orb (orb (n =? 32)\n           (n =? 9))\n      (orb (n =? 10)\n           (n =? 13)).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x '<=?' y\" := (x <=? y)\n  (at level 70, no associativity) : nat_scope.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition isLowerAlpha (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n    andb (97 <=? n) (n <=? 122).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition isAlpha (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n    orb (andb (65 <=? n) (n <=? 90))\n        (andb (97 <=? n) (n <=? 122)).",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition isDigit (c : ascii) : bool :=\n  let n := nat_of_ascii c in\n     andb (48 <=? n) (n <=? 57).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive chartype := white | alpha | digit | other.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition classifyChar (c : ascii) : chartype :=\n  if isWhite c then\n    white\n  else if isAlpha c then\n    alpha\n  else if isDigit c then\n    digit\n  else\n    other.",
    "Dependencies":[
      "other",
      "digit",
      "alpha",
      "white",
      "chartype",
      "isDigit",
      "isAlpha",
      "isWhite"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint list_of_string (s : string) : list ascii :=\n  match s with\n  | EmptyString => []\n  | String c s => c :: (list_of_string s)\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition string_of_list (xs : list ascii) : string :=\n  fold_right String EmptyString xs.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition token := string.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint tokenize_helper (cls : chartype) (acc xs : list ascii)\n                       : list (list ascii) :=\n  let tk := match acc with [] => [] | _::_ => [rev acc] end in\n  match xs with\n  | [] => tk\n  | (x::xs') =>\n    match cls, classifyChar x, x with\n    | _, _, \"(\"      =>\n      tk ++ [\"(\"]::(tokenize_helper other [] xs')\n    | _, _, \")\"      =>\n      tk ++ [\")\"]::(tokenize_helper other [] xs')\n    | _, white, _    =>\n      tk ++ (tokenize_helper white [] xs')\n    | alpha,alpha,x  =>\n      tokenize_helper alpha (x::acc) xs'\n    | digit,digit,x  =>\n      tokenize_helper digit (x::acc) xs'\n    | other,other,x  =>\n      tokenize_helper other (x::acc) xs'\n    | _,tp,x         =>\n      tk ++ (tokenize_helper tp [x] xs')\n    end\n  end %char.",
    "Dependencies":[
      "classifyChar",
      "other",
      "digit",
      "alpha",
      "white",
      "chartype"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition tokenize (s : string) : list string :=\n  map string_of_list (tokenize_helper white [] (list_of_string s)).",
    "Dependencies":[
      "tokenize_helper",
      "string_of_list",
      "list_of_string",
      "white"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example tokenize_ex1 :\n    tokenize \"abc12=3  223*(3+(a+c))\" %string\n  = [\"abc\"; \"12\"; \"=\"; \"3\"; \"223\";\n       \"*\"; \"(\"; \"3\"; \"+\"; \"(\";\n       \"a\"; \"+\"; \"c\"; \")\"; \")\"]%string.",
    "Dependencies":[
      "tokenize"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive optionE (X:Type) : Type :=\n  | SomeE (x : X)\n  | NoneE (s : string).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments SomeE {X}.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments NoneE {X}.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"' p <- e1 ;; e2\"\n   := (match e1 with\n       | SomeE p => e2\n       | NoneE err => NoneE err\n       end)\n   (right associativity, p pattern, at level 60, e1 at next level).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'TRY' e1 'OR' e2\"\n   := (\n    let result := e1 in\n    match result with\n       | SomeE _  => result\n       | NoneE _ => e2\n       end)\n   (right associativity,\n    at level 60, e1 at next level, e2 at next level).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Open Scope string_scope.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition parser (T : Type) :=\n  list token -> optionE (T * list token).",
    "Dependencies":[
      "optionE",
      "token"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint many_helper {T} (p : parser T) acc steps xs :=\n  match steps, p xs with\n  | 0, _ =>\n      NoneE \"Too many recursive calls\"\n  | _, NoneE _ =>\n      SomeE ((rev acc), xs)\n  | S steps', SomeE (t, xs') =>\n      many_helper p (t :: acc) steps' xs'\n  end.",
    "Dependencies":[
      "parser",
      "NoneE",
      "SomeE",
      "optionE",
      "token"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition many {T} (p : parser T) (steps : nat) : parser (list T) :=\n  many_helper p [] steps.",
    "Dependencies":[
      "many_helper",
      "parser"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition firstExpect {T} (t : token) (p : parser T)\n                     : parser T :=\n  fun xs => match xs with\n            | x::xs' =>\n              if string_dec x t\n              then p xs'\n              else NoneE (\"expected '\" ++ t ++ \"'.\")\n            | [] =>\n              NoneE (\"expected '\" ++ t ++ \"'.\")\n            end.",
    "Dependencies":[
      "parser",
      "NoneE",
      "optionE",
      "token"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition expect (t : token) : parser unit :=\n  firstExpect t (fun xs => SomeE (tt, xs)).",
    "Dependencies":[
      "firstExpect",
      "parser",
      "SomeE",
      "token"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition parseIdentifier (xs : list token)\n                         : optionE (string * list token) :=\nmatch xs with\n| [] => NoneE \"Expected identifier\"\n| x::xs' =>\n    if forallb isLowerAlpha (list_of_string x) then\n      SomeE (x, xs')\n    else\n      NoneE (\"Illegal identifier:'\" ++ x ++ \"'\")\nend.",
    "Dependencies":[
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "list_of_string",
      "isLowerAlpha"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition parseNumber (xs : list token)\n                     : optionE (nat * list token) :=\nmatch xs with\n| [] => NoneE \"Expected number\"\n| x::xs' =>\n    if forallb isDigit (list_of_string x) then\n      SomeE (fold_left\n               (fun n d =>\n                  10 * n + (nat_of_ascii d -\n                            nat_of_ascii \"0\"%char))\n               (list_of_string x)\n               0,\n             xs')\n    else\n      NoneE \"Expected number\"\nend.",
    "Dependencies":[
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "list_of_string",
      "isDigit"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint parsePrimaryExp (steps:nat)\n                         (xs : list token)\n                       : optionE (aexp * list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n      TRY ' (i, rest) <- parseIdentifier xs ;;\n          SomeE (AId i, rest)\n      OR\n      TRY ' (n, rest) <- parseNumber xs ;;\n          SomeE (ANum n, rest)\n      OR\n      ' (e, rest) <- firstExpect \"(\" (parseSumExp steps') xs ;;\n      ' (u, rest') <- expect \")\" rest ;;\n      SomeE (e,rest')\n  end\n\nwith parseProductExp (steps:nat)\n                     (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parsePrimaryExp steps' xs ;;\n    ' (es, rest') <- many (firstExpect \"*\" (parsePrimaryExp steps'))\n                          steps' rest ;;\n    SomeE (fold_left AMult es e, rest')\n  end\n\nwith parseSumExp (steps:nat) (xs : list token)  :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parseProductExp steps' xs ;;\n    ' (es, rest') <-\n        many (fun xs =>\n                TRY ' (e,rest') <-\n                    firstExpect \"+\"\n                                (parseProductExp steps') xs ;;\n                    SomeE ( (true, e), rest')\n                OR\n                ' (e, rest') <-\n                    firstExpect \"-\"\n                                (parseProductExp steps') xs ;;\n                SomeE ( (false, e), rest'))\n        steps' rest ;;\n      SomeE (fold_left (fun e0 term =>\n                          match term with\n                          | (true,  e) => APlus e0 e\n                          | (false, e) => AMinus e0 e\n                          end)\n                       es e,\n             rest')\n  end.",
    "Dependencies":[
      "parseNumber",
      "parseIdentifier",
      "expect",
      "firstExpect",
      "many",
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "AMult",
      "AMinus",
      "APlus",
      "AId",
      "ANum",
      "aexp"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition parseAExp := parseSumExp.",
    "Dependencies":[
      "parseSumExp",
      "optionE",
      "token",
      "aexp"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint parseAtomicExp (steps:nat)\n                        (xs : list token)  :=\nmatch steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n     TRY ' (u,rest) <- expect \"true\" xs ;;\n         SomeE (BTrue,rest)\n     OR\n     TRY ' (u,rest) <- expect \"false\" xs ;;\n         SomeE (BFalse,rest)\n     OR\n     TRY ' (e,rest) <- firstExpect \"~\"\n                                   (parseAtomicExp steps')\n                                   xs ;;\n         SomeE (BNot e, rest)\n     OR\n     TRY ' (e,rest) <- firstExpect \"(\"\n                                   (parseConjunctionExp steps')\n                                   xs ;;\n         ' (u,rest') <- expect \")\" rest ;;\n         SomeE (e, rest')\n     OR\n     ' (e, rest) <- parseProductExp steps' xs ;;\n     TRY ' (e', rest') <- firstExpect \"=\"\n                                  (parseAExp steps') rest ;;\n         SomeE (BEq e e', rest')\n     OR\n     TRY ' (e', rest') <- firstExpect \"<=\"\n                                      (parseAExp steps') rest ;;\n         SomeE (BLe e e', rest')\n     OR\n     NoneE \"Expected '=' or '<=' after arithmetic expression\"\nend\n\nwith parseConjunctionExp (steps:nat)\n                         (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (e, rest) <- parseAtomicExp steps' xs ;;\n    ' (es, rest') <- many (firstExpect \"&&\"\n               (parseAtomicExp steps'))\n            steps' rest ;;\n    SomeE (fold_left BAnd es e, rest')\n  end.",
    "Dependencies":[
      "parseAExp",
      "parseProductExp",
      "expect",
      "firstExpect",
      "many",
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "BAnd",
      "BNot",
      "BLe",
      "BEq",
      "BFalse",
      "BTrue",
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition parseBExp := parseConjunctionExp.",
    "Dependencies":[
      "parseConjunctionExp",
      "optionE",
      "token",
      "bexp"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check parseConjunctionExp.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition testParsing {X : Type}\n           (p : nat ->\n                list token ->\n                optionE (X * list token))\n           (s : string) :=\n  let t := tokenize s in\n  p 100 t.",
    "Dependencies":[
      "optionE",
      "tokenize",
      "token"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint parseSimpleCommand (steps:nat)\n                            (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    TRY ' (u, rest) <- expect \"skip\" xs ;;\n        SomeE (<{skip}>, rest)\n    OR\n    TRY ' (e,rest) <-\n            firstExpect \"if\"\n                        (parseBExp steps') xs ;;\n        ' (c,rest') <-\n            firstExpect \"then\"\n                        (parseSequencedCommand steps') rest ;;\n        ' (c',rest'') <-\n            firstExpect \"else\"\n                        (parseSequencedCommand steps') rest' ;;\n        ' (tt,rest''') <-\n            expect \"end\" rest'' ;;\n       SomeE(<{if e then c else c' end}>, rest''')\n    OR\n    TRY ' (e,rest) <-\n            firstExpect \"while\"\n                        (parseBExp steps') xs ;;\n        ' (c,rest') <-\n            firstExpect \"do\"\n                        (parseSequencedCommand steps') rest ;;\n        ' (u,rest'') <-\n            expect \"end\" rest' ;;\n        SomeE(<{while e do c end}>, rest'')\n    OR\n    TRY ' (i, rest) <- parseIdentifier xs ;;\n        ' (e, rest') <- firstExpect \":=\" (parseAExp steps') rest ;;\n        SomeE (<{i := e}>, rest')\n    OR\n        NoneE \"Expecting a command\"\nend\n\nwith parseSequencedCommand (steps:nat)\n                           (xs : list token) :=\n  match steps with\n  | 0 => NoneE \"Too many recursive calls\"\n  | S steps' =>\n    ' (c, rest) <- parseSimpleCommand steps' xs ;;\n    TRY ' (c', rest') <-\n            firstExpect \";\"\n                        (parseSequencedCommand steps') rest ;;\n        SomeE (<{c ; c'}>, rest')\n    OR\n    SomeE (c, rest)\n  end.",
    "Dependencies":[
      "parseBExp",
      "parseAExp",
      "parseIdentifier",
      "expect",
      "firstExpect",
      "NoneE",
      "SomeE",
      "optionE",
      "token",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "bexp",
      "aexp"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition bignumber := 1000.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition parse (str : string) : optionE com :=\n  let tokens := tokenize str in\n  match parseSequencedCommand bignumber tokens with\n  | SomeE (c, []) => SomeE c\n  | SomeE (_, t::_) => NoneE (\"Trailing tokens remaining: \" ++ t)\n  | NoneE err => NoneE err\n  end.",
    "Dependencies":[
      "bignumber",
      "parseSequencedCommand",
      "NoneE",
      "SomeE",
      "optionE",
      "tokenize",
      "token",
      "com"
    ]
  },
  {
    "Type":"Example",
    "Chunk":"Example eg1 : parse \"\n  if x = y + 1 + 2 - y * 6 + 3 then\n    x := x * 1;\n    y := 0\n  else\n    skip\n  end  \"\n=\n  SomeE <{\n      if (\"x\" = (\"y\" + 1 + 2 - \"y\" * 6 + 3)) then\n        \"x\" := \"x\" * 1;\n        \"y\" := 0\n      else\n        skip\n      end }>.",
    "Dependencies":[
      "parse",
      "SomeE",
      "optionE",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "BEq",
      "AMult",
      "AMinus",
      "APlus",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"cbv.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Example",
    "Chunk":"Example eg2 : parse \"\n  skip;\n  z:=x*y*(x*x);\n  while x=x do\n    if (z <= z*z) && ~(x = 2) then\n      x := z;\n      y := z\n    else\n      skip\n    end;\n    skip\n  end;\n  x:=z  \"\n=\n  SomeE <{\n      skip;\n      \"z\" := \"x\" * \"y\" * (\"x\" * \"x\");\n      while (\"x\" = \"x\") do\n        if (\"z\" <= \"z\" * \"z\") && ~(\"x\" = 2) then\n          \"x\" := \"z\";\n          \"y\" := \"z\"\n        else\n          skip\n        end;\n        skip\n      end;\n      \"x\" := \"z\" }>.",
    "Dependencies":[
      "parse",
      "SomeE",
      "optionE",
      "CWhile",
      "CIf",
      "CSeq",
      "CAsgn",
      "CSkip",
      "com",
      "BAnd",
      "BNot",
      "BLe",
      "BEq",
      "AMult",
      "AId",
      "ANum"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"cbv.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End ImpParser.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ImpParser.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Extraction.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Extraction.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extraction Language OCaml.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.Arith.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Corelib.Init.Nat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.Arith.EqNat.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ImpCEvalFun.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extraction \"imp1.ml\" ceval_step.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extract Inductive bool => \"bool\" [ \"true\" \"false\" ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extract Inductive nat => \"int\"\n  [ \"0\" \"(fun x -> x + 1)\" ]\n  \"(fun zero succ n ->\n      if n=0 then zero () else succ (n-1))\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extract Constant plus => \"( + )\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extract Constant mult => \"( * )\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extract Constant eqb => \"( = )\".",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extraction \"imp2.ml\" ceval_step.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Corelib.extraction.ExtrOcamlBasic.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Stdlib.extraction.ExtrOcamlString.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extract Inductive sumbool => \"bool\" [\"true\" \"false\"].",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Imp.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ImpParser.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Maps.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Extraction \"imp.ml\" empty_st ceval_step parse.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Extraction.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Extraction.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ExtractionTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Extraction.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Extraction.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ExtractionTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ImpCEvalFunTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ImpCEvalFun.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ImpCEvalFun.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ceval__ceval_step.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ImpCEvalFunTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ImpParserTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ImpParser.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ImpParser.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ImpParserTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ImpTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Imp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Imp.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions AExp.optimize_0plus_b_test1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions AExp.optimize_0plus_b_test2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions AExp.optimize_0plus_b_sound.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions AExp.bevalR_iff_beval.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ceval_example2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions loop_never_stops.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions no_whiles_eqv.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions s_execute1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions s_execute2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions s_compile1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions execute_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions s_compile_correct_aux.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions s_compile_correct.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions BreakImp.break_ignore.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions BreakImp.while_continue.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions BreakImp.while_stops_on_break.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions BreakImp.seq_continue.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions BreakImp.seq_stops_on_break.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ImpTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ProofObjects.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export ProofObjects.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.IndProp.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev : nat -> Prop :=\n  | ev_0                       : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_SS\n  : forall n,\n    ev n ->\n    ev (S (S n)).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4 : ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4 : ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print ev_4.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check (ev_SS 2 (ev_SS 0 ev_0))\n  : ev 4.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4': ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4': ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (ev_SS 2 (ev_SS 0 ev_0)).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_4'' : ev 4.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ev_4''' : ev 4 :=\n  ev_SS 2 (ev_SS 0 ev_0).",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Print ev_4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print ev_4'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print ev_4''.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print ev_4'''.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_8 : ev 8.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ev_8' : ev 8\n  .",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_plus4 : forall n, ev n -> ev (4 + n).",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H).",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H).",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_plus4'' : forall n : nat, ev n -> ev (4 + n).",
    "Dependencies":[
      "ev_SS",
      "ev"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2).",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2).",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2).",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition add1 : nat -> nat.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intro n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Defined.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print add1.",
    "Dependencies":null
  },
  {
    "Type":"Compute",
    "Chunk":"Compute add1 2.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Props.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module And.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive and (P Q : Prop) : Prop :=\n  | conj : P -> Q -> and P Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments conj [P] [Q].",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"P \/\\ Q\" := (and P Q) : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print prod.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem proj1' : forall P Q,\n  P \/\\ Q -> P.",
    "Dependencies":[
      "and"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HPQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct HPQ as [HP HQ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma and_comm : forall P Q : Prop, P \/\\ Q <-> Q \/\\ P.",
    "Dependencies":[
      "conj",
      "and"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [HP HQ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros [HQ HP].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End And.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition proj1'' P Q (HPQ : P \/\\ Q) : P :=\n  match HPQ with\n  | conj HP HQ => HP\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition and_comm'_aux P Q (H : P \/\\ Q) : Q \/\\ P :=\n  match H with\n  | conj HP HQ => conj HQ HP\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition and_comm' P Q : P \/\\ Q <-> Q \/\\ P :=\n  conj (and_comm'_aux P Q) (and_comm'_aux Q P).",
    "Dependencies":[
      "and_comm'_aux"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition conj_fact : forall P Q R, P \/\\ Q -> Q \/\\ R -> P \/\\ R\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive or (P Q : Prop) : Prop :=\n  | or_introl : P -> or P Q\n  | or_intror : Q -> or P Q.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments or_introl [P] [Q].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments or_intror [P] [Q].",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"P \\\/ Q\" := (or P Q) : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition inj_l : forall (P Q : Prop), P -> P \\\/ Q :=\n  fun P Q HP => or_introl HP.",
    "Dependencies":[
      "or_introl",
      "or"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem inj_l' : forall (P Q : Prop), P -> P \\\/ Q.",
    "Dependencies":[
      "or_introl",
      "or"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"left.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Show Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition or_elim : forall (P Q R : Prop), (P \\\/ Q) -> (P -> R) -> (Q -> R) -> R :=\n  fun P Q R HPQ HPR HQR =>\n    match HPQ with\n    | or_introl HP => HPR HP\n    | or_intror HQ => HQR HQ\n    end.",
    "Dependencies":[
      "or"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem or_elim' : forall (P Q R : Prop), (P \\\/ Q) -> (P -> R) -> (Q -> R) -> R.",
    "Dependencies":[
      "or"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros P Q R HPQ HPR HQR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct HPQ as [HP | HQ].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HPR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HP.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HQR.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply HQ.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition or_commut' : forall P Q, P \\\/ Q -> Q \\\/ P\n  .",
    "Dependencies":[
      "or"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ex {A : Type} (P : A -> Prop) : Prop :=\n  | ex_intro : forall x : A, P x -> ex P.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"'exists' x , p\" :=\n  (ex (fun x => p))\n    (at level 200, right associativity) : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ex (fun n => ev n) : Prop.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition some_nat_is_even : exists n, ev n :=\n  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0)).",
    "Dependencies":[
      "ex_intro",
      "ex",
      "ev_SS",
      "ev_0",
      "ev"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ex_ev_Sn : ex (fun n => ev (S n))\n  .",
    "Dependencies":[
      "ex",
      "ev"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition dist_exists_or_term (X:Type) (P Q : X -> Prop) :\n  (exists x, P x \\\/ Q x) -> (exists x, P x) \\\/ (exists x, Q x) :=\n  fun H => match H with\n           | ex_intro _ x Hx =>\n               match Hx with\n               | or_introl HPx => or_introl (ex_intro _ x HPx)\n               | or_intror HQx => or_intror (ex_intro _ x HQx)\n               end\n           end.",
    "Dependencies":[
      "ex_intro",
      "ex",
      "or_intror",
      "or_introl",
      "or"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ex_match : forall (A : Type) (P Q : A -> Prop),\n  (forall x, P x -> Q x) ->\n  (exists x, P x) -> (exists x, Q x)\n  .",
    "Dependencies":[
      "ex"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive True : Prop :=\n  | I : True.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition p_implies_true : forall P, P -> True\n  .",
    "Dependencies":[
      "True"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive False : Prop := .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail\n  Definition contra : False :=\n  42.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition false_implies_zero_eq_one : False -> 0 = 1 :=\n  fun contra => match contra with end.",
    "Dependencies":[
      "False"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition ex_falso_quodlibet' : forall P, False -> P\n  .",
    "Dependencies":[
      "False"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Props.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export EqualityPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive eq {X:Type} : X -> X -> Prop :=\n  | eq_refl : forall x, eq x x.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"x == y\" := (eq x y)\n                       (at level 70, no associativity)\n                     : type_scope.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma four: 2 + 2 == 1 + 3.",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition four' : 2 + 2 == 1 + 3 :=\n  eq_refl 4.",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition singleton : forall (X:Type) (x:X), []++[x] == x::[]  :=\n  fun (X:Type) (x:X) => eq_refl [x].",
    "Dependencies":[
      "app",
      "cons",
      "nil",
      "list",
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition eq_add : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2) :=\n  fun n1 n2 Heq =>\n    match Heq with\n    | eq_refl n => eq_refl (S n)\n    end.",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem eq_add' : forall (n1 n2 : nat), n1 == n2 -> (S n1) == (S n2).",
    "Dependencies":[
      "eq_refl",
      "eq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n1 n2 Heq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail rewrite Heq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"destruct Heq as [n].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply eq_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition eq_cons : forall (X : Type) (h1 h2 : X) (t1 t2 : list X),\n    h1 == h2 -> t1 == t2 -> h1 :: t1 == h2 :: t2\n  .",
    "Dependencies":[
      "cons",
      "list",
      "eq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma equality__leibniz_equality : forall (X : Type) (x y: X),\n  x == y -> forall (P : X -> Prop), P x -> P y.",
    "Dependencies":[
      "eq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition equality__leibniz_equality_term : forall (X : Type) (x y: X),\n    x == y -> forall P : (X -> Prop), P x -> P y\n  .",
    "Dependencies":[
      "eq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma leibniz_equality__equality : forall (X : Type) (x y: X),\n  (forall P:X->Prop, P x -> P y) -> x == y.",
    "Dependencies":[
      "eq"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End EqualityPlayground.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Definition or_bogus : forall P Q, P \\\/ Q -> P :=\n  fun (P Q : Prop) (A : P \\\/ Q) =>\n    match A with\n    | or_introl H => H\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Fixpoint infinite_loop {X : Type} (n : nat) {struct n} : X :=\n  infinite_loop n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Fail Definition falso : False := infinite_loop 0.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition and_assoc : forall P Q R : Prop,\n    P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R\n  .",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition and_assoc : forall P Q R : Prop,\n    P \/\\ (Q \/\\ R) -> (P \/\\ Q) \/\\ R\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition or_distributes_over_and : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)\n  .",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition or_distributes_over_and : forall P Q R : Prop,\n    P \\\/ (Q \/\\ R) <-> (P \\\/ Q) \/\\ (P \\\/ R)\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition double_neg : forall P : Prop,\n    P -> ~~P\n  .",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition double_neg : forall P : Prop,\n    P -> ~~P\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition contradiction_implies_anything : forall P Q : Prop,\n    (P \/\\ ~P) -> Q\n  .",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition contradiction_implies_anything : forall P Q : Prop,\n    (P \/\\ ~P) -> Q\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q\n  .",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition de_morgan_not_or : forall P Q : Prop,\n    ~ (P \\\/ Q) -> ~P \/\\ ~Q\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition curry : forall P Q R : Prop,\n    ((P \/\\ Q) -> R) -> (P -> (Q -> R))\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition uncurry : forall P Q R : Prop,\n    (P -> (Q -> R)) -> ((P \/\\ Q) -> R)\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition propositional_extensionality : Prop :=\n  forall (P Q : Prop), (P <-> Q) -> P = Q.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem pe_implies_or_eq :\n  propositional_extensionality ->\n  forall (P Q : Prop), (P \\\/ Q) = (Q \\\/ P).",
    "Dependencies":[
      "propositional_extensionality"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma pe_implies_true_eq :\n  propositional_extensionality ->\n  forall (P : Prop), P -> True = P.",
    "Dependencies":[
      "propositional_extensionality"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition proof_irrelevance : Prop :=\n  forall (P : Prop) (pf1 pf2 : P), pf1 = pf2.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem pe_implies_pi :\n  propositional_extensionality -> proof_irrelevance.",
    "Dependencies":[
      "proof_irrelevance",
      "propositional_extensionality"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End ProofObjects.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ProofObjects.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_IndPrinciples.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export IndPrinciples.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.ProofObjects.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n.",
    "Dependencies":[
      "S",
      "O",
      "nat"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mul_0_r' : forall n:nat,\n  n * 0 = 0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply nat_ind.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n' IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem plus_one_r' : forall n:nat,\n  n + 1 = S n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive time : Type :=\n  | day\n  | night.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check time_ind :\n  forall P : time -> Prop,\n    P day ->\n    P night ->\n    forall t : time, P t.",
    "Dependencies":[
      "night",
      "day",
      "time"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive rgb : Type :=\n  | red\n  | green\n  | blue.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check rgb_ind.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive natlist : Type :=\n  | nnil\n  | ncons (n : nat) (l : natlist).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l.",
    "Dependencies":[
      "ncons",
      "nnil",
      "natlist"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check natlist_ind :\n  forall P : natlist -> Prop,\n    P nnil  ->\n    (forall (n : nat) (l : natlist),\n        P l -> P (ncons n l)) ->\n    forall l : natlist, P l.",
    "Dependencies":[
      "cons",
      "nil",
      "natlist"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive natlist' : Type :=\n  | nnil'\n  | nsnoc (l : natlist') (n : nat).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check natlist'_ind :\n  forall P : natlist' -> Prop,\n    P nnil' ->\n    (forall l : natlist', P l -> forall n : nat, P (nsnoc l n)) ->\n    forall n : natlist', P n.",
    "Dependencies":[
      "nsnoc",
      "nnil'",
      "natlist'"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive booltree : Type :=\n  | bt_empty\n  | bt_leaf (b : bool)\n  | bt_branch (b : bool) (t1 t2 : booltree).",
    "Dependencies":[
      "bool"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition booltree_property_type : Type := booltree -> Prop.",
    "Dependencies":[
      "booltree"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition base_case (P : booltree_property_type) : Prop\n  .",
    "Dependencies":[
      "booltree_property_type"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition leaf_case (P : booltree_property_type) : Prop\n  .",
    "Dependencies":[
      "booltree_property_type"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition branch_case (P : booltree_property_type) : Prop\n  .",
    "Dependencies":[
      "booltree_property_type"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition booltree_ind_type :=\n  forall (P : booltree_property_type),\n    base_case P ->\n    leaf_case P ->\n    branch_case P ->\n    forall (b : booltree), P b.",
    "Dependencies":[
      "branch_case",
      "leaf_case",
      "base_case",
      "booltree_property_type",
      "booltree"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem booltree_ind_type_correct : booltree_ind_type.",
    "Dependencies":[
      "booltree_ind_type"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive Toy : Type :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem Toy_correct : exists f g,\n  forall P : Toy -> Prop,\n    (forall b : bool, P (f b)) ->\n    (forall (n : nat) (t : Toy), P t -> P (g n t)) ->\n    forall t : Toy, P t.",
    "Dependencies":[
      "Toy",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive tree (X:Type) : Type :=\n  | leaf (x : X)\n  | node (t1 t2 : tree X).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check tree_ind.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive foo' (X:Type) : Type :=\n  | C1 (l : list X) (f : foo' X)\n  | C2.",
    "Dependencies":[
      "list"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition P_m0r (n:nat) : Prop :=\n  n * 0 = 0.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition P_m0r' : nat -> Prop :=\n  fun n => n * 0 = 0.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem mul_0_r'' : forall n:nat,\n  P_m0r n.",
    "Dependencies":[
      "P_m0r"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply nat_ind.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n IHn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold P_m0r in IHn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold P_m0r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_assoc' : forall n m p : nat,\n  n + (m + p) = (n + m) + p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_comm' : forall n m : nat,\n  n + m = m + n.",
    "Dependencies":[
      "plus_n_Sm",
      "add_0_r"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [| n'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> add_0_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- plus_n_Sm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem add_comm'' : forall n m : nat,\n  n + m = m + n.",
    "Dependencies":[
      "plus_n_Sm",
      "add_0_r"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction m as [| m'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite -> add_0_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- IHm'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"rewrite <- plus_n_Sm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print ev.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check ev_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, ev n -> P n -> P (S (S n))) ->\n    forall n : nat, ev n -> P n.",
    "Dependencies":[
      "ev"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem ev_ev' : forall n, ev n -> ev' n.",
    "Dependencies":[
      "ev_ind",
      "ev",
      "ev'_sum",
      "ev'_2",
      "ev'_0",
      "ev'"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_ind.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev'_0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros m Hm IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply (ev'_sum 2 m).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev'_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IH.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive le1 : nat -> nat -> Prop :=\n  | le1_n : forall n, le1 n n\n  | le1_S : forall n m, (le1 n m) -> (le1 n (S m)).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"m <=1 n\" := (le1 m n) (at level 70).",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive le2 (n:nat) : nat -> Prop :=\n  | le2_n : le2 n n\n  | le2_S m (H : le2 n m) : le2 n (S m).",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"m <=2 n\" := (le2 m n) (at level 70).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check le1_ind :\n  forall P : nat -> nat -> Prop,\n    (forall n : nat, P n n) ->\n    (forall n m : nat, n <=1 m -> P n m -> P n (S m)) ->\n    forall n n0 : nat, n <=1 n0 -> P n n0.",
    "Dependencies":[
      "le1"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check le2_ind :\n  forall (n : nat) (P : nat -> Prop),\n    P n ->\n    (forall m : nat, n <=2 m -> P m -> P (S m)) ->\n    forall n0 : nat, n <=2 n0 -> P n0.",
    "Dependencies":[
      "le2"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check nat_ind :\n  forall P : nat -> Prop,\n    P 0 ->\n    (forall n : nat, P n -> P (S n)) ->\n    forall n : nat, P n.",
    "Dependencies":[
      "S",
      "O",
      "nat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Print nat_ind.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint build_proof\n         (P : nat -> Prop)\n         (evPO : P 0)\n         (evPS : forall n : nat, P n -> P (S n))\n         (n : nat) : P n :=\n  match n with\n  | 0 => evPO\n  | S k => evPS k (build_proof P evPO evPS k)\n  end.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition nat_ind_tidy := build_proof.",
    "Dependencies":[
      "build_proof"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition nat_ind2 :\n  forall (P : nat -> Prop),\n  P 0 ->\n  P 1 ->\n  (forall n : nat, P n -> P (S(S n))) ->\n  forall n : nat , P n :=\n    fun P => fun P0 => fun P1 => fun PSS =>\n      fix f (n:nat) := match n with\n                         0 => P0\n                       | 1 => P1\n                       | S (S n') => PSS n' (f n')\n                       end.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma even_ev : forall n, even n = true -> ev n.",
    "Dependencies":[
      "ev_SS",
      "ev_0",
      "ev",
      "nat_ind2",
      "even",
      "false",
      "true",
      "bool"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction n as [ | |n'] using nat_ind2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_0.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"simpl in H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply ev_SS.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHn'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Notation",
    "Chunk":"Notation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : core_scope.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive t_tree (X : Type) : Type :=\n| t_leaf\n| t_branch : (t_tree X * X * t_tree X) -> t_tree X.",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments t_leaf {X}.",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Arguments t_branch {X}.",
    "Dependencies":[
      "prod"
    ]
  },
  {
    "Type":"Check",
    "Chunk":"Check t_tree_ind.",
    "Dependencies":null
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end.",
    "Dependencies":[
      "pair",
      "prod",
      "t_branch",
      "t_leaf",
      "t_tree"
    ]
  },
  {
    "Type":"Fixpoint",
    "Chunk":"Fixpoint reflect {X : Type} (t : t_tree X) : t_tree X :=\n  match t with\n  | t_leaf => t_leaf\n  | t_branch (l, v, r) => t_branch (reflect r, v, reflect l)\n  end.",
    "Dependencies":[
      "false",
      "true"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition better_t_tree_ind_type : Prop\n  .",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition better_t_tree_ind : better_t_tree_ind_type\n  .",
    "Dependencies":[
      "better_t_tree_ind_type"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem reflect_involution : forall (X : Type) (t : t_tree X),\n    reflect (reflect t) = t.",
    "Dependencies":[
      "reflect",
      "t_tree"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End IndPrinciples.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_IndPrinciples.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_IndPrinciplesTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.IndPrinciples.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.IndPrinciples.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_one_r'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions booltree_ind_type_correct.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Toy_correct.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_IndPrinciplesTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_IndPropTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.IndProp.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.IndProp.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ev_double.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Perm3_ex1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Perm3_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions le_inversion.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions SSSSev__even.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ev5_nonsense.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ev_sum.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ev_ev__ev.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Perm3_In.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions le_trans.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions O_le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions n_le_m__Sn_le_Sm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Sn_le_Sm__n_le_m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions le_plus_l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_le.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_le_cases.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_le_compat_l.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_le_compat_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions le_plus_trans.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions subseq_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions subseq_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions subseq_trans.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions EmptySet_is_empty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions MUnion'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions MStar'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions re_not_empty.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions re_not_empty_correct.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Pumping.weak_pumping.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions reflect_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions eqbP_practice.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions merge_filter.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_IndPropTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_InductionTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Induction.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Induction.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions mul_0_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_n_Sm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions add_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions add_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions double_plus.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions eqb_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions add_shuffle3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions mul_comm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions bin_to_nat_pres_incr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions nat_bin_nat.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions double_incr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions double_bin_zero.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions double_incr_bin.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions bin_nat_bin.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_InductionTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ListsTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Lists.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Lists.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.snd_fst_is_swap.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_nonzeros.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_oddmembers.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_countoddmembers2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_countoddmembers3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_alternate1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_alternate2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_alternate4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_count2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_sum1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_add1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_add2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_member1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_member2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.app_nil_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.rev_app_distr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.rev_involutive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.app_assoc4.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.nonzeros_app.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.eqblist_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.count_member_nonzero.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.remove_does_not_increase_count.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.involution_injective.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.rev_injective.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_hd_error1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions NatList.test_hd_error2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions eqb_id_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions PartialMap.update_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions PartialMap.update_neq.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ListsTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_LogicTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Logic.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Logic.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_is_O.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions and_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions mult_is_O.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions or_commut.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions contrapositive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions not_both_true_and_false.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions de_morgan_not_or.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions or_distributes_over_and.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions dist_not_exists.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions dist_exists_or.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions In_map_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions In_app_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions All_In.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions even_double_conv.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions andb_true_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions orb_true_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions eqb_neq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions eqb_list_true_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions forallb_true_iff.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions tr_rev_correct.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions excluded_middle_irrefutable.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions not_exists_dist.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_LogicTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_MapsTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Maps.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Maps.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions t_update_same.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions t_update_permute.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_MapsTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_PolyTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Poly.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Poly.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions app_nil_r.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions app_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions app_length.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions rev_app_distr.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions rev_involutive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_filter_even_gt7_1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_filter_even_gt7_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions partition.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_partition1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_partition2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions map_rev.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions flat_map.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions test_flat_map1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.fold_length_correct.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.uncurry_curry.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.curry_uncurry.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.scc_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.scc_3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.plus_1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.plus_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.plus_3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.mult_1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.mult_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.mult_3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.exp_1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.exp_2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Exercises.Church.exp_3.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_PolyTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Postscript.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Postscript.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Postscript.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Postscript.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_PostscriptTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Postscript.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Postscript.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_PostscriptTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_Preface.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Preface.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Preface.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_Preface.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_PrefaceTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Preface.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Preface.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_PrefaceTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_ProofObjectsTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ProofObjects.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.ProofObjects.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ev_8.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions ev_8'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Props.conj_fact.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Props.or_commut'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Props.ex_ev_Sn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Props.ex_match.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Props.p_implies_true.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions Props.ex_falso_quodlibet'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions EqualityPlayground.eq_cons.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions EqualityPlayground.equality__leibniz_equality.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions EqualityPlayground.equality__leibniz_equality_term.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions and_assoc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions or_distributes_over_and.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions double_neg.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions contradiction_implies_anything.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions de_morgan_not_or.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions curry.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions uncurry.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions pe_implies_or_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions pe_implies_true_eq.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions pe_implies_pi.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_ProofObjectsTest.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export Rel.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export LF.IndProp.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition relation (X: Type) := X -> X -> Prop.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print le.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check le : nat -> nat -> Prop.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check le : nat -> nat -> Prop.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check le : relation nat.",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check le : relation nat.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition partial_function {X: Type} (R: relation X) :=\n  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive next_nat : nat -> nat -> Prop :=\n  | nn n : next_nat n (S n).",
    "Dependencies":null
  },
  {
    "Type":"Check",
    "Chunk":"Check next_nat : relation nat.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem next_nat_partial_function :\n  partial_function next_nat.",
    "Dependencies":[
      "next_nat",
      "partial_function"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold partial_function.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros x y1 y2 H1 H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"reflexivity.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_not_a_partial_function :\n  ~ (partial_function le).",
    "Dependencies":[
      "partial_function"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold not.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold partial_function.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros Hc.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"assert (0 = 1) as Nonsense.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"{",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hc with (x := 0).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"}",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"discriminate Nonsense.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive total_relation : nat -> nat -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem total_relation_not_partial_function :\n  ~ (partial_function total_relation).",
    "Dependencies":[
      "total_relation",
      "partial_function"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive empty_relation : nat -> nat -> Prop :=\n\n.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem empty_relation_partial_function :\n  partial_function empty_relation.",
    "Dependencies":[
      "empty_relation",
      "partial_function"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition reflexive {X: Type} (R: relation X) :=\n  forall a : X, R a a.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_reflexive :\n  reflexive le.",
    "Dependencies":[
      "reflexive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold reflexive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition transitive {X: Type} (R: relation X) :=\n  forall a b c : X, (R a b) -> (R b c) -> (R a c).",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_trans :\n  transitive le.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_trans :\n  transitive le.",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o Hnm Hmo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction Hmo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHHmo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lt_trans:\n  transitive lt.",
    "Dependencies":[
      "le_trans",
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold lt.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold transitive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o Hnm Hmo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S in Hnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S in Hnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (a := (S n)) (b := (S m)) (c := o).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (a := (S n)) (b := (S m)) (c := o).",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hnm.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply Hmo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lt_trans' :\n  transitive lt.",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold lt.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold transitive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o Hnm Hmo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction Hmo as [| m' Hm'o].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem lt_trans'' :\n  transitive lt.",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold lt.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold transitive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m o Hnm Hmo.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction o as [| o'].",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_Sn_le : forall n m, S n <= m -> n <= m.",
    "Dependencies":[
      "le_trans"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (S n).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with (S n).",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_S_n : forall n m,\n  (S n <= S m) -> (n <= m).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_Sn_n : forall n,\n  ~ (S n <= n).",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition symmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a).",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_not_symmetric :\n  ~ (symmetric le).",
    "Dependencies":[
      "symmetric"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition antisymmetric {X: Type} (R: relation X) :=\n  forall a b : X, (R a b) -> (R b a) -> a = b.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_antisymmetric :\n  antisymmetric le.",
    "Dependencies":[
      "antisymmetric"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_step : forall n m p,\n  n < m ->\n  m <= S p ->\n  n <= p.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Definition",
    "Chunk":"Definition equivalence {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (symmetric R) \/\\ (transitive R).",
    "Dependencies":[
      "symmetric",
      "transitive",
      "reflexive",
      "relation"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition order {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (antisymmetric R) \/\\ (transitive R).",
    "Dependencies":[
      "antisymmetric",
      "transitive",
      "reflexive",
      "relation"
    ]
  },
  {
    "Type":"Definition",
    "Chunk":"Definition preorder {X:Type} (R: relation X) :=\n  (reflexive R) \/\\ (transitive R).",
    "Dependencies":[
      "transitive",
      "reflexive",
      "relation"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem le_order :\n  order le.",
    "Dependencies":[
      "order",
      "le_antisymmetric",
      "antisymmetric",
      "le_trans",
      "transitive",
      "le_reflexive",
      "reflexive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"unfold order.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_reflexive.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_antisymmetric.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=\n  | rt_step x y (H : R x y) : clos_refl_trans R x y\n  | rt_refl x : clos_refl_trans R x x\n  | rt_trans x y z\n        (Hxy : clos_refl_trans R x y)\n        (Hyz : clos_refl_trans R y z) :\n        clos_refl_trans R x z.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem next_nat_closure_is_le : forall n m,\n  (n <= m) <-> ((clos_refl_trans next_nat) n m).",
    "Dependencies":[
      "clos_refl_trans_ind",
      "rt_trans",
      "rt_refl",
      "rt_step",
      "clos_refl_trans",
      "le_trans",
      "nn",
      "next_nat"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros n m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intro H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply rt_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply rt_trans with m.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply rt_trans with m.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHle.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply rt_step.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply nn.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"-",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intro H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"induction H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"inversion H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_S.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_n.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"+",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with y.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply le_trans with y.",
    "Dependencies":[
      "transitive"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHclos_refl_trans1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply IHclos_refl_trans2.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Inductive",
    "Chunk":"Inductive clos_refl_trans_1n {A : Type}\n                             (R : relation A) (x : A)\n                             : A -> Prop :=\n  | rt1n_refl : clos_refl_trans_1n R x x\n  | rt1n_trans (y z : A)\n      (Hxy : R x y) (Hrest : clos_refl_trans_1n R y z) :\n      clos_refl_trans_1n R x z.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma rsc_R : forall (X:Type) (R:relation X) (x y : X),\n  R x y -> clos_refl_trans_1n R x y.",
    "Dependencies":[
      "rt1n_trans",
      "rt1n_refl",
      "clos_refl_trans_1n",
      "relation"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"intros X R x y H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply rt1n_trans with y.",
    "Dependencies":[
      "relation"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"apply H.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"apply rt1n_refl.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Qed.",
    "Dependencies":null
  },
  {
    "Type":"Lemma",
    "Chunk":"Lemma rsc_trans :\n  forall (X:Type) (R: relation X) (x y z : X),\n      clos_refl_trans_1n R x y  ->\n      clos_refl_trans_1n R y z ->\n      clos_refl_trans_1n R x z.",
    "Dependencies":[
      "clos_refl_trans_1n",
      "relation"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"Theorem",
    "Chunk":"Theorem rtc_rsc_coincide :\n  forall (X:Type) (R: relation X) (x y : X),\n    clos_refl_trans R x y <-> clos_refl_trans_1n R x y.",
    "Dependencies":[
      "clos_refl_trans_1n",
      "clos_refl_trans",
      "relation"
    ]
  },
  {
    "Type":"Misc",
    "Chunk":"Proof.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Admitted.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End Rel.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF.",
    "Dependencies":null
  },
  {
    "Type":"Module",
    "Chunk":"Module Export LF_DOT_RelTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Rel.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Rel.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"End",
    "Chunk":"End LF_DOT_RelTest.",
    "Dependencies":null
  },
  {
    "Type":"global_directive",
    "Chunk":"Set Warnings \"-notation-overridden,-parsing\".",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Export Stdlib.Strings.String.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Tactics.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Parameter MISSING: Type.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac check_type A B :=\n    match type of A with\n    | context[MISSING] => idtac \"Missing:\" A\n    | ?T => first [unify T B; idtac \"Type: ok\" | idtac \"Type: wrong - should be (\" B \")\"]\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Ltac",
    "Chunk":"Ltac print_manual_grade A :=\n    match eval compute in A with\n    | Some (_ ?S ?C) =>\n        idtac \"Score:\"  S;\n        match eval compute in C with\n          | \"\"%string => idtac \"Comment: None\"\n          | _ => idtac \"Comment:\" C\n        end\n    | None =>\n        idtac \"Score: Ungraded\";\n        idtac \"Comment: None\"\n    end.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import LF.Tactics.",
    "Dependencies":null
  },
  {
    "Type":"Import",
    "Chunk":"Import Check.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions rev_exercise1.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions injection_ex3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions discriminate_ex3.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions eqb_true.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions plus_n_n_injective.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions nth_error_after_last.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions combine_split.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions bool_fn_applied_thrice.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions eqb_sym.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions filter_exercise.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"Print Assumptions existsb_existsb'.",
    "Dependencies":null
  },
  {
    "Type":"Misc",
    "Chunk":"",
    "Dependencies":null
  }
]